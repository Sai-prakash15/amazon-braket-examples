<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <!-- Generated with Sphinx 5.3.0 and Furo 2022.12.07 -->
        <title>Simulating noise on Amazon Braket - Amazon Braket Examples documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?digest=91d0f0d1c444bdcb17a68e833c7a53903343c195" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Amazon Braket Examples  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">Amazon Braket Examples  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  
</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="simulating-noise-on-amazon-braket">
<h1>Simulating noise on Amazon Braket<a class="headerlink" href="#simulating-noise-on-amazon-braket" title="Permalink to this heading">#</a></h1>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Use Braket SDK Cost Tracking to estimate the cost to run this example</span>
<span class="kn">from</span> <span class="nn">braket.tracking</span> <span class="kn">import</span> <span class="n">Tracker</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tracker</span><span class="p">()</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>This notebook gives a detailed overview of noise simulations on Amazon Braket. Amazon Braket provides two noise simulators: a local noise simulator that you can use for free as part of the Braket SDK and an on-demand, high-performing noise simulator, DM1. Both simulators are based on the density matrix formalism. After this tutorial, you will be able to define noise channels, apply noise to new or existing circuits, and run those circuits on the Braket noise simulators.</p>
<section id="table-of-contents">
<h2>Table of contents:<a class="headerlink" href="#table-of-contents" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p><span class="xref myst">Background</span></p>
<ul>
<li><p><span class="xref myst">Noise simulation based on the density matrix formalism</span></p></li>
<li><p><span class="xref myst">Quantum channel and Kraus representation</span></p></li>
</ul>
</li>
<li><p><span class="xref myst">General imports</span></p></li>
<li><p><span class="xref myst">Quick start</span></p></li>
<li><p><span class="xref myst">Defining noise channels</span></p>
<ul>
<li><p><span class="xref myst">Pre-defined noise channels</span></p></li>
<li><p><span class="xref myst">Defining custom noise channels</span></p></li>
</ul>
</li>
<li><p><span class="xref myst">Adding noise to a circuit</span></p>
<ul>
<li><p><span class="xref myst">Build noisy circuits bottom-up</span></p></li>
<li><p><span class="xref myst">Applying noise to existing circuits with global methods</span></p>
<ul>
<li><p><span class="xref myst">Applying gate noise to the circuit</span></p></li>
<li><p><span class="xref myst">Applying initialization noise to the circuit</span></p></li>
<li><p><span class="xref myst">Applying readout noise to the circuit</span></p></li>
</ul>
</li>
<li><p><span class="xref myst">Using both the direct and global methods to apply noise</span></p></li>
</ul>
</li>
<li><p><span class="xref myst">Running a noisy circuit</span></p></li>
</ul>
</section>
<section id="background-a-class-anchor-id-background-a">
<h2>Background <a class="anchor" id="Background"></a><a class="headerlink" href="#background-a-class-anchor-id-background-a" title="Permalink to this heading">#</a></h2>
<section id="noise-simulation-based-on-the-density-matrix-formalism-a-class-anchor-id-density-matrix-a">
<h3>Noise simulation based on the density matrix formalism <a class="anchor" id="density_matrix"></a><a class="headerlink" href="#noise-simulation-based-on-the-density-matrix-formalism-a-class-anchor-id-density-matrix-a" title="Permalink to this heading">#</a></h3>
<p>In an ideal case, a quantum state prepared by a noise-free circuit can be described by a state vector $|\psi\rangle$ – we call it a ‘pure state’. However, the presence of noise in realistic quantum devices will introduce classical uncertainty to the quantum state. For example, a bit flip error with 50% probability acting on a qubit flips the $|0\rangle$ state into either $|0\rangle$ or $|1\rangle$ with a 50-50 chance. Note that this is different from an Hadamard-gate acting on $|0\rangle$: The latter results in a coherent superposition of $|0\rangle$ and $|1\rangle$, whereas the former is a classical, so-called mixture of $|0\rangle$ and $|1\rangle$. The most general way of describing a quantum state in the presence of noise is through the so-called density matrix: $\rho = \sum_i p_i|\psi_i\rangle\langle\psi_i|$. It can be understood as a classical mixture of a series of pure states $|\psi_i\rangle$ (each of which could be highly entangled), where $p_i$ is the probability of the state being in $|\psi_i\rangle$. Because the $p_i$ are classical probabilities they have to sum up to 1: $\sum_i p_i = 1$. The density matrix of a pure state is simply $\rho = |\psi\rangle\langle\psi|$ and, in the bit-flip example from above, the density matrix would be $\rho = 0.5|0\rangle\langle 0| + 0.5|1\rangle\langle 1|$.</p>
<p>The density matrix formalism is a very useful way to describe a noisy system with probabilistic outcomes. It gives an exact description of a quantum system going through a quantum channel with noise. Besides, the expectation value of an observable $\langle O\rangle$ can be easily calculated by $\rm{Tr}(O\rho)$, where “$\rm{Tr}$” is the trace operator.</p>
</section>
<section id="quantum-channel-and-kraus-representation-a-class-anchor-id-quantum-channel-a">
<h3>Quantum channel and Kraus representation <a class="anchor" id="quantum_channel"></a><a class="headerlink" href="#quantum-channel-and-kraus-representation-a-class-anchor-id-quantum-channel-a" title="Permalink to this heading">#</a></h3>
<p>A <a class="reference external" href="https://en.wikipedia.org/wiki/Quantum_channel">quantum channel</a> describes the time evolution of a quantum state which is expressed as a density matrix. For instance, to understand what a series of noisy gates does to the state of a quantum computer, you can apply a quantum channel corresponding to the different gate and noise operations.
Mathematically speaking, a quantum channel is a completely positive and trace-preserving (CPTP) linear map acting on a density matrix. Completely positive means the channel maps positive operators into positive operators (even if the operator is applied to part of a larger system) to make sure the density matrix describes a proper quantum state after the map. Trace-preserving means the trace of the density matrix remains unchanged during the mapping process (this is so that after the map the classical probabilities $p_i$ still sum to 1).</p>
<p>The so-called <em>Kraus representation</em> is a commonly used representation for CPTP maps. <a class="reference external" href="https://en.wikipedia.org/wiki/Quantum_operation#Kraus_operators">Kraus’s theorem</a> states that any quantum operation acting on a quantum state $\rho$ can be expressed as a map $\varepsilon(\rho) = \sum_i K_i\rho K_i^{\dagger}$, and it satisfies: $\sum_i K_i^{\dagger}K_i = \mathbb{1}$, where $\mathbb{1}$ is the Identity operator.</p>
<p>Let’s get started and have a look how you can define and simulate noisy circuits on Amazon Braket.</p>
</section>
</section>
<section id="general-imports-a-class-anchor-id-imports-a">
<h2>General imports <a class="anchor" id="imports"></a><a class="headerlink" href="#general-imports-a-class-anchor-id-imports-a" title="Permalink to this heading">#</a></h2>
<p>Let’s begin with the usual imports.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">braket.circuits</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">Observable</span><span class="p">,</span> <span class="n">Gate</span><span class="p">,</span> <span class="n">Noise</span><span class="p">,</span> <span class="n">FreeParameter</span>
<span class="kn">from</span> <span class="nn">braket.devices</span> <span class="kn">import</span> <span class="n">LocalSimulator</span>
<span class="kn">from</span> <span class="nn">braket.aws</span> <span class="kn">import</span> <span class="n">AwsDevice</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">unitary_group</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="quick-start-a-class-anchor-id-start-a">
<h2>Quick start <a class="anchor" id="start"></a><a class="headerlink" href="#quick-start-a-class-anchor-id-start-a" title="Permalink to this heading">#</a></h2>
<p>Let’s start with a simple example of running a noisy circuit on Amazon Braket.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># build a simple circuit</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># define a noise channel</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">BitFlip</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># add noise to every gate in the circuit</span>
<span class="n">circ</span><span class="o">.</span><span class="n">apply_gate_noise</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>

<span class="c1"># select the local noise simulator</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">LocalSimulator</span><span class="p">(</span><span class="s1">&#39;braket_dm&#39;</span><span class="p">)</span>

<span class="c1"># run the circuit on the local simulator</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">shots</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">)</span>

<span class="c1"># visualize the results</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">measurement</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">measurement_counts</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;measurement results:&#39;</span><span class="p">,</span> <span class="n">measurement</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>measurement results: Counter({&#39;11&#39;: 441, &#39;00&#39;: 381, &#39;01&#39;: 94, &#39;10&#39;: 84})
</pre></div>
</div>
</div>
</div>
<p>Ideally, in the noise-free case, the circuit we defined prepares a Bell-state, and we would expect to measure only ‘00’ and ‘11’ outcomes. However, the presence of noise, in our case a bit flip error, means that sometimes we find the state in ‘01’ and ‘10’ instead.</p>
<p>The local simulator is suitable for fast prototyping on small circuits. If you want to run a noisy circuit with more than 10~12 qubits, we recommend using the on-demand simulator DM1. Using DM1, you can run circuits with up to 17 qubits, and benefit from parallel execution for a group of circuits. The code below shows an example of preparing a 13-qubit GHZ state in the presence of noise.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">ghz_circuit</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Circuit</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to return simple GHZ circuit ansatz. Assumes all qubits in range(0, n_qubits-1)</span>
<span class="sd">    are entangled.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>                        

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_qubits</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="n">control</span><span class="o">=</span><span class="n">ii</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  
    <span class="k">return</span> <span class="n">circuit</span>

<span class="c1"># build a 13-qubit GHZ circuit</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">ghz_circuit</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>

<span class="c1"># define a noise channel</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">Depolarizing</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># add noise to every gate in the circuit</span>
<span class="n">circ</span><span class="o">.</span><span class="n">apply_gate_noise</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>

<span class="c1"># select the on-demand density matrix simulator DM1</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">AwsDevice</span><span class="p">(</span><span class="s2">&quot;arn:aws:braket:::device/quantum-simulator/amazon/dm1&quot;</span><span class="p">)</span>

<span class="c1"># run the circuit on DM1</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">shots</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>

<span class="c1"># visualize the results</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">measurement</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">measurement_counts</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;measurement results:&#39;</span><span class="p">,</span> <span class="n">measurement</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>measurement results: Counter({&#39;0000000000000&#39;: 2, &#39;1100111111111&#39;: 1, &#39;0000000000001&#39;: 1, &#39;1000001111100&#39;: 1, &#39;1111100000000&#39;: 1, &#39;0000000010000&#39;: 1, &#39;1111111111111&#39;: 1, &#39;1000010000001&#39;: 1, &#39;0011111111111&#39;: 1})
</pre></div>
</div>
</div>
</div>
<p>We now start exploring the detailed instructions and use cases of each step in the following sections.</p>
</section>
<section id="defining-noise-channels-a-class-anchor-id-noise-channels-a">
<h2>Defining noise channels <a class="anchor" id="noise_channels"></a><a class="headerlink" href="#defining-noise-channels-a-class-anchor-id-noise-channels-a" title="Permalink to this heading">#</a></h2>
<p>To apply noise to a quantum circuit, first, you need to define the noise channel, which is defined in Kraus representation. We offer many commonly-used noise channels in the <code class="docutils literal notranslate"><span class="pre">Noise</span></code> class of the <a class="reference external" href="https://amazon-braket-sdk-python.readthedocs.io/en/latest/_apidoc/braket.circuits.html">Amazon Braket SDK</a>. In addition, you can also define your own custom noise channel as a list of Kraus operators.</p>
<section id="pre-defined-noise-channels-a-class-anchor-id-pre-defined-a">
<h3>Pre-defined noise channels <a class="anchor" id="pre-defined"></a><a class="headerlink" href="#pre-defined-noise-channels-a-class-anchor-id-pre-defined-a" title="Permalink to this heading">#</a></h3>
<p>The pre-defined single-qubit noise channels include <code class="docutils literal notranslate"><span class="pre">BitFlip</span></code>, <code class="docutils literal notranslate"><span class="pre">PhaseFlip</span></code>, <code class="docutils literal notranslate"><span class="pre">Depolarizing</span></code>, <code class="docutils literal notranslate"><span class="pre">AmplitudeDamping</span></code>, <code class="docutils literal notranslate"><span class="pre">GeneralizedAmplitudeDamping</span></code>, <code class="docutils literal notranslate"><span class="pre">PhaseDamping</span></code> and <code class="docutils literal notranslate"><span class="pre">PauliChannel</span></code>.
The pre-defined two-qubit noise channels include <code class="docutils literal notranslate"><span class="pre">TwoQubitDepolarizing</span></code> and <code class="docutils literal notranslate"><span class="pre">TwoQubitDephasing</span></code>. The Kraus representations for all of the pre-defined channels are summarized in the following table.</p>
<p><strong>single-qubit noise channels</strong></p>
<div class="table-wrapper colwidths-auto docutils container">
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="text-left head"><p>Noise channel</p></th>
<th class="text-left head"><p><div style="width:290px">Kraus representation</div></p></th>
<th class="text-left head"><p>Parameter</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">BitFlip</span></code></p></td>
<td class="text-left"><p>$(1-p)\rho$ + $pX\rho X$</p></td>
<td class="text-left"><p>$p$ is the probability of the bit flip noise.</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">PhaseFlip</span></code></p></td>
<td class="text-left"><p>$(1-p)\rho$ + $pZ\rho Z$</p></td>
<td class="text-left"><p>$p$ is the probability of the phase flip noise.</p></td>
</tr>
<tr class="row-even"><td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">Depolarizing</span></code></p></td>
<td class="text-left"><p>$(1-p)\rho$ + $p/3(X\rho X$ + $Y\rho Y$ + $Z\rho Z)$</p></td>
<td class="text-left"><p>$p$ is the probability of the depolarizing noise (the three possible error cases share the same probability of $p/3$).</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">AmplitudeDamping</span></code></p></td>
<td class="text-left"><p>$K_0\rho K_0^\dagger$ + $K_1\rho K_1^\dagger$</p></td>
<td class="text-left"><p>$K_0=[1,0;0,\sqrt{1-\gamma}]$, $K_1=[0,\sqrt{\gamma};0,0]$, where $\gamma$ is the rate of amplitude damping.</p></td>
</tr>
<tr class="row-even"><td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">GeneralizedAmplitudeDamping</span></code></p></td>
<td class="text-left"><p>$K_0\rho K_0^\dagger$ + $K_1\rho K_1^\dagger$ + $K_2\rho K_2^\dagger$ + $K_3 \rho K_3^\dagger$</p></td>
<td class="text-left"><p>$K_0=\sqrt{p}[1,0;0,\sqrt{1-\gamma}]$, $K_1=\sqrt{p}[0,\sqrt{\gamma};0,0]$, $K_2=\sqrt{1-p}[\sqrt{1-\gamma},0;0,1]$, $K_3=\sqrt{1-p}[0,0;\sqrt{\gamma},0]$, where $\gamma$ is the rate of amplitude damping, and $p$ is the probability of the system been excited by the environment [1].</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">PhaseDamping</span></code></p></td>
<td class="text-left"><p>$K_0\rho K_0^\dagger$ + $K_1 \rho K_1^\dagger$</p></td>
<td class="text-left"><p>$K_0=[1,0;0,\sqrt{1-\gamma}]$, $K_1=[0,0;0,\sqrt{\gamma}]$, where $\gamma$ is the rate of phase damping.</p></td>
</tr>
<tr class="row-even"><td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">PauliChannel</span></code></p></td>
<td class="text-left"><p>$(1-p_x-p_y-p_z)\rho$ + $p_xX\rho X$ + $p_yY\rho Y$ + $p_zZ\rho Z$</p></td>
<td class="text-left"><p>$p_x$, $p_y$ and $p_z$ are probabilities for the Pauli X, Y, Z noise respectively.</p></td>
</tr>
</tbody>
</table>
</div>
<p><strong>two-qubit noise channels</strong></p>
<div class="table-wrapper colwidths-auto docutils container">
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="text-left head"><p><div style="width:160px">Noise channel</div></p></th>
<th class="text-left head"><p><div style="width:290px">Kraus representation</div></p></th>
<th class="text-left head"><p>Parameter</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">TwoQubitDepolarizing</span></code></p></td>
<td class="text-left"><p>$(1-p)\rho$ + $p/15(IX\rho IX$ + $IY\rho IY$ + $IZ\rho IZ$ + $XI\rho XI$ +….+ $ZZ\rho ZZ)$</p></td>
<td class="text-left"><p>$p$ is the probability of the two-qubit depolarizing noise (the 15 possible error combinations share the same probability of $p/15$).</p></td>
</tr>
<tr class="row-odd"><td class="text-left"><p><code class="docutils literal notranslate"><span class="pre">TwoQubitDephasing</span></code></p></td>
<td class="text-left"><p>$(1-p)\rho$ + $p/3(IZ\rho IZ$ + $ZI\rho ZI$ + $ZZ\rho ZZ)$</p></td>
<td class="text-left"><p>$p$ is the probability of the two-qubit dephasing noise (the three possible error combinations share the same probability of $p/3$).</p></td>
</tr>
</tbody>
</table>
</div>
<p>The following code block takes the example of the bit flip noise channel: $\rho\rightarrow(1-p)\rho$ + $pX\rho X$, where $p$ corresponds to the <code class="docutils literal notranslate"><span class="pre">probability</span></code> parameter when defining the noise. This noise channel is equivalent to applying a bit flip error (applying an X gate) with probability $p$ and doing nothing with probability $1-p$. You can check the target qubit count and the Kraus operators of the noise channel defined.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># define a bit flip noise channel with probability = 0.1</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">BitFlip</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;name: &#39;</span><span class="p">,</span> <span class="n">noise</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;qubit count: &#39;</span><span class="p">,</span> <span class="n">noise</span><span class="o">.</span><span class="n">qubit_count</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Kraus operators: &#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">noise</span><span class="o">.</span><span class="n">to_matrix</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>name:  BitFlip
qubit count:  1
Kraus operators: 
[[0.9486833+0.j 0.       +0.j]
 [0.       +0.j 0.9486833+0.j]] 

[[0.        +0.j 0.31622777+0.j]
 [0.31622777+0.j 0.        +0.j]] 
</pre></div>
</div>
</div>
</div>
<p>Other pre-defined noise channels can be used in a similar way:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># define a phase flip noise channel</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">PhaseFlip</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="c1"># define a single-qubit depolarizing noise channel</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">Depolarizing</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="c1"># define a two-qubit depolarizing noise channel</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">TwoQubitDepolarizing</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="c1"># define a two-qubit dephasing noise channel</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">TwoQubitDephasing</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="c1"># define an amplitude damping noise channel</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">AmplitudeDamping</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="c1"># define a generalized amplitude damping noise, where gamma is the amplitude damping rate, and</span>
<span class="c1"># probability is the probability of the system being excited by the environment.</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">GeneralizedAmplitudeDamping</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="c1"># define a phase damping noise channel</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">PhaseDamping</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="c1"># define a Pauli noise channel</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">PauliChannel</span><span class="p">(</span><span class="n">probX</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">probY</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">probZ</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="defining-custom-noise-channels-a-class-anchor-id-self-defined-a">
<h3>Defining custom noise channels <a class="anchor" id="self-defined"></a><a class="headerlink" href="#defining-custom-noise-channels-a-class-anchor-id-self-defined-a" title="Permalink to this heading">#</a></h3>
<p>Apart from the pre-defined noise models, you can also define your own noise model by specifying a list of Kraus operators. The following code shows an example of defining a two-qubit Kraus channel with randomly generated unitary operators.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># create an arbitrary 2-qubit Kraus matrix</span>
<span class="n">E0</span> <span class="o">=</span> <span class="n">unitary_group</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span> 
<span class="n">E1</span> <span class="o">=</span> <span class="n">unitary_group</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.8</span><span class="p">)</span>
<span class="n">K</span> <span class="o">=</span> <span class="p">[</span><span class="n">E0</span><span class="p">,</span> <span class="n">E1</span><span class="p">]</span> 

<span class="c1"># define a two-qubit noise channel with Kraus operators</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">Kraus</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> 
</pre></div>
</div>
</div>
</div>
<p>Note that the noise channel you define needs to form a CPTP map. If the input matrices do not define a CPTP map, an error will be raised.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">K_invalid</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span> 

<span class="k">try</span><span class="p">:</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">Kraus</span><span class="p">(</span><span class="n">K_invalid</span><span class="p">)</span>
    <span class="k">pass</span>
<span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The input matrices do not define a completely-positive trace-preserving map.
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="adding-noise-to-a-circuit-a-class-anchor-id-apply-noise-a">
<h2>Adding noise to a circuit <a class="anchor" id="apply_noise"></a><a class="headerlink" href="#adding-noise-to-a-circuit-a-class-anchor-id-apply-noise-a" title="Permalink to this heading">#</a></h2>
<p>There are two methods to build a ‘noisy’ circuit. First, you can add noise to the circuit ‘bottom-up’, by using the noise operations in the same way as you would add a gate to the circuit. Second, you can use the methods <code class="docutils literal notranslate"><span class="pre">apply_gate_noise()</span></code>, <code class="docutils literal notranslate"><span class="pre">apply_initialization_noise()</span></code> and <code class="docutils literal notranslate"><span class="pre">apply_readout_noise()</span></code> to apply gate error, qubit initialization error and measurement error globally to existing circuits.</p>
<p>The direct method is more flexible as you can apply noise to any place in a circuit. But for an existing large circuit with lots of gates, you may want to use the global methods to conveniently apply noise to the circuit.</p>
<section id="build-noisy-circuits-bottom-up-a-class-anchor-id-apply-noise-directly-a">
<h3>Build noisy circuits bottom-up  <a class="anchor" id="apply_noise_directly"></a><a class="headerlink" href="#build-noisy-circuits-bottom-up-a-class-anchor-id-apply-noise-directly-a" title="Permalink to this heading">#</a></h3>
<p>Noise channels can be applied to the circuit the same way as gates. The following example shows how to apply single- and two-qubit noise channels directly to a circuit. The noise applied can be visualized in the circuit diagram with the <code class="docutils literal notranslate"><span class="pre">print()</span></code> method.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># apply depolarizing noise</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">depolarizing</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">two_qubit_dephasing</span><span class="p">(</span><span class="n">target1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">target2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>T  : |0|     1     |     2     |
                                
q0 : -X-C-----------X-DEPH(0.1)-
        |             |         
q1 : -X-X-DEPO(0.2)---DEPH(0.1)-

T  : |0|     1     |     2     |
</pre></div>
</div>
</div>
</div>
</section>
<section id="applying-noise-to-existing-circuits-with-global-methods-a-class-anchor-id-apply-noise-globally-a">
<h3>Applying noise to existing circuits with global methods<a class="anchor" id="apply_noise_globally"></a><a class="headerlink" href="#applying-noise-to-existing-circuits-with-global-methods-a-class-anchor-id-apply-noise-globally-a" title="Permalink to this heading">#</a></h3>
<p>We offer three methods to apply noise globally to the circuit: <code class="docutils literal notranslate"><span class="pre">apply_gate_noise()</span></code>, <code class="docutils literal notranslate"><span class="pre">apply_initialization_noise()</span></code> and <code class="docutils literal notranslate"><span class="pre">apply_readout_noise()</span></code>. In the following, we explain in detail the usage of these three methods.</p>
<section id="applying-gate-noise-to-the-circuit-a-class-anchor-id-gate-noise-a">
<h4>Applying gate noise to the circuit <a class="anchor" id="gate-noise"></a><a class="headerlink" href="#applying-gate-noise-to-the-circuit-a-class-anchor-id-gate-noise-a" title="Permalink to this heading">#</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">apply_gate_noise()</span></code> is the method to conveniently apply gate-noise to the circuit. It accepts the following input parameters:</p>
<ul class="simple">
<li><p><strong>noise</strong>: A single or a list of noise channel in <code class="docutils literal notranslate"><span class="pre">Noise</span></code> type.</p></li>
<li><p><strong>target_unitary</strong>: A single unitary gate in the form of a matrix in <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> type. The noise will be applied to that unitary gate.</p></li>
<li><p><strong>target_gates</strong>: A single or a list of gates in <code class="docutils literal notranslate"><span class="pre">Gate</span></code> type. Note that <code class="docutils literal notranslate"><span class="pre">target_gates</span></code> and <code class="docutils literal notranslate"><span class="pre">target_unitary</span></code> can not be provided at the same time. If none of <code class="docutils literal notranslate"><span class="pre">target_gates</span></code> and <code class="docutils literal notranslate"><span class="pre">target_unitary</span></code> is given, noise will be applied to all the gates in the circuit.</p></li>
<li><p><strong>target_qubits</strong>: A single or a list of qubit indexes. If not given, noise will be applied to all the qubits in the circuit.</p></li>
</ul>
<p>When calling the method, the noise channel(s) will be applied right after all <code class="docutils literal notranslate"><span class="pre">target_gates</span></code> in <code class="docutils literal notranslate"><span class="pre">target_qubits</span></code>.</p>
<div class="alert alert-block alert-info">
    <b>Note</b> When you call this method, noise will be inserted right after the gate. If you like to apply more than one noise operation, be aware of the order. Alternatively, you can provide a list of noise operations in one call, and the noise will be applied in forward order. 
</div><p>The code below is an example of applying phase damping noise to all gates in the circuit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">PhaseDamping</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># the noise channel is applied to every gate in the circuit</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">bit_flip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.1</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">apply_gate_noise</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Noise is applied to every gate in the circuit:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Noise is applied to every gate in the circuit:

T  : |        0        |    1    |
                                  
q0 : -X-PD(0.1)-BF(0.1)-C-PD(0.1)-
                        |         
q1 : -------------------X-PD(0.1)-

T  : |        0        |    1    |
</pre></div>
</div>
</div>
</div>
<p>If you want to apply noise to some particular gates in the circuit, you can specify them as <code class="docutils literal notranslate"><span class="pre">target_gates</span></code>. Below is an example in which noise is applied to all X gates in the circuit.</p>
<div class="alert alert-block alert-info">
    <b>Note</b> The <code>target_gates</code> must be a <code>Gate</code> type. You can find all available gates with the following commands:
<code>
from braket.circuits import Gate
gate_set = [attr for attr in dir(Gate) if attr[0] in string.ascii_uppercase]
print(gate_set)
</code>
</div><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># the noise channel is applied to all the X gates in the circuit</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">apply_gate_noise</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="n">target_gates</span> <span class="o">=</span> <span class="n">Gate</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Noise is applied to every X gate:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Noise is applied to every X gate:

T  : |    0    |     1     |2|
                              
q0 : -X-PD(0.1)-C-------------
                |             
q1 : -Y---------|-X-PD(0.1)---
                |             
q2 : -----------X-----------Z-

T  : |    0    |     1     |2|
</pre></div>
</div>
</div>
</div>
<p>If you define custom unitary gates as part of your circuit, and you want to apply noise to them, you can use the <code class="docutils literal notranslate"><span class="pre">target_unitary</span></code> criterion.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">U1</span><span class="o">=</span><span class="n">unitary_group</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">U2</span><span class="o">=</span><span class="n">unitary_group</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unitary</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">U1</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">unitary</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">U2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">apply_gate_noise</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="n">target_unitary</span> <span class="o">=</span> <span class="n">U2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Noise is applied to U2:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Noise is applied to U2:

T  : |0|1| 2 |3|    4    |
                          
q0 : -X-U-C---------------
        | |               
q1 : -Y-U-|-X---U-PD(0.1)-
          |     |         
q2 : -----X---Z-U-PD(0.1)-

T  : |0|1| 2 |3|    4    |
</pre></div>
</div>
</div>
</div>
<p>If you want to apply noise to some particular qubits in the circuit, you can specify them as <code class="docutils literal notranslate"><span class="pre">target_qubits</span></code>. Below is an example to apply noise to all gates in qubits 0 and 2 in the circuit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># the noise channel is applied to every gate on qubits 0 and 2</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">apply_gate_noise</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="n">target_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Noise is applied to every gate in qubits 0 and 2:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Noise is applied to every gate in qubits 0 and 2:

T  : |    0    |    1    |    2    |
                                    
q0 : -X-PD(0.1)-C-PD(0.1)-----------
                |                   
q1 : -Y---------|-X-----------------
                |                   
q2 : -----------X-PD(0.1)-Z-PD(0.1)-

T  : |    0    |    1    |    2    |
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">target_qubits</span></code> and <code class="docutils literal notranslate"><span class="pre">target_gates</span></code> criteria can be used at the same time. The code block below applies the gate noise to all X gates in qubit 0.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># the noise channel is applied to X gate on qubits 0</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">apply_gate_noise</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="n">target_gates</span> <span class="o">=</span> <span class="n">Gate</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">target_qubits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Noise is applied to X gates in qubits 0:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Noise is applied to X gates in qubits 0:

T  : |    0    | 1 |    2    |
                              
q0 : -X-PD(0.1)-C---X-PD(0.1)-
                |             
q1 : -Y---------|-X-----------
                |             
q2 : -----------X---Z---------

T  : |    0    | 1 |    2    |
</pre></div>
</div>
</div>
</div>
<p>If a list of noise channels is provided, the first noise channel in the list will be applied first, then the second.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># define two noise channels</span>
<span class="n">noise1</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">Depolarizing</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">noise2</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">BitFlip</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>

<span class="c1"># apply a list of noise channels </span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">apply_gate_noise</span><span class="p">([</span><span class="n">noise1</span><span class="p">,</span> <span class="n">noise2</span><span class="p">],</span> <span class="n">target_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Noise channels are applied to every gate in qubits 0 and 1:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Noise channels are applied to every gate in qubits 0 and 1:

T  : |         0         |              1              |2|
                                                          
q0 : -X-DEPO(0.1)-BF(0.2)-C-DEPO(0.1)-BF(0.2)-------------
                          |                               
q1 : -Y-DEPO(0.1)-BF(0.2)-|-X---------DEPO(0.1)-BF(0.2)---
                          |                               
q2 : ---------------------X-----------------------------Z-

T  : |         0         |              1              |2|
</pre></div>
</div>
</div>
</div>
<p>If you want to apply multi-qubit noise channels to a gate, the number of qubits associated with the gate must equal to the number of qubits defined by the noise channel, or otherwise the noise will not be applied. Below shows an example.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># define a two-qubit noise channel</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">TwoQubitDephasing</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># apply the noise to the circuit</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">apply_gate_noise</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The two-qubit noise channel is applied to all the two-qubit gates in the circuit:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The two-qubit noise channel is applied to all the two-qubit gates in the circuit:

T  : |0|      1      |      2       |
                                     
q0 : -X-C-DEPH(0.1)---SWAP-DEPH(0.1)-
        | |           |    |         
q1 : -Y-|-|---------X-SWAP-DEPH(0.1)-
        | |                          
q2 : ---X-DEPH(0.1)---Z--------------

T  : |0|      1      |      2       |
</pre></div>
</div>
</div>
</div>
</section>
<section id="applying-initialization-noise-to-the-circuit-a-class-anchor-id-initialization-noise-a">
<h4>Applying initialization noise to the circuit <a class="anchor" id="initialization-noise"></a><a class="headerlink" href="#applying-initialization-noise-to-the-circuit-a-class-anchor-id-initialization-noise-a" title="Permalink to this heading">#</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">apply_initialization_noise()</span></code> is the method to apply initialization noise to the circuit. By using the method, the noise will be applied to every qubit at the beginning of a circuit. It accepts the following input parameters:</p>
<ul class="simple">
<li><p><strong>noise</strong>: a single or a list of noise channel in <code class="docutils literal notranslate"><span class="pre">Noise</span></code> type.</p></li>
<li><p><strong>target_qubits</strong>: a single or a list of qubit indexes. If not given, noise will be applied to all the qubits in the circuit.</p></li>
</ul>
<p>If you want to apply the initialization noise to an empty circuit, you need to provide <code class="docutils literal notranslate"><span class="pre">target_qubits</span></code> to the method.</p>
<div class="alert alert-block alert-info">
    <b>Note</b> When you call this method, noise will be inserted at the very beginning of the circuit. If you like to apply more than one noise operation, be aware of the order. Alternatively, you can provide a list of noise operations in one call, and the noise will be applied in forward order. 
</div><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># define a noise channel</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">Depolarizing</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># the noise channel is applied as the initialization noise to the circuit</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">apply_initialization_noise</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initialization noise is applied to the circuit:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Initialization noise is applied to the circuit:

T  : |     0     | 1 |2|
                        
q0 : -DEPO(0.1)-X-C-----
                  |     
q1 : -DEPO(0.1)-Y-|-X---
                  |     
q2 : -DEPO(0.1)---X---Z-

T  : |     0     | 1 |2|
</pre></div>
</div>
</div>
</div>
<p>If you want to apply a multi-qubit noise channel as the initialization noise to a circuit and if the number of the qubits in the existing circuit doesn’t match the number of qubits as defined by the noise channel, you need to provide <code class="docutils literal notranslate"><span class="pre">target_qubits</span></code> with the number of qubits matching the noise channel.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># define a two-qubit noise channel</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">TwoQubitDephasing</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># the noise channel is applied as the initialization noise to the circuit</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">apply_initialization_noise</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initialization noise is applied to the circuit:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Initialization noise is applied to the circuit:

T  : |     0     |1|2|
                      
q0 : -DEPH(0.1)-X-C-Z-
      |           |   
q1 : -DEPH(0.1)-Y-X-X-

T  : |     0     |1|2|
</pre></div>
</div>
</div>
</div>
</section>
<section id="applying-readout-noise-to-the-circuit-a-class-anchor-id-readout-noise-a">
<h4>Applying readout noise to the circuit <a class="anchor" id="readout-noise"></a><a class="headerlink" href="#applying-readout-noise-to-the-circuit-a-class-anchor-id-readout-noise-a" title="Permalink to this heading">#</a></h4>
<p>The method of <code class="docutils literal notranslate"><span class="pre">apply_readout_noise()</span></code> is very similar to the method to apply initialization noise, except that the noise channel is applied to every qubit in the end of a circuit. It accepts the following input parameters:</p>
<ul class="simple">
<li><p><strong>noise</strong>: a single or a list of noise channel in <code class="docutils literal notranslate"><span class="pre">Noise</span></code> type.</p></li>
<li><p><strong>target_qubits</strong>: a single or a list of qubit indexes. If not given, noise will be applied to all the qubits in the circuit.</p></li>
</ul>
<p>If you want to apply the readout noise to an empty circuit, you need to provide <code class="docutils literal notranslate"><span class="pre">target_qubits</span></code> to the method.</p>
<div class="alert alert-block alert-info">
    <b>Note</b> When you call this method, noise will be inserted at the very end of the circuit. If you like to apply more than one noise operation, be aware of the order. You can also provide a list of noise operations in the one call, and the noise will be applied in forward order. 
</div><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># define a noise channel</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">Depolarizing</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

<span class="c1"># the noise channel is applied as the readout noise to the circuit</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">apply_readout_noise</span><span class="p">(</span><span class="n">noise</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Read-out noise is applied to the circuit:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Read-out noise is applied to the circuit:

T  : |0| 1 |         2         |
                                
q0 : -X-C---DEPO(0.1)-----------
        |                       
q1 : -Y-|-X-DEPO(0.1)-----------
        |                       
q2 : ---X---Z---------DEPO(0.1)-

T  : |0| 1 |         2         |
</pre></div>
</div>
</div>
</div>
<p>If you want to apply a multi-qubit noise channel as the readout noise to a circuit and if the number of the qubits in the existing circuit doesn’t match the number of qubits as defined by the noise channel, you need to provide <code class="docutils literal notranslate"><span class="pre">target_qubits</span></code> with the number of qubits matching the noise channel.</p>
</section>
</section>
<section id="using-both-the-direct-and-global-methods-to-apply-noise-a-class-anchor-id-both-a">
<h3>Using both the direct and global methods to apply noise <a class="anchor" id="both"></a><a class="headerlink" href="#using-both-the-direct-and-global-methods-to-apply-noise-a-class-anchor-id-both-a" title="Permalink to this heading">#</a></h3>
<p>You can apply noise to the circuit using both the direct and global methods.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># define a noise channel</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">PhaseFlip</span><span class="p">(</span><span class="n">probability</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>

<span class="c1"># create a circuit and add noise directly to the circuit</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">bit_flip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.1</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">two_qubit_depolarizing</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">apply_gate_noise</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="n">target_qubits</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Noise channels are applied to the circuit:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Noise channels are applied to the circuit:

T  : |        0        |     1     |2|
                                      
q0 : -X-PF(0.2)-BF(0.1)---------------
                                      
q1 : -Y-----------------C-DEPO(0.1)---
                        | |           
q2 : -------------------X-DEPO(0.1)-Z-

T  : |        0        |     1     |2|
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="running-a-noisy-circuit-a-class-anchor-id-run-a">
<h2>Running a noisy circuit <a class="anchor" id="run"></a><a class="headerlink" href="#running-a-noisy-circuit-a-class-anchor-id-run-a" title="Permalink to this heading">#</a></h2>
<p>Running a noisy circuit is like running any other task on Amazon Braket. In the example below we will pick the local simulator to run our circuit.</p>
<p>With shots = 0, you can obtain the exact values of probability, density matrix and expectation values of the mixed state by attaching the corresponding result type. The reduced density matrix is also available if providing the targets qubits. If no target qubit is provided, the full density matrix will be returned.</p>
<p>An example is shown in the code block below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># define the noise channel</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">AmplitudeDamping</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="c1"># create a circuit</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># apply the noise to qubits 0 and 2 in the circuit </span>
<span class="n">circ</span><span class="o">.</span><span class="n">apply_gate_noise</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="n">target_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>

<span class="c1"># attach the result types</span>
<span class="n">circ</span><span class="o">.</span><span class="n">probability</span><span class="p">()</span>
<span class="n">circ</span><span class="o">.</span><span class="n">expectation</span><span class="p">(</span><span class="n">observable</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="n">Z</span><span class="p">(),</span><span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="c1"># attach the density matrix with target=[0,1], and the reduced density matrix of qubits 0,1 will be returned</span>
<span class="n">circ</span><span class="o">.</span><span class="n">density_matrix</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>

<span class="c1"># choose the noise simulator, which is called &quot;braket_dm&quot;</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">LocalSimulator</span><span class="p">(</span><span class="s2">&quot;braket_dm&quot;</span><span class="p">)</span>
<span class="c1"># run the circuit</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>


<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;- Probability is: &#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;- Expectation value &lt;Z_0&gt; is: &#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;- The reduced Density Matrix is: &#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>T  : |    0    |    1    |    2    |              Result Types              |
                                                                             
q0 : -X-AD(0.1)-C-AD(0.1)-----------Probability-Expectation(Z)-DensityMatrix-
                |                   |                          |             
q1 : -Y---------|-X-----------------Probability----------------DensityMatrix-
                |                   |                                        
q2 : -----------X-AD(0.1)-Z-AD(0.1)-Probability------------------------------

T  : |    0    |    1    |    2    |              Result Types              |
- Probability is: 
[0.1171 0.0729 0.     0.     0.1539 0.6561 0.     0.    ]
- Expectation value &lt;Z_0&gt; is: 
-0.6199999999999997
- The reduced Density Matrix is: 
[[0.19+0.j 0.  +0.j 0.  +0.j 0.  +0.j]
 [0.  +0.j 0.  +0.j 0.  +0.j 0.  +0.j]
 [0.  +0.j 0.  +0.j 0.81+0.j 0.  +0.j]
 [0.  +0.j 0.  +0.j 0.  +0.j 0.  +0.j]]
</pre></div>
</div>
</div>
</div>
<p>With shots &gt; 0, the results are sampled from the probability distributions. The result type <code class="docutils literal notranslate"><span class="pre">density_matrix</span></code> is not available for shots &gt; 0.</p>
<p>The code below shows the expectation value $\langle Z_0\rangle$ and the probability that the mixed state collapsing into different states. We see those values here are different from the exact values obtained in the shots = 0 case.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># create a circuit</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">apply_gate_noise</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="n">target_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>

<span class="n">circ</span><span class="o">.</span><span class="n">probability</span><span class="p">()</span>
<span class="n">circ</span><span class="o">.</span><span class="n">expectation</span><span class="p">(</span><span class="n">observable</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="n">Z</span><span class="p">(),</span><span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>

<span class="c1"># run the circuit</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;- Probability is: &#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;- Expectation value &lt;Z_0&gt; is: &#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>T  : |    0    |    1    |    2    |       Result Types       |
                                                               
q0 : -X-AD(0.1)-C-AD(0.1)-----------Probability-Expectation(Z)-
                |                   |                          
q1 : -Y---------|-X-----------------Probability----------------
                |                   |                          
q2 : -----------X-AD(0.1)-Z-AD(0.1)-Probability----------------

T  : |    0    |    1    |    2    |       Result Types       |
- Probability is: 
[0.12 0.11 0.   0.   0.22 0.55 0.   0.  ]
- Expectation value &lt;Z_0&gt; is: 
-0.54
</pre></div>
</div>
</div>
</div>
<p>You can also create circuits with parametrized noise operations and specify the parameter values later:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># define the free parameter</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="n">FreeParameter</span><span class="p">(</span><span class="s1">&#39;gamma&#39;</span><span class="p">)</span>
<span class="c1"># define the noise channel</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">Noise</span><span class="o">.</span><span class="n">AmplitudeDamping</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="n">gamma</span><span class="p">)</span>
<span class="c1"># create a circuit</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">y</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">apply_gate_noise</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="n">target_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>

<span class="n">circ</span><span class="o">.</span><span class="n">probability</span><span class="p">()</span>
<span class="n">circ</span><span class="o">.</span><span class="n">expectation</span><span class="p">(</span><span class="n">observable</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="n">Z</span><span class="p">(),</span><span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>

<span class="c1"># run the circuit with gamma = 0.1</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circ</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">),</span> <span class="n">shots</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;- Probability when gamma=0.1 is: &#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;- Expectation value &lt;Z_0&gt;  when gamma=0.1 is: &#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># run the circuit with gamma = 0.3</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circ</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span><span class="mf">0.3</span><span class="p">),</span> <span class="n">shots</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;- Probability when gamma=0.3 is: &#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;- Expectation value &lt;Z_0&gt;  when gamma=0.3 is: &#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>T  : |     0     |     1     |     2     |       Result Types       |
                                                                     
q0 : -X-AD(gamma)-C-AD(gamma)-------------Probability-Expectation(Z)-
                  |                       |                          
q1 : -Y-----------|-X---------------------Probability----------------
                  |                       |                          
q2 : -------------X-AD(gamma)-Z-AD(gamma)-Probability----------------

T  : |     0     |     1     |     2     |       Result Types       |
- Probability when gamma=0.1 is: 
[0.12 0.18 0.   0.   0.09 0.61 0.   0.  ]
- Expectation value &lt;Z_0&gt;  when gamma=0.1 is: 
-0.4
- Probability when gamma=0.3 is: 
[0.42 0.1  0.   0.   0.21 0.27 0.   0.  ]
- Expectation value &lt;Z_0&gt;  when gamma=0.3 is: 
0.04
</pre></div>
</div>
</div>
</div>
</section>
<section id="reference">
<h2>Reference<a class="headerlink" href="#reference" title="Permalink to this heading">#</a></h2>
<p>[1] Srikanth R, Banerjee S. “Squeezed generalized amplitude damping channel”, Physical Review A, 2008, 77(1): 012318.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Task Summary&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">quantum_tasks_statistics</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Note: Charges shown are estimates based on your Amazon Braket simulator and quantum processing unit (QPU) task usage. Estimated charges shown may differ from your actual charges. Estimated charges do not factor in any discounts or credits, and you may experience additional charges based on your use of other services such as Amazon Elastic Compute Cloud (Amazon EC2).&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Estimated cost to run this example: </span><span class="si">{</span><span class="n">t</span><span class="o">.</span><span class="n">qpu_tasks_cost</span><span class="p">()</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">simulator_tasks_cost</span><span class="p">()</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> USD&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Task Summary
{&#39;arn:aws:braket:::device/quantum-simulator/amazon/dm1&#39;: {&#39;shots&#39;: 10, &#39;tasks&#39;: {&#39;COMPLETED&#39;: 1}, &#39;execution_duration&#39;: datetime.timedelta(microseconds=639000), &#39;billed_execution_duration&#39;: datetime.timedelta(seconds=3)}}
Note: Charges shown are estimates based on your Amazon Braket simulator and quantum processing unit (QPU) task usage. Estimated charges shown may differ from your actual charges. Estimated charges do not factor in any discounts or credits, and you may experience additional charges based on your use of other services such as Amazon Elastic Compute Cloud (Amazon EC2).
Estimated cost to run this example: 0.004 USD
</pre></div>
</div>
</div>
</div>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Simulating noise on Amazon Braket</a><ul>
<li><a class="reference internal" href="#table-of-contents">Table of contents:</a></li>
<li><a class="reference internal" href="#background-a-class-anchor-id-background-a">Background <a class="anchor" id="Background"></a></a><ul>
<li><a class="reference internal" href="#noise-simulation-based-on-the-density-matrix-formalism-a-class-anchor-id-density-matrix-a">Noise simulation based on the density matrix formalism <a class="anchor" id="density_matrix"></a></a></li>
<li><a class="reference internal" href="#quantum-channel-and-kraus-representation-a-class-anchor-id-quantum-channel-a">Quantum channel and Kraus representation <a class="anchor" id="quantum_channel"></a></a></li>
</ul>
</li>
<li><a class="reference internal" href="#general-imports-a-class-anchor-id-imports-a">General imports <a class="anchor" id="imports"></a></a></li>
<li><a class="reference internal" href="#quick-start-a-class-anchor-id-start-a">Quick start <a class="anchor" id="start"></a></a></li>
<li><a class="reference internal" href="#defining-noise-channels-a-class-anchor-id-noise-channels-a">Defining noise channels <a class="anchor" id="noise_channels"></a></a><ul>
<li><a class="reference internal" href="#pre-defined-noise-channels-a-class-anchor-id-pre-defined-a">Pre-defined noise channels <a class="anchor" id="pre-defined"></a></a></li>
<li><a class="reference internal" href="#defining-custom-noise-channels-a-class-anchor-id-self-defined-a">Defining custom noise channels <a class="anchor" id="self-defined"></a></a></li>
</ul>
</li>
<li><a class="reference internal" href="#adding-noise-to-a-circuit-a-class-anchor-id-apply-noise-a">Adding noise to a circuit <a class="anchor" id="apply_noise"></a></a><ul>
<li><a class="reference internal" href="#build-noisy-circuits-bottom-up-a-class-anchor-id-apply-noise-directly-a">Build noisy circuits bottom-up  <a class="anchor" id="apply_noise_directly"></a></a></li>
<li><a class="reference internal" href="#applying-noise-to-existing-circuits-with-global-methods-a-class-anchor-id-apply-noise-globally-a">Applying noise to existing circuits with global methods<a class="anchor" id="apply_noise_globally"></a></a><ul>
<li><a class="reference internal" href="#applying-gate-noise-to-the-circuit-a-class-anchor-id-gate-noise-a">Applying gate noise to the circuit <a class="anchor" id="gate-noise"></a></a></li>
<li><a class="reference internal" href="#applying-initialization-noise-to-the-circuit-a-class-anchor-id-initialization-noise-a">Applying initialization noise to the circuit <a class="anchor" id="initialization-noise"></a></a></li>
<li><a class="reference internal" href="#applying-readout-noise-to-the-circuit-a-class-anchor-id-readout-noise-a">Applying readout noise to the circuit <a class="anchor" id="readout-noise"></a></a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-both-the-direct-and-global-methods-to-apply-noise-a-class-anchor-id-both-a">Using both the direct and global methods to apply noise <a class="anchor" id="both"></a></a></li>
</ul>
</li>
<li><a class="reference internal" href="#running-a-noisy-circuit-a-class-anchor-id-run-a">Running a noisy circuit <a class="anchor" id="run"></a></a></li>
<li><a class="reference internal" href="#reference">Reference</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/scripts/furo.js"></script>
    </body>
</html>