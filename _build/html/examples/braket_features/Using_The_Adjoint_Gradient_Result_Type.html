<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <!-- Generated with Sphinx 5.3.0 and Furo 2022.12.07 -->
        <title>Using the Adjoint Gradient Result Type on Amazon Braket - Amazon Braket Examples documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?digest=91d0f0d1c444bdcb17a68e833c7a53903343c195" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Amazon Braket Examples  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">Amazon Braket Examples  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  
</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Use Braket SDK Cost Tracking to estimate the cost to run this example</span>
<span class="kn">from</span> <span class="nn">braket.tracking</span> <span class="kn">import</span> <span class="n">Tracker</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tracker</span><span class="p">()</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<section id="using-the-adjoint-gradient-result-type-on-amazon-braket">
<h1>Using the Adjoint Gradient Result Type on Amazon Braket<a class="headerlink" href="#using-the-adjoint-gradient-result-type-on-amazon-braket" title="Permalink to this heading">#</a></h1>
<p>In this tutorial we’ll introduce the <code class="docutils literal notranslate"><span class="pre">AdjointGradient</span></code> result type, discuss what a gradient is and how to compute one on a quantum circuit, explain how they can be used to accelerate your workflows, and show an example of gradients in action on a hybrid quantum algorithm.</p>
<div class="alert alert-block alert-info">
<b>Note:</b> This notebook requires amazon-braket-sdk-python>=1.35.0
</div><section id="table-of-contents">
<h2>Table of Contents<a class="headerlink" href="#table-of-contents" title="Permalink to this heading">#</a></h2>
<ul class="simple">
<li><p><span class="xref myst">Background: What is a gradient?</span></p></li>
<li><p><span class="xref myst">Why compute gradients?</span></p></li>
<li><p><span class="xref myst">Computing gradients of parameters in a quantum circuit</span></p>
<ul>
<li><p><span class="xref myst">Finite differences</span></p></li>
<li><p><span class="xref myst">Parameter shift</span></p></li>
<li><p><span class="xref myst">Adjoint gradient</span></p></li>
</ul>
</li>
<li><p><span class="xref myst">The <code class="docutils literal notranslate"><span class="pre">AdjointGradient</span></code> result type</span></p></li>
<li><p><span class="xref myst">Accelerating QAOA with <code class="docutils literal notranslate"><span class="pre">AdjointGradient</span></code></span></p></li>
</ul>
</section>
<section id="background-what-is-a-gradient">
<h2>Background: What is a gradient?<a class="headerlink" href="#background-what-is-a-gradient" title="Permalink to this heading">#</a></h2>
<p>A <a class="reference external" href="https://en.wikipedia.org/wiki/Gradient">gradient</a> refers to a vector derivative of a scalar-valued function of multiple variables. If we have a function $f(x)$, which depends only on $x$ and maps $x \to \mathbb{R}$ (maps $x$ to a single real number), then $f$’s gradient is just its derivative with respect to $x$: $\frac{df}{dx}$. The gradient is denoted $\nabla$, so that $\nabla f(x) = \frac{df}{dx}$. However, if $f$ is a function of multiple variables, mapping $\mathbb{R}^n \to \mathbb{R}$, we must take partial derivatives with respect to each variable. For example:</p>
<p>$$ \nabla f(x, y, z) = \left[\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y}, \frac{\partial f}{\partial z}\right] $$</p>
<p>The gradient of $f$ is itself a function and can be evaluated on specific values of $x$, $y$, and $z$. In general, for a function $f$ of $n$ independent real variables, $\nabla f$ is a length $n$ vector.</p>
</section>
<section id="why-compute-gradients">
<h2>Why compute gradients?<a class="headerlink" href="#why-compute-gradients" title="Permalink to this heading">#</a></h2>
<p>Gradients are of interest to us because many quantum algorithms – hybrid classical-quantum algorithms such as the quantum approximate optimization algorithm (QAOA) or the variational quantum eigensolver (VQE) especially – can be formulated as a problem of optimizing parameters (i.e. variables) in a quantum circuit with respect to some cost function, for example an expectation value of a Hamiltonian. To efficiently perform this optimization it’s common to use a gradient based optimization method, such as gradient descent (stochastic or not). An efficient means of computing gradients allows us to arrive at a good solution to the optimization problem in fewer circuit evaluations, and thus less cost.</p>
</section>
<section id="computing-gradients-of-parameters-in-a-quantum-circuit">
<h2>Computing gradients of parameters in a quantum circuit<a class="headerlink" href="#computing-gradients-of-parameters-in-a-quantum-circuit" title="Permalink to this heading">#</a></h2>
<p>Let’s make this a little more concrete. Suppose we have a quantum circuit which depends on a set of parameters $\vec{p}$. We can compactly represent this circuit as $U(\vec{p})$, where $U$ is the unitary that represents the action of all the gates in the circuit. Further suppose that after running this circuit, we will compute the expectation value of some operator $\hat{O}$ (for example, a Hamiltonian) and use the result to determine how good our choice of parameters $\vec{p}$ was. This situation arises often when running hybrid algorithms or quantum machine learning workflows.</p>
<div class="alert alert-block alert-info">
<b>Note</b> Although, for the sake of simplicity, we will only discuss measuring expectation values to generate the function to differentiate, one can equally well compute variances or any other scalar valued function.
</div>
<p>We can express this whole procedure as:</p>
<p>$$ f(\vec{p}) = \left\langle \psi \right| \hat{O} \left| \psi \right\rangle = \left\langle 0 U^\dagger(\vec{p}) \right| \hat{O} \left| U(\vec{p}) 0 \right\rangle $$</p>
<p>$f(\vec{p})$ is a scalar valued function and we can compute its gradient – all its partial derivatives with respect to the parameters $\vec{p}$ – in order to optimize those parameters. There are a variety of methods available to compute these derivatives, three of which will be discussed below. Of the three, the adjoint differentiation method is the fastest and most frugal in circuit executions and should be preferred when available, that is, when running on a state vector simulator in exact (<code class="docutils literal notranslate"><span class="pre">shots=0</span></code>) mode. We’ll introduce these other two common approaches to better understand the benefit of using the adjoint differentiation method.</p>
<section id="finite-differences">
<h3>Finite differences<a class="headerlink" href="#finite-differences" title="Permalink to this heading">#</a></h3>
<p>The <a class="reference external" href="https://en.wikipedia.org/wiki/Finite_difference">finite difference method</a> is a common technique used to approximate derivatives. Suppose we have a function $f(\vec{p})$ and we want to compute the $i$-th partial derivative of $f$, $\frac{\partial f}{\partial p_i}$. We can do so by approximating:</p>
<p>$$ \frac{\partial f}{\partial p_i} \approx \frac{f(p_1, p_2, …, p_i + h, …, p_n) - f(p_1, p_2, …, p_i, …, p_n)}{h} $$</p>
<p>Where $h$ is some small real number. This formula might seem familiar from introductory calculus.  The smaller $h$ is the better approximated the derivative is. By keeping all other parameters fixed, we can approximate the partial derivative with respect to $p_i$, but as we can see, computing <em>each</em> partial derivative would require <em>two</em> full circuit executions (one to compute each value of $f$). Thus, the total number of circuit executions needed to compute the gradient of $f$ for <em>one</em> set of values $\vec{p}$ would be $2n$, if the length of $p$ is $n$.</p>
<p>For a quantum circuit there can be additional problems. On a real quantum device, we can’t compute the exact expectation value (or variance) of a circuit. We can only run many shots, each of which is a full circuit execution, and approximate the expectation value from the measurement statistics that result. This means that for very small $h$, it may be very difficult to approximate the gradient accurately.</p>
</section>
<section id="parameter-shift-rules">
<h3>Parameter shift rules<a class="headerlink" href="#parameter-shift-rules" title="Permalink to this heading">#</a></h3>
<p>Let’s return to our original formula for the gradient of $f$:</p>
<p>$$ \nabla f(\vec{p}) = \left(\frac{\partial f}{\partial p_1}, \ldots , \frac{\partial f}{\partial p_n}\right) $$</p>
<p>and examine one of the vector elements a little more closely:</p>
<p>$$ \frac{\partial f}{\partial p_i} = \frac{\partial}{\partial p_i} \left\langle 0 U^\dagger(\vec{p}) \right| \hat{O} \left| U(\vec{p}) 0 \right\rangle = \frac{\partial}{\partial p_i} \left\langle 0 \right| U^\dagger(\vec{p}) \hat{O} U(\vec{p}) \left| 0 \right\rangle $$</p>
<p>We can pull the derivative operator inside the expectation value so that:</p>
<p>$$ \frac{\partial f}{\partial p_i} = \left\langle 0 \left|\frac{\partial}{\partial p_i} \left( U^\dagger(\vec{p}) \hat{O} U(\vec{p})\right) \right| 0 \right\rangle $$</p>
<p>We’ll assume that each gate depends on at most one parameter, and each parameter appears in only one gate. What if we have repeated parameters? We can write down a mapping of each repeated parameter to a unique copy and sum the derivatives of those copies at the end using the <a class="reference external" href="https://en.wikipedia.org/wiki/Product_rule">product rule</a>. But for now, for simplicity we will assume that each parameter appears only once and each gate has at most one parameter. Further we’ll state that gate $i$ is associated with the $i$-th parameter (every gate has a parameter). If non-parametrized gates are present, we can contract them into parametrized gates to achieve this, or assign them constant parameters (remember, the derivative of a constant is always 0).</p>
<p>We can write that the overall circuit unitary $U$ is a product of individual gates:</p>
<p>$$ U(\vec{p}) = \otimes_{i=1}^N U_{i}(p_i) $$</p>
<p>if there are $N$ gates in the circuit.</p>
<p>Then, using the product rule, we can write:</p>
<p>$$ \frac{\partial f}{\partial p_i} = \left\langle 0 \left| \otimes_{j=1}^{i-1} U^\dagger_j \otimes \frac{\partial U^\dagger_i(p_i)}{\partial p_i} \otimes_{j=i+1}^{n} U^\dagger_j \hat{O} U(\vec{p}) + U^\dagger(\vec{p}) \hat{O}\otimes_{j=i+1}^{n} U_j \otimes \frac{\partial U_i(p_i)}{\partial p_i}\otimes_{j=1}^{i-1} U_j \right| 0 \right\rangle $$</p>
<p>We can absorb the non-differentiated products so that:</p>
<p>$$ \frac{\partial f}{\partial p_i} = \left\langle \phi \left| \frac{\partial U^\dagger_i(p_i)}{\partial p_i} \hat{\mathcal{O}}U_i(p_i) + U^\dagger_i(p_i)\hat{\mathcal{O}}\frac{\partial U_i(p_i)}{\partial p_i}\right| \phi \right\rangle $$</p>
<p>where</p>
<p>$$ \phi = \otimes_{j=1}^{i-1} U_j \left| 0 \right\rangle $$</p>
<p>and</p>
<p>$$ \hat{\mathcal{O}} = \otimes_{j=i+1}^{n} U^\dagger_j  \hat{O} \otimes_{j=i+1}^{n} U_j $$.</p>
<p>Now we can see that</p>
<p>$$ \frac{\partial U^\dagger_i(p_i)}{\partial p_i} \hat{\mathcal{O}}U_i(p_i) + U^\dagger_i(p_i)\hat{\mathcal{O}}\frac{\partial U_i(p_i)}{\partial p_i} = \frac{\partial}{\partial p_i} \left( U_i^\dagger(p_i) \hat{\mathcal{O}} U_i(p_i)\right) $$</p>
<p>so, in sum:</p>
<p>$$ \frac{\partial f}{\partial p_i} = \left\langle \phi \left|\frac{\partial}{\partial p_i} \left( U_i^\dagger(p_i) \hat{\mathcal{O}} U_i(p_i)\right)\right| \phi \right\rangle $$</p>
<p>and in many cases (but not all!) we can define a <em>shift</em> $s$ such that:</p>
<p>$$ \frac{\partial}{\partial p_i} \left( U_i^\dagger(p_i) \hat{\mathcal{O}} U_i(p_i)\right) = U_i^\dagger(p_i + s) \hat{\mathcal{O}} U_i(p_i + s) - U_i^\dagger(p_i - s) \hat{\mathcal{O}} U_i(p_i - s) $$</p>
<p>Thus the name “parameter shift”. What makes this different from the finite differences method is that $s$ is not necessarily small. Detailed guides to choosing shifts and identifying which gates support the method can be found in Refs. <a class="reference external" href="https://arxiv.org/abs/1803.00745">1</a> and <a class="reference external" href="https://arxiv.org/abs/1811.11184">2</a>. If a gate does <em>not</em> support a parameter shift rule, we can always fall back to the finite difference method.</p>
<p>We can see that the parameter shift method <em>also</em> requires two circuit executions to compute the partial derivative of each parametrized gate. The advantage over finite difference is in numerical accuracy. Parameter shift can be used both when <code class="docutils literal notranslate"><span class="pre">shots=0</span></code> or when <code class="docutils literal notranslate"><span class="pre">shots&gt;0</span></code>. Since the introduction of the method, many extensions and generalizations have been published, including Refs. <a class="reference external" href="https://arxiv.org/abs/2107.12390">3</a>, <a class="reference external" href="https://arxiv.org/abs/2005.10299">4</a>, and many more.</p>
</section>
<section id="adjoint-differentiation">
<h3>Adjoint differentiation<a class="headerlink" href="#adjoint-differentiation" title="Permalink to this heading">#</a></h3>
<p>The two methods we’ve examined so far, finite differences and parameter shift, both require two full circuit executions per parameter to compute the gradient. This can become very expensive, in both time and charges, for deep circuits and/or circuits with many parameters. Is there a way to compute gradients in a more “execution-frugal” way? For <code class="docutils literal notranslate"><span class="pre">shots=0</span></code>, the answer is yes. First introduced in Ref. <a class="reference external" href="https://arxiv.org/abs/2009.02823">5</a>, the adjoint differentiation method allows us to compute all partial derivatives in “1+1” circuit executions. How does it work? Recall that:</p>
<p>$$ \frac{\partial f}{\partial p_i} = \left\langle 0 \left| \otimes_{j=1}^{i-1} U^\dagger_j \otimes \frac{\partial U^\dagger_i(p_i)}{\partial p_i} \otimes_{j=i+1}^{n} U^\dagger_j \hat{O} U(\vec{p}) + U^\dagger(\vec{p}) \hat{O}\otimes_{j=i+1}^{n} U_j \otimes \frac{\partial U_i(p_i)}{\partial p_i}\otimes_{j=1}^{i-1} U_j \right| 0 \right\rangle $$</p>
<p>In the adjoint method, we take a different approach to computing this derivative. We realize that:</p>
<p>$$ \left( \left \langle 0 \left| \otimes_{j=1}^{i-1} U^\dagger_j \otimes \frac{\partial U^\dagger_i(p_i)}{\partial p_i} \otimes_{j=i+1}^{n} U^\dagger_j \hat{O} U(\vec{p}) \right| 0 \right\rangle \right)^\dagger = \left \langle 0 \left| U^\dagger(\vec{p}) \hat{O}\otimes_{j=i+1}^{n} U_j \otimes \frac{\partial U_i(p_i)}{\partial p_i}\otimes_{j=1}^{i-1} U_j \right| 0 \right\rangle$$</p>
<p>and thus, because all the gates are unitaries and the operator $\hat{O}$ is Hermitian,</p>
<p>$$ \frac{\partial f}{\partial p_i} = 2\Re \left\langle 0 \left| U^\dagger(\vec{p}) \hat{O}\otimes_{j=i+1}^{n} U_j \otimes \frac{\partial U_i(p_i)}{\partial p_i}\otimes_{j=1}^{i-1} U_j \right| 0 \right\rangle $$</p>
<p>where $\Re$ denotes the real part. Now we can absorb some factors so that:</p>
<p>$$ \frac{\partial f}{\partial p_i} = 2\Re \left\langle b_i \left| \frac{\partial U_i(p_i)}{\partial p_i} \right| k_i \right\rangle $$</p>
<p>where</p>
<p>$$ \left\langle b_i \right| = \left\langle 0 \right| U^\dagger(\vec{p}) \hat{O}\otimes_{j=i+1}^{n} U_j(p_j) $$</p>
<p>and</p>
<p>$$ \left | k_i \right\rangle = \otimes_{j=1}^{i-1} U_j(p_j) \left| 0 \right\rangle $$</p>
<p>The basis of the adjoint method is realizing that we can iteratively compute each partial derivative by “back stepping” through the circuit after having applied all its gates once. This is very similar to classical back propagation, if you’re familiar with that technique from classical machine learning. We first apply all gates to compute $ \left| k_n \right\rangle = \otimes_{j=1}^{n} U_j \left| 0 \right\rangle $, copy the state and apply $\hat{O}$ to acquire:</p>
<p>$$ \left\langle b_n \right| = \left\langle 0 \right| U^\dagger(\vec{p}) \hat{O} $$</p>
<p>then compute $\frac{\partial f}{\partial p_n}$:</p>
<p>$$ \frac{\partial f}{\partial p_n} = \left\langle b_n \left|\frac{\partial U_n(p_n)}{\partial p_n}\right| k_n \right\rangle $$</p>
<p>In a moment we’ll address how to find $\frac{\partial U_n(p_n)}{\partial p_n}$. Once we’ve computed the first partial derivative, we update $\left\langle b_n\right|$ and $ \left| k_n \right\rangle$ to generate:</p>
<p>$$ \left\langle b_{n-1} \right| = \left\langle b_n \right| U_n(p_n) $$
$$ \left | k_{n-1} \right\rangle =  U^\dagger_{n-1} \left| k_n \right\rangle $$</p>
<p>By iteratively updating these two states, we can compute all partial derivatives with only one circuit execution plus one “back step” execution, significantly less than what is required by finite differences or parameter shift. The cost is that there is additional memory overhead, as we have to store an additional state vector and compute a third in the expectation value $\left\langle b_i \left|\frac{\partial U_i(p_i)}{\partial p_i}\right| k_i \right\rangle$.</p>
<p>How do we compute the derivative $\frac{\partial U_i(p_i)}{\partial p_i}$? In many cases, if $U_i(p_i)$ is continually differentiable with respect to $p_i$, we can simply take a matrix derivative. In particular, many parametrizable gates can be written as exponentials of Paulis, so that:</p>
<p>$$ \frac{\partial U_i(p_i)}{\partial p_i} = \frac{\partial}{\partial p_i}\exp\left{ i c p_i \hat{P}\right} = i c \hat{P} \exp\left{ i c p_i \hat{P}\right} $$</p>
<p>where $c$ is some constant, $\hat{P}$ is some Pauli gate, and $i$ is the imaginary number $\sqrt{-1}$. This is easily generalizable to exponents of sums of Paulis through the <a class="reference external" href="https://en.wikipedia.org/wiki/Chain_rule">chain rule</a>. In cases where $U(p_i)$ is <em>not</em> continuously differentiable, the derivative can be computed numerically, e.g. through finite differences as discussed above.</p>
<div class="alert alert-block alert-info">
<b>Note</b> Because it is formulated <b>only</b> for exact computations, the adjoint method can only be used on simulators, such as SV1, when running with <code>shots=0</code>.
</div>
<p>The adjoint differentiation method is available through the <code class="docutils literal notranslate"><span class="pre">AdjointGradient</span></code> result type on Amazon Braket, which we’ll introduce in the next section. With this result type, all gradients are computed using the adjoint differentiation method.</p>
</section>
</section>
<section id="the-adjointgradient-result-type">
<h2>The <code class="docutils literal notranslate"><span class="pre">AdjointGradient</span></code> Result Type<a class="headerlink" href="#the-adjointgradient-result-type" title="Permalink to this heading">#</a></h2>
<p>Amazon Braket now supports a result type, <code class="docutils literal notranslate"><span class="pre">AdjointGradient</span></code>, which allows you to conveniently compute gradients of free parameters with respect to the expectation value of some observable on your circuits.</p>
<div class="alert alert-block alert-info">
<b>Note</b> Currently, the <code>AdjointGradient</code> result type is <b>only</b> supported on SV1 when running in <code>shots=0</code> mode. All gradients are computed using the adjoint differentiation method.
</div>
<p>Let’s see an example of this result type in action:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># general imports</span>
<span class="o">!</span> pip install seaborn
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="c1"># magic line for producing visualizations in notebook</span>
<span class="o">%</span><span class="k">matplotlib</span> inline

<span class="c1"># AWS imports: Import Braket SDK modules</span>
<span class="kn">from</span> <span class="nn">braket.circuits</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">Observable</span><span class="p">,</span> <span class="n">FreeParameter</span>
<span class="kn">from</span> <span class="nn">braket.aws</span> <span class="kn">import</span> <span class="n">AwsSession</span><span class="p">,</span> <span class="n">AwsDevice</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">device_arn</span> <span class="o">=</span> <span class="s2">&quot;arn:aws:braket:::device/quantum-simulator/amazon/sv1&quot;</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">AwsDevice</span><span class="p">(</span><span class="n">device_arn</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can prepare a simple parametrized circuit and compute its gradient with respect to some observable. Note that you supply the observable to the <code class="docutils literal notranslate"><span class="pre">AdjointGradient</span></code> result type. Supported observables are:</p>
<ul class="simple">
<li><p>Any of <code class="docutils literal notranslate"><span class="pre">Observable.Z()</span></code>, <code class="docutils literal notranslate"><span class="pre">Observable.X()</span></code>, <code class="docutils literal notranslate"><span class="pre">Observable.Y()</span></code>, <code class="docutils literal notranslate"><span class="pre">Observable.H()</span></code>, or <code class="docutils literal notranslate"><span class="pre">Observable.I()</span></code></p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">TensorProduct</span></code></p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">Hermitian</span></code></p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">Sum</span></code></p></li>
</ul>
<p>You can also supply the list of parameters to compute partial derivatives with respect to. If a parameter is present in the circuit, but not in the <code class="docutils literal notranslate"><span class="pre">parameters</span></code> argument to <code class="docutils literal notranslate"><span class="pre">adjoint_gradient</span></code>, its corresponding partial derivative will not be computed. If the list of <code class="docutils literal notranslate"><span class="pre">parameters</span></code> is empty, the gradient will be computed with respect to all free parameters present in the circuit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">theta</span> <span class="o">=</span> <span class="n">FreeParameter</span><span class="p">(</span><span class="s1">&#39;theta&#39;</span><span class="p">)</span>
<span class="n">gamma</span> <span class="o">=</span> <span class="n">FreeParameter</span><span class="p">(</span><span class="s1">&#39;gamma&#39;</span><span class="p">)</span>
<span class="n">circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span><span class="o">.</span><span class="n">xx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
<span class="c1"># add the adjoint gradient result type</span>
<span class="c1">#circuit.adjoint_gradient(observable = Observable.Z() @ Observable.Z(), target = [0, 1], parameters=[&#39;theta&#39;, gamma])</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">adjoint_gradient</span><span class="p">(</span><span class="n">observable</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="n">Z</span><span class="p">()</span> <span class="o">@</span> <span class="n">Observable</span><span class="o">.</span><span class="n">Z</span><span class="p">(),</span> <span class="n">target</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">parameters</span><span class="o">=</span><span class="p">[])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Circuit(&#39;instructions&#39;: [Instruction(&#39;operator&#39;: H(&#39;qubit_count&#39;: 1), &#39;target&#39;: QubitSet([Qubit(0)])), Instruction(&#39;operator&#39;: CNot(&#39;qubit_count&#39;: 2), &#39;target&#39;: QubitSet([Qubit(0), Qubit(1)])), Instruction(&#39;operator&#39;: Rx(&#39;angle&#39;: theta, &#39;qubit_count&#39;: 1), &#39;target&#39;: QubitSet([Qubit(0)])), Instruction(&#39;operator&#39;: Rx(&#39;angle&#39;: theta, &#39;qubit_count&#39;: 1), &#39;target&#39;: QubitSet([Qubit(1)])), Instruction(&#39;operator&#39;: XX(&#39;angle&#39;: gamma, &#39;qubit_count&#39;: 2), &#39;target&#39;: QubitSet([Qubit(0), Qubit(1)]))], &#39;result_types&#39;: [AdjointGradient(observable=TensorProduct(Z(&#39;qubit_count&#39;: 1), Z(&#39;qubit_count&#39;: 1)), target=QubitSet([Qubit(0), Qubit(1)]), parameters=[])])
</pre></div>
</div>
</div>
</div>
<p>Now we can compute the gradient of the circuit with respect to our two free parameters for a given set of parameter values, which we supply to <code class="docutils literal notranslate"><span class="pre">device.run</span></code> with the <code class="docutils literal notranslate"><span class="pre">inputs</span></code> argument:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">result_1</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;theta&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="mf">0.05</span><span class="p">})</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">result_2</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;theta&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">})</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Gradient when theta = 0.1, gamma = 0.05: </span><span class="si">{</span><span class="n">result_1</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Gradient when theta = 0.2, gamma = 0.1: </span><span class="si">{</span><span class="n">result_2</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Gradient when theta = 0.1, gamma = 0.05: {&#39;expectation&#39;: 0.9800665778412416, &#39;gradient&#39;: {&#39;gamma&#39;: 6.938893903907228e-18, &#39;theta&#39;: -0.3973386615901225}}
Gradient when theta = 0.2, gamma = 0.1: {&#39;expectation&#39;: 0.9210609940028854, &#39;gradient&#39;: {&#39;gamma&#39;: -4.336808689942018e-19, &#39;theta&#39;: -0.7788366846173014}}
</pre></div>
</div>
</div>
</div>
<p>We can immediately see that although <code class="docutils literal notranslate"><span class="pre">theta</span></code> appears twice in the circuit (in two <code class="docutils literal notranslate"><span class="pre">Rx</span></code> gates), it only appears once in the result. <code class="docutils literal notranslate"><span class="pre">AdjointGradient</span></code> computes gradients <strong>per parameter</strong>, and <strong>not</strong> per-gate. We can also see that if <code class="docutils literal notranslate"><span class="pre">parameters</span></code> is empty, derivatives with respect to all free parameters will be computed. This is useful in cases when your circuit has a large number of free parameters.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span><span class="o">.</span><span class="n">xx</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">gamma</span><span class="p">)</span>
<span class="c1"># add the gradient result type</span>
<span class="n">circuit</span><span class="o">.</span><span class="n">adjoint_gradient</span><span class="p">(</span><span class="n">observable</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="n">Z</span><span class="p">()</span> <span class="o">@</span> <span class="n">Observable</span><span class="o">.</span><span class="n">Z</span><span class="p">(),</span> <span class="n">target</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">parameters</span><span class="o">=</span><span class="p">[])</span>
<span class="n">result_all</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circuit</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inputs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;theta&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">})</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Gradient when theta = 0.2, gamma = 0.1: </span><span class="si">{</span><span class="n">result_all</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Gradient when theta = 0.2, gamma = 0.1: {&#39;expectation&#39;: 0.9210609940028854, &#39;gradient&#39;: {&#39;gamma&#39;: -4.336808689942018e-19, &#39;theta&#39;: -0.7788366846173013}}
</pre></div>
</div>
</div>
</div>
</section>
<section id="accelerating-qaoa-with-adjointgradient">
<h2>Accelerating QAOA with <code class="docutils literal notranslate"><span class="pre">AdjointGradient</span></code><a class="headerlink" href="#accelerating-qaoa-with-adjointgradient" title="Permalink to this heading">#</a></h2>
<p>Now we can see how using the <code class="docutils literal notranslate"><span class="pre">AdjointGradient</span></code> result type can improve performance for a hybrid algorithm such as QAOA. For an introduction to QAOA, see <a class="reference internal" href="../hybrid_quantum_algorithms/QAOA/QAOA_braket.html"><span class="doc std std-doc">its example notebook</span></a>. We’ll modify the <code class="docutils literal notranslate"><span class="pre">train</span></code> function to use <code class="docutils literal notranslate"><span class="pre">AdjointGradient</span></code> and determine a Jacobian, and compare this approach with the Jacobian-free method used in the QAOA notebook. Much of the code here is further explained in that notebook, so we strongly suggest you review it before proceeding. We’ll run the entire QAOA workflow in <code class="docutils literal notranslate"><span class="pre">shots=0</span></code> mode so that we can compare with <code class="docutils literal notranslate"><span class="pre">AdjointGradient</span></code>, which means we can directly compute the cost (energy). First, we set up the problem and import the circuit generator and training functions:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># setup Erdos Renyi graph</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># number of nodes/vertices</span>
<span class="n">m</span> <span class="o">=</span> <span class="mi">20</span>  <span class="c1"># number of edges</span>
<span class="n">seed</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c1"># define graph object</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">gnm_random_graph</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
<span class="c1"># positions for all nodes</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

<span class="c1"># choose random weights</span>
<span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
    <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># draw graph</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># set Ising matrix </span>
<span class="n">Jfull</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">adjacency_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>
<span class="n">Jfull</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Jfull</span><span class="p">)</span>

<span class="c1"># get off-diagonal upper triangular matrix</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">Jfull</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/86390ffc3836eb34d5f7cd8167f8c60cc1e4dc72a4f77ab5ec1401a844fb3d86.png" src="../../_images/86390ffc3836eb34d5f7cd8167f8c60cc1e4dc72a4f77ab5ec1401a844fb3d86.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">utils_qaoa</span> <span class="kn">import</span> <span class="n">circuit</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">train_adjoint</span>
<span class="c1"># auto reload external files, so that we can edit the external .py file and immediately see the changes here</span>
<span class="o">%</span><span class="k">load_ext</span> autoreload
<span class="o">%</span><span class="k">autoreload</span> 2
</pre></div>
</div>
</div>
</div>
<p>Now we define hyperparameters. We’ll use an optimization method that can benefit from information about the Jacobian, in this case <code class="docutils literal notranslate"><span class="pre">'BFGS'</span></code>, when running with the <code class="docutils literal notranslate"><span class="pre">AdjointGradient</span></code> result type. Without it, we’ll use <code class="docutils literal notranslate"><span class="pre">'Powell'</span></code>, as we did in the other QAOA notebook, which uses the finite differences method to compute gradients and adjust the parameters. See the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html#scipy.optimize.minimize">scipy documentation</a> for more information about possible optimization methods.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">##################################################################################</span>
<span class="c1"># set up hyperparameters</span>
<span class="c1">##################################################################################</span>

<span class="c1"># User-defined hypers</span>
<span class="n">DEPTH</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># circuit depth for QAOA</span>
<span class="n">OPT_METHOD</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;adjoint&#39;</span><span class="p">:</span> <span class="s1">&#39;BFGS&#39;</span><span class="p">,</span> <span class="s1">&#39;gradient-free&#39;</span><span class="p">:</span> <span class="s1">&#39;BFGS&#39;</span><span class="p">}</span>

<span class="c1"># set up the problem</span>
<span class="n">n_qubits</span> <span class="o">=</span> <span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># initialize reference solution (simple guess)</span>
<span class="n">energy_init</span> <span class="o">=</span> <span class="mf">0.0</span>

<span class="c1">##################################################################################</span>
<span class="c1"># run QAOA optimization on graph </span>
<span class="c1">##################################################################################</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Circuit depth hyperparameter:&#39;</span><span class="p">,</span> <span class="n">DEPTH</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Problem size:&#39;</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>

<span class="c1"># set options for classical optimization</span>
<span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="mi">30</span><span class="p">}</span>
<span class="n">verbose</span> <span class="o">=</span> <span class="kc">True</span>

<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">DEPTH</span>
<span class="c1"># randomly initialize variational parameters within appropriate bounds</span>
<span class="n">gamma_initial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="n">beta_initial</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
<span class="n">params0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">gamma_initial</span> <span class="o">+</span> <span class="n">beta_initial</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Circuit depth hyperparameter: 2
Problem size: 10
</pre></div>
</div>
</div>
</div>
<p>We’re now ready to run the optimization. We’ll set up separate cost trackers for each run to compare not only running time, but also billing incurred. First, using the adjoint differentiation method:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">adjoint_costs</span> <span class="o">=</span> <span class="n">Tracker</span><span class="p">()</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="c1">#set up trackers to keep track of results</span>
<span class="n">adjoint_tracker</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>                           <span class="c1"># Elapsed optimization steps</span>
    <span class="s1">&#39;optimal_energy&#39;</span><span class="p">:</span> <span class="n">energy_init</span><span class="p">,</span>        <span class="c1"># Global optimal energy</span>
    <span class="s1">&#39;opt_energies&#39;</span><span class="p">:</span> <span class="p">[],</span>                   <span class="c1"># Optimal energy at each step</span>
    <span class="s1">&#39;global_energies&#39;</span><span class="p">:</span> <span class="p">[],</span>                <span class="c1"># Global optimal energy at each step</span>
    <span class="s1">&#39;costs&#39;</span><span class="p">:</span> <span class="p">[],</span>                          <span class="c1"># Cost (energy) at each step</span>
    <span class="s1">&#39;res&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>                          <span class="c1"># Quantum result object</span>
    <span class="s1">&#39;params&#39;</span><span class="p">:</span> <span class="p">[]</span>                          <span class="c1"># Track parameters</span>
<span class="p">}</span>

<span class="c1"># kick off training for adjoint</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">result_energy</span><span class="p">,</span> <span class="n">result_angle</span><span class="p">,</span> <span class="n">adjoint_tracker</span> <span class="o">=</span> <span class="n">train_adjoint</span><span class="p">(</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">device</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">DEPTH</span><span class="p">,</span> <span class="n">ising</span><span class="o">=</span><span class="n">J</span><span class="p">,</span> <span class="n">n_qubits</span><span class="o">=</span><span class="n">n_qubits</span><span class="p">,</span>
    <span class="n">opt_method</span><span class="o">=</span><span class="n">OPT_METHOD</span><span class="p">[</span><span class="s1">&#39;adjoint&#39;</span><span class="p">],</span> <span class="n">tracker</span><span class="o">=</span><span class="n">adjoint_tracker</span><span class="p">,</span> <span class="n">params0</span><span class="o">=</span><span class="n">params0</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
<span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="c1"># print execution time</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Code execution time using adjoint differentiation [sec]:&#39;</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>

<span class="c1"># print optimized results</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Optimal energy using adjoint differentiation:&#39;</span><span class="p">,</span> <span class="n">adjoint_tracker</span><span class="p">[</span><span class="s1">&#39;optimal_energy&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Starting the training.
====================================================================
OPTIMIZATION for circuit depth p=2
Initial energy:  -0.05267587615473164
====================================================================
Calling the quantum circuit. Cycle: 2
Energy expectation value (cost): -0.05267587615473156
====================================================================
Calling the quantum circuit. Cycle: 3
Energy expectation value (cost): 0.3531762574841993
====================================================================
Calling the quantum circuit. Cycle: 4
Energy expectation value (cost): -1.9354434136131804
====================================================================
Calling the quantum circuit. Cycle: 5
Energy expectation value (cost): -0.3498090866453894
====================================================================
Calling the quantum circuit. Cycle: 6
Energy expectation value (cost): -1.79710493450284
====================================================================
Calling the quantum circuit. Cycle: 7
Energy expectation value (cost): -2.048613457094462
====================================================================
Calling the quantum circuit. Cycle: 8
Energy expectation value (cost): -2.090456572339379
====================================================================
Calling the quantum circuit. Cycle: 9
Energy expectation value (cost): -2.1335721563595507
====================================================================
Calling the quantum circuit. Cycle: 10
Energy expectation value (cost): -2.1466520627954995
====================================================================
Calling the quantum circuit. Cycle: 11
Energy expectation value (cost): -2.146589390426477
====================================================================
Calling the quantum circuit. Cycle: 12
Energy expectation value (cost): -2.1548795821625237
====================================================================
Calling the quantum circuit. Cycle: 13
Energy expectation value (cost): -2.158405687757965
====================================================================
Calling the quantum circuit. Cycle: 14
Energy expectation value (cost): -2.160231466558164
====================================================================
Calling the quantum circuit. Cycle: 15
Energy expectation value (cost): -2.170885714298184
====================================================================
Calling the quantum circuit. Cycle: 16
Energy expectation value (cost): -2.2017257216438497
====================================================================
Calling the quantum circuit. Cycle: 17
Energy expectation value (cost): -2.2204782717518112
====================================================================
Calling the quantum circuit. Cycle: 18
Energy expectation value (cost): -2.231745254745078
====================================================================
Calling the quantum circuit. Cycle: 19
Energy expectation value (cost): -2.272653720288545
====================================================================
Calling the quantum circuit. Cycle: 20
Energy expectation value (cost): -2.338598305165878
====================================================================
Calling the quantum circuit. Cycle: 21
Energy expectation value (cost): -2.406813607483334
====================================================================
Calling the quantum circuit. Cycle: 22
Energy expectation value (cost): -2.4140539585680183
====================================================================
Calling the quantum circuit. Cycle: 23
Energy expectation value (cost): -2.4226083364070496
====================================================================
Calling the quantum circuit. Cycle: 24
Energy expectation value (cost): -2.425918124006462
====================================================================
Calling the quantum circuit. Cycle: 25
Energy expectation value (cost): -2.42837089364217
====================================================================
Calling the quantum circuit. Cycle: 26
Energy expectation value (cost): -2.428440753686318
====================================================================
Calling the quantum circuit. Cycle: 27
Energy expectation value (cost): -2.4284433319360255
====================================================================
Calling the quantum circuit. Cycle: 28
Energy expectation value (cost): -2.428443347240679
====================================================================
Calling the quantum circuit. Cycle: 29
Energy expectation value (cost): -2.4284433472812954
Optimization terminated successfully.
         Current function value: -2.428443
         Iterations: 20
         Function evaluations: 28
         Gradient evaluations: 28
Final average energy (cost): -2.4284433472812954
Final angles: [2.65349514 0.60430877 1.10839027 1.38078709]
Training complete.
Code execution time using adjoint differentiation [sec]: 100.16227006912231
Optimal energy using adjoint differentiation: -2.4284433472812954
</pre></div>
</div>
</div>
</div>
<p>Let’s also examine the costs incurred by running QAOA with the <code class="docutils literal notranslate"><span class="pre">AdjointGradient</span></code> result type and a gradient-aware optimization method:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Adjoint Gradient Aware Task Summary&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">adjoint_costs</span><span class="o">.</span><span class="n">quantum_tasks_statistics</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Estimated cost to run this example: </span><span class="si">{</span><span class="n">adjoint_costs</span><span class="o">.</span><span class="n">simulator_tasks_cost</span><span class="p">()</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> USD&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Adjoint Gradient Aware Task Summary
{&#39;arn:aws:braket:::device/quantum-simulator/amazon/sv1&#39;: {&#39;shots&#39;: 0, &#39;tasks&#39;: {&#39;COMPLETED&#39;: 29}, &#39;execution_duration&#39;: datetime.timedelta(seconds=1, microseconds=860000), &#39;billed_execution_duration&#39;: datetime.timedelta(seconds=87)}}
Estimated cost to run this example: 0.109 USD
</pre></div>
</div>
</div>
</div>
<p>Finally, we’ll run without using the adjoint differentiation method to compute the gradient and compare the running time and costs:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">no_adjoint_costs</span> <span class="o">=</span> <span class="n">Tracker</span><span class="p">()</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">energy_init</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">tracker</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>                           <span class="c1"># Elapsed optimization steps</span>
    <span class="s1">&#39;optimal_energy&#39;</span><span class="p">:</span> <span class="n">energy_init</span><span class="p">,</span>        <span class="c1"># Global optimal energy</span>
    <span class="s1">&#39;opt_energies&#39;</span><span class="p">:</span> <span class="p">[],</span>                   <span class="c1"># Optimal energy at each step</span>
    <span class="s1">&#39;global_energies&#39;</span><span class="p">:</span> <span class="p">[],</span>                <span class="c1"># Global optimal energy at each step</span>
    <span class="s1">&#39;costs&#39;</span><span class="p">:</span> <span class="p">[],</span>                          <span class="c1"># Cost (energy) at each step</span>
    <span class="s1">&#39;res&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>                          <span class="c1"># Quantum result object</span>
    <span class="s1">&#39;params&#39;</span><span class="p">:</span> <span class="p">[]</span>                          <span class="c1"># Track parameters</span>
<span class="p">}</span>

<span class="c1"># kick off training for gradient-free</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">result_energy</span><span class="p">,</span> <span class="n">result_angle</span><span class="p">,</span> <span class="n">tracker</span> <span class="o">=</span> <span class="n">train</span><span class="p">(</span>
    <span class="n">device</span> <span class="o">=</span> <span class="n">device</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">DEPTH</span><span class="p">,</span> <span class="n">ising</span><span class="o">=</span><span class="n">J</span><span class="p">,</span> <span class="n">n_qubits</span><span class="o">=</span><span class="n">n_qubits</span><span class="p">,</span> 
    <span class="n">opt_method</span><span class="o">=</span><span class="n">OPT_METHOD</span><span class="p">[</span><span class="s1">&#39;gradient-free&#39;</span><span class="p">],</span> <span class="n">tracker</span><span class="o">=</span><span class="n">tracker</span><span class="p">,</span> <span class="n">params0</span><span class="o">=</span><span class="n">params0</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
<span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="c1"># print execution time</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Code execution time without adjoint differentiation [sec]:&#39;</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>

<span class="c1"># print optimized results</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Optimal energy:&#39;</span><span class="p">,</span> <span class="n">tracker</span><span class="p">[</span><span class="s1">&#39;optimal_energy&#39;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Starting the training.
====================================================================
OPTIMIZATION for circuit depth p=2
Initial energy:  -0.05267587615473153
====================================================================
Calling the quantum circuit. Cycle: 2
Energy expectation value (cost): -0.05267587615473145
====================================================================
Calling the quantum circuit. Cycle: 3
Energy expectation value (cost): -0.05267583401081515
====================================================================
Calling the quantum circuit. Cycle: 4
Energy expectation value (cost): -0.052675832946504964
====================================================================
Calling the quantum circuit. Cycle: 5
Energy expectation value (cost): -0.052675775205400364
====================================================================
Calling the quantum circuit. Cycle: 6
Energy expectation value (cost): -0.05267578407188134
====================================================================
Calling the quantum circuit. Cycle: 7
Energy expectation value (cost): 0.35317625639201633
====================================================================
Calling the quantum circuit. Cycle: 8
Energy expectation value (cost): 0.35317635436937445
====================================================================
Calling the quantum circuit. Cycle: 9
Energy expectation value (cost): 0.35317631990683873
====================================================================
Calling the quantum circuit. Cycle: 10
Energy expectation value (cost): 0.35317628774530807
====================================================================
Calling the quantum circuit. Cycle: 11
Energy expectation value (cost): 0.3531763197484072
====================================================================
Calling the quantum circuit. Cycle: 12
Energy expectation value (cost): -1.9354434155579512
====================================================================
Calling the quantum circuit. Cycle: 13
Energy expectation value (cost): -1.9354433768795676
====================================================================
Calling the quantum circuit. Cycle: 14
Energy expectation value (cost): -1.9354433767431884
====================================================================
Calling the quantum circuit. Cycle: 15
Energy expectation value (cost): -1.935443382335277
====================================================================
Calling the quantum circuit. Cycle: 16
Energy expectation value (cost): -1.9354433899609917
====================================================================
Calling the quantum circuit. Cycle: 17
Energy expectation value (cost): -0.34980910143980903
====================================================================
Calling the quantum circuit. Cycle: 18
Energy expectation value (cost): -0.3498090652567156
====================================================================
Calling the quantum circuit. Cycle: 19
Energy expectation value (cost): -0.34980906705689274
====================================================================
Calling the quantum circuit. Cycle: 20
Energy expectation value (cost): -0.3498091824665031
====================================================================
Calling the quantum circuit. Cycle: 21
Energy expectation value (cost): -0.34980906522353905
====================================================================
Calling the quantum circuit. Cycle: 22
Energy expectation value (cost): -1.797105044442033
====================================================================
Calling the quantum circuit. Cycle: 23
Energy expectation value (cost): -1.7971051019761821
====================================================================
Calling the quantum circuit. Cycle: 24
Energy expectation value (cost): -1.7971051015680377
====================================================================
Calling the quantum circuit. Cycle: 25
Energy expectation value (cost): -1.7971050144192944
====================================================================
Calling the quantum circuit. Cycle: 26
Energy expectation value (cost): -1.797105015189591
====================================================================
Calling the quantum circuit. Cycle: 27
Energy expectation value (cost): -2.0486134643105225
====================================================================
Calling the quantum circuit. Cycle: 28
Energy expectation value (cost): -2.048613463165455
====================================================================
Calling the quantum circuit. Cycle: 29
Energy expectation value (cost): -2.048613463165
====================================================================
Calling the quantum circuit. Cycle: 30
Energy expectation value (cost): -2.048613433174286
====================================================================
Calling the quantum circuit. Cycle: 31
Energy expectation value (cost): -2.048613434025501
====================================================================
Calling the quantum circuit. Cycle: 32
Energy expectation value (cost): -2.0904565914685818
====================================================================
Calling the quantum circuit. Cycle: 33
Energy expectation value (cost): -2.0904565917957267
====================================================================
Calling the quantum circuit. Cycle: 34
Energy expectation value (cost): -2.090456594815293
====================================================================
Calling the quantum circuit. Cycle: 35
Energy expectation value (cost): -2.0904566099986406
====================================================================
Calling the quantum circuit. Cycle: 36
Energy expectation value (cost): -2.0904566127559843
====================================================================
Calling the quantum circuit. Cycle: 37
Energy expectation value (cost): -2.133572157281146
====================================================================
Calling the quantum circuit. Cycle: 38
Energy expectation value (cost): -2.1335721627107724
====================================================================
Calling the quantum circuit. Cycle: 39
Energy expectation value (cost): -2.1335721621067916
====================================================================
Calling the quantum circuit. Cycle: 40
Energy expectation value (cost): -2.1335721543128763
====================================================================
Calling the quantum circuit. Cycle: 41
Energy expectation value (cost): -2.1335721553545866
====================================================================
Calling the quantum circuit. Cycle: 42
Energy expectation value (cost): -2.1466520873072668
====================================================================
Calling the quantum circuit. Cycle: 43
Energy expectation value (cost): -2.1466520963683533
====================================================================
Calling the quantum circuit. Cycle: 44
Energy expectation value (cost): -2.1466520940265736
====================================================================
Calling the quantum circuit. Cycle: 45
Energy expectation value (cost): -2.1466520819905996
====================================================================
Calling the quantum circuit. Cycle: 46
Energy expectation value (cost): -2.146652080835302
====================================================================
Calling the quantum circuit. Cycle: 47
Energy expectation value (cost): -2.146589380341281
====================================================================
Calling the quantum circuit. Cycle: 48
Energy expectation value (cost): -2.146589379851874
====================================================================
Calling the quantum circuit. Cycle: 49
Energy expectation value (cost): -2.1465893856205946
====================================================================
Calling the quantum circuit. Cycle: 50
Energy expectation value (cost): -2.1465893820672637
====================================================================
Calling the quantum circuit. Cycle: 51
Energy expectation value (cost): -2.146589378670433
====================================================================
Calling the quantum circuit. Cycle: 52
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Energy expectation value (cost): -2.1548796100967627
====================================================================
Calling the quantum circuit. Cycle: 53
Energy expectation value (cost): -2.1548796153793828
====================================================================
Calling the quantum circuit. Cycle: 54
Energy expectation value (cost): -2.1548796166539845
====================================================================
Calling the quantum circuit. Cycle: 55
Energy expectation value (cost): -2.1548796073363605
====================================================================
Calling the quantum circuit. Cycle: 56
Energy expectation value (cost): -2.1548796054619683
====================================================================
Calling the quantum circuit. Cycle: 57
Energy expectation value (cost): -2.158404763282674
====================================================================
Calling the quantum circuit. Cycle: 58
Energy expectation value (cost): -2.1584047788181904
====================================================================
Calling the quantum circuit. Cycle: 59
Energy expectation value (cost): -2.1584047719619237
====================================================================
Calling the quantum circuit. Cycle: 60
Energy expectation value (cost): -2.1584047631043077
====================================================================
Calling the quantum circuit. Cycle: 61
Energy expectation value (cost): -2.158404752934861
====================================================================
Calling the quantum circuit. Cycle: 62
Energy expectation value (cost): -2.160231194220481
====================================================================
Calling the quantum circuit. Cycle: 63
Energy expectation value (cost): -2.1602312040395066
====================================================================
Calling the quantum circuit. Cycle: 64
Energy expectation value (cost): -2.160231202042433
====================================================================
Calling the quantum circuit. Cycle: 65
Energy expectation value (cost): -2.1602311924177826
====================================================================
Calling the quantum circuit. Cycle: 66
Energy expectation value (cost): -2.1602311872981423
====================================================================
Calling the quantum circuit. Cycle: 67
Energy expectation value (cost): -2.170884827927509
====================================================================
Calling the quantum circuit. Cycle: 68
Energy expectation value (cost): -2.1708848389024
====================================================================
Calling the quantum circuit. Cycle: 69
Energy expectation value (cost): -2.170884835803945
====================================================================
Calling the quantum circuit. Cycle: 70
Energy expectation value (cost): -2.17088482564214
====================================================================
Calling the quantum circuit. Cycle: 71
Energy expectation value (cost): -2.170884819532099
====================================================================
Calling the quantum circuit. Cycle: 72
Energy expectation value (cost): -2.2017231916882922
====================================================================
Calling the quantum circuit. Cycle: 73
Energy expectation value (cost): -2.201723212932062
====================================================================
Calling the quantum circuit. Cycle: 74
Energy expectation value (cost): -2.201723198044966
====================================================================
Calling the quantum circuit. Cycle: 75
Energy expectation value (cost): -2.201723185647768
====================================================================
Calling the quantum circuit. Cycle: 76
Energy expectation value (cost): -2.2017231732806297
====================================================================
Calling the quantum circuit. Cycle: 77
Energy expectation value (cost): -2.2204622418515827
====================================================================
Calling the quantum circuit. Cycle: 78
Energy expectation value (cost): -2.220462273882845
====================================================================
Calling the quantum circuit. Cycle: 79
Energy expectation value (cost): -2.2204622350878593
====================================================================
Calling the quantum circuit. Cycle: 80
Energy expectation value (cost): -2.2204622201326245
====================================================================
Calling the quantum circuit. Cycle: 81
Energy expectation value (cost): -2.2204622246198986
====================================================================
Calling the quantum circuit. Cycle: 82
Energy expectation value (cost): -2.231736377725677
====================================================================
Calling the quantum circuit. Cycle: 83
Energy expectation value (cost): -2.2317364024077575
====================================================================
Calling the quantum circuit. Cycle: 84
Energy expectation value (cost): -2.2317363787387268
====================================================================
Calling the quantum circuit. Cycle: 85
Energy expectation value (cost): -2.231736364291387
====================================================================
Calling the quantum circuit. Cycle: 86
Energy expectation value (cost): -2.2317363587687113
====================================================================
Calling the quantum circuit. Cycle: 87
Energy expectation value (cost): -2.2726472425821527
====================================================================
Calling the quantum circuit. Cycle: 88
Energy expectation value (cost): -2.272647273945502
====================================================================
Calling the quantum circuit. Cycle: 89
Energy expectation value (cost): -2.27264724314604
====================================================================
Calling the quantum circuit. Cycle: 90
Energy expectation value (cost): -2.2726472396051567
====================================================================
Calling the quantum circuit. Cycle: 91
Energy expectation value (cost): -2.2726472148737265
====================================================================
Calling the quantum circuit. Cycle: 92
Energy expectation value (cost): -2.3385936445782365
====================================================================
Calling the quantum circuit. Cycle: 93
Energy expectation value (cost): -2.3385936660991997
====================================================================
Calling the quantum circuit. Cycle: 94
Energy expectation value (cost): -2.338593642992647
====================================================================
Calling the quantum circuit. Cycle: 95
Energy expectation value (cost): -2.338593644550744
====================================================================
Calling the quantum circuit. Cycle: 96
Energy expectation value (cost): -2.338593619749116
====================================================================
Calling the quantum circuit. Cycle: 97
Energy expectation value (cost): -2.406820073747788
====================================================================
Calling the quantum circuit. Cycle: 98
Energy expectation value (cost): -2.4068200747963573
====================================================================
Calling the quantum circuit. Cycle: 99
Energy expectation value (cost): -2.406820071488685
====================================================================
Calling the quantum circuit. Cycle: 100
Energy expectation value (cost): -2.4068200596241356
====================================================================
Calling the quantum circuit. Cycle: 101
Energy expectation value (cost): -2.406820068389814
====================================================================
Calling the quantum circuit. Cycle: 102
Energy expectation value (cost): -2.41406981099362
====================================================================
Calling the quantum circuit. Cycle: 103
Energy expectation value (cost): -2.4140698069381004
====================================================================
Calling the quantum circuit. Cycle: 104
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Energy expectation value (cost): -2.4140698046521014
====================================================================
Calling the quantum circuit. Cycle: 105
Energy expectation value (cost): -2.4140698082790046
====================================================================
Calling the quantum circuit. Cycle: 106
Energy expectation value (cost): -2.414069804579258
====================================================================
Calling the quantum circuit. Cycle: 107
Energy expectation value (cost): -2.422620526817567
====================================================================
Calling the quantum circuit. Cycle: 108
Energy expectation value (cost): -2.422620521827577
====================================================================
Calling the quantum circuit. Cycle: 109
Energy expectation value (cost): -2.4226205261068987
====================================================================
Calling the quantum circuit. Cycle: 110
Energy expectation value (cost): -2.4226205248456
====================================================================
Calling the quantum circuit. Cycle: 111
Energy expectation value (cost): -2.4226205215500163
====================================================================
Calling the quantum circuit. Cycle: 112
Energy expectation value (cost): -2.4259152579388106
====================================================================
Calling the quantum circuit. Cycle: 113
Energy expectation value (cost): -2.425915261165225
====================================================================
Calling the quantum circuit. Cycle: 114
Energy expectation value (cost): -2.425915257684496
====================================================================
Calling the quantum circuit. Cycle: 115
Energy expectation value (cost): -2.4259152537174233
====================================================================
Calling the quantum circuit. Cycle: 116
Energy expectation value (cost): -2.425915260265329
====================================================================
Calling the quantum circuit. Cycle: 117
Energy expectation value (cost): -2.428371640379875
====================================================================
Calling the quantum circuit. Cycle: 118
Energy expectation value (cost): -2.4283716402941264
====================================================================
Calling the quantum circuit. Cycle: 119
Energy expectation value (cost): -2.428371640769982
====================================================================
Calling the quantum circuit. Cycle: 120
Energy expectation value (cost): -2.4283716398172084
====================================================================
Calling the quantum circuit. Cycle: 121
Energy expectation value (cost): -2.4283716403928652
====================================================================
Calling the quantum circuit. Cycle: 122
Energy expectation value (cost): -2.4284408105996813
====================================================================
Calling the quantum circuit. Cycle: 123
Energy expectation value (cost): -2.428440810542444
====================================================================
Calling the quantum circuit. Cycle: 124
Energy expectation value (cost): -2.4284408105924773
====================================================================
Calling the quantum circuit. Cycle: 125
Energy expectation value (cost): -2.4284408105075745
====================================================================
Calling the quantum circuit. Cycle: 126
Energy expectation value (cost): -2.428440810494738
====================================================================
Calling the quantum circuit. Cycle: 127
Energy expectation value (cost): -2.428443332137185
====================================================================
Calling the quantum circuit. Cycle: 128
Energy expectation value (cost): -2.428443332133395
====================================================================
Calling the quantum circuit. Cycle: 129
Energy expectation value (cost): -2.4284433321437477
====================================================================
Calling the quantum circuit. Cycle: 130
Energy expectation value (cost): -2.4284433321496195
====================================================================
Calling the quantum circuit. Cycle: 131
Energy expectation value (cost): -2.428443332137407
====================================================================
Calling the quantum circuit. Cycle: 132
Energy expectation value (cost): -2.4284433472406057
====================================================================
Calling the quantum circuit. Cycle: 133
Energy expectation value (cost): -2.428443347241153
====================================================================
Calling the quantum circuit. Cycle: 134
Energy expectation value (cost): -2.428443347240252
====================================================================
Calling the quantum circuit. Cycle: 135
Energy expectation value (cost): -2.4284433472406293
====================================================================
Calling the quantum circuit. Cycle: 136
Energy expectation value (cost): -2.4284433472403757
====================================================================
Calling the quantum circuit. Cycle: 137
Energy expectation value (cost): -2.428443347281297
====================================================================
Calling the quantum circuit. Cycle: 138
Energy expectation value (cost): -2.428443347281339
====================================================================
Calling the quantum circuit. Cycle: 139
Energy expectation value (cost): -2.428443347281304
====================================================================
Calling the quantum circuit. Cycle: 140
Energy expectation value (cost): -2.4284433472813154
====================================================================
Calling the quantum circuit. Cycle: 141
Energy expectation value (cost): -2.4284433472812643
Optimization terminated successfully.
         Current function value: -2.428443
         Iterations: 20
         Function evaluations: 140
         Gradient evaluations: 28
Final average energy (cost): -2.428443347281297
Final angles: [2.65349514 0.60430877 1.10839025 1.38078708]
Training complete.
Code execution time without adjoint differentiation [sec]: 491.3400547504425
Optimal energy: -2.428443347281339
</pre></div>
</div>
</div>
</div>
<p>We can examine the costs incurred by running QAOA without the <code class="docutils literal notranslate"><span class="pre">AdjointGradient</span></code> result type, using a finite-differences based optimization method:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Gradient-Unaware Task Summary&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">no_adjoint_costs</span><span class="o">.</span><span class="n">quantum_tasks_statistics</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Estimated cost to run this example: </span><span class="si">{</span><span class="n">no_adjoint_costs</span><span class="o">.</span><span class="n">simulator_tasks_cost</span><span class="p">()</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> USD&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Gradient-Unaware Task Summary
{&#39;arn:aws:braket:::device/quantum-simulator/amazon/sv1&#39;: {&#39;shots&#39;: 0, &#39;tasks&#39;: {&#39;COMPLETED&#39;: 141}, &#39;execution_duration&#39;: datetime.timedelta(seconds=6, microseconds=22000), &#39;billed_execution_duration&#39;: datetime.timedelta(seconds=423)}}
Estimated cost to run this example: 0.529 USD
</pre></div>
</div>
</div>
</div>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this heading">#</a></h2>
<p>[1] Mitarai K., Negoro M., et al., “Quantum Circuit Learning”, Physical Review A 98: 032309 (2018)</p>
<p>[2] Schuld M., Bergholm V., et al., “Evaluating analytic gradients on quantum hardware”, Physical Review A 99: 032331 (2019)</p>
<p>[3] Weirechs D., Izaac J, et al., “General parameter-shift rules for quantum gradients”, Quantum 6: 677 (2022)</p>
<p>[4] Banchi L., Crooks G., “Measuring Analytic Gradients of General Quantum Evolution with the Stochastic Parameter Shift Rule”, Quantum 5: 386 (2021)</p>
<p>[5] Jones T., Gacon J., “Efficient calculation of gradients in classical simulations of variational quantum algorithms”, arXiv:2009.02823</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Task Summary&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">quantum_tasks_statistics</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Note: Charges shown are estimates based on your Amazon Braket simulator and quantum processing unit (QPU) task usage. Estimated charges shown may differ from your actual charges. Estimated charges do not factor in any discounts or credits, and you may experience additional charges based on your use of other services such as Amazon Elastic Compute Cloud (Amazon EC2).&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Estimated cost to run this example: </span><span class="si">{</span><span class="n">t</span><span class="o">.</span><span class="n">qpu_tasks_cost</span><span class="p">()</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">simulator_tasks_cost</span><span class="p">()</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> USD&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Task Summary
{&#39;arn:aws:braket:::device/quantum-simulator/amazon/sv1&#39;: {&#39;shots&#39;: 0, &#39;tasks&#39;: {&#39;COMPLETED&#39;: 173}, &#39;execution_duration&#39;: datetime.timedelta(seconds=7, microseconds=958000), &#39;billed_execution_duration&#39;: datetime.timedelta(seconds=519)}}
Note: Charges shown are estimates based on your Amazon Braket simulator and quantum processing unit (QPU) task usage. Estimated charges shown may differ from your actual charges. Estimated charges do not factor in any discounts or credits, and you may experience additional charges based on your use of other services such as Amazon Elastic Compute Cloud (Amazon EC2).
Estimated cost to run this example: 0.649 USD
</pre></div>
</div>
</div>
</div>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Using the Adjoint Gradient Result Type on Amazon Braket</a><ul>
<li><a class="reference internal" href="#table-of-contents">Table of Contents</a></li>
<li><a class="reference internal" href="#background-what-is-a-gradient">Background: What is a gradient?</a></li>
<li><a class="reference internal" href="#why-compute-gradients">Why compute gradients?</a></li>
<li><a class="reference internal" href="#computing-gradients-of-parameters-in-a-quantum-circuit">Computing gradients of parameters in a quantum circuit</a><ul>
<li><a class="reference internal" href="#finite-differences">Finite differences</a></li>
<li><a class="reference internal" href="#parameter-shift-rules">Parameter shift rules</a></li>
<li><a class="reference internal" href="#adjoint-differentiation">Adjoint differentiation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-adjointgradient-result-type">The <code class="docutils literal notranslate"><span class="pre">AdjointGradient</span></code> Result Type</a></li>
<li><a class="reference internal" href="#accelerating-qaoa-with-adjointgradient">Accelerating QAOA with <code class="docutils literal notranslate"><span class="pre">AdjointGradient</span></code></a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/scripts/furo.js"></script>
    </body>
</html>