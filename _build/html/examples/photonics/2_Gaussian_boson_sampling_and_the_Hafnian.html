<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../../genindex.html" /><link rel="search" title="Search" href="../../search.html" />

    <!-- Generated with Sphinx 5.3.0 and Furo 2022.12.07 -->
        <title>Gaussian boson sampling and the Hafnian - Amazon Braket Examples documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo.css?digest=91d0f0d1c444bdcb17a68e833c7a53903343c195" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../index.html"><div class="brand">Amazon Braket Examples  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../index.html">
  
  
  <span class="sidebar-brand-text">Amazon Braket Examples  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Examples</span></p>
<ul>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../getting_started_index.html">Getting started</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/0_Getting_started/0_Getting_started.html">Getting started with Amazon Braket</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/1_Running_quantum_circuits_on_simulators/1_Running_quantum_circuits_on_simulators.html">Preparing a GHZ state and running the circuit on simulators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/2_Running_quantum_circuits_on_QPU_devices/2_Running_quantum_circuits_on_QPU_devices.html">Running quantum circuits on QPU devices</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/2_Running_quantum_circuits_on_QPU_devices/2_Running_quantum_circuits_on_QPU_devices.html#appendix">APPENDIX</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/3_Deep_dive_into_the_anatomy_of_quantum_circuits/3_Deep_dive_into_the_anatomy_of_quantum_circuits.html">Anatomy of Quantum Circuits and Quantum Tasks in Amazon Braket</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/4_Superdense_coding/4_Superdense_coding.html">Superdense Coding</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../braket_features_index.html">Braket Features</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../braket_features/Getting_Devices_and_Checking_Device_Properties.html">Getting Devices and Checking Device Properties</a></li>
<li class="toctree-l2"><a class="reference internal" href="../braket_features/Getting_Started_with_OpenQASM_on_Braket.html">Getting Started with OpenQASM on Braket</a></li>
<li class="toctree-l2"><a class="reference internal" href="../braket_features/Getting_Started_with_OpenQASM_on_Braket.html#openqasm-features-on-braket">OpenQASM features on Braket</a></li>
<li class="toctree-l2"><a class="reference internal" href="../braket_features/Getting_Started_with_OpenQASM_on_Braket.html#conclusion">Conclusion</a></li>
<li class="toctree-l2"><a class="reference internal" href="../braket_features/Simulating_Advanced_OpenQASM_Programs_with_the_Local_Simulator.html">Simulating Advanced OpenQASM Programs with the Local Simulator</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># This cell is added by sphinx-gallery</span>
<span class="c1"># It can be customized to whatever you like</span>
<span class="o">%</span><span class="k">matplotlib</span> inline
</pre></div>
</div>
</div>
</div>
<section id="gaussian-boson-sampling-and-the-hafnian">
<h1>Gaussian boson sampling and the Hafnian<a class="headerlink" href="#gaussian-boson-sampling-and-the-hafnian" title="Permalink to this heading">#</a></h1>
<blockquote>
<div><p>“The extended Church-Turing thesis states that <em>‘Any algorithmic process can be simulated efficiently using a probabilistic Turing machine’.</em> This ad-hoc modification of the Church-Turing thesis should leave you feeling rather queasy.” — Nielsen and Chuang [1].</p>
</div></blockquote>
<p>In this tutorial, we will walk through the application of Gaussian boson sampling.$\newcommand{\ket}[1]{\left|{#1}\right\rangle}$$\newcommand{\bra}[1]{\left\langle{#1}\right|}$</p>
<section id="background-theory">
<h2>Background theory<a class="headerlink" href="#background-theory" title="Permalink to this heading">#</a></h2>
<p>Introduced by Hamilton et al. [2], and inspired by an earlier approach of Aaronson and Arkhipov [3], Gaussian boson sampling (GBS) presented a slight deviation from the general approach in quantum computation. Rather than presenting a theoretical model of universal quantum computation (i.e., a framework that enables quantum simulation of any arbitrary Hamiltonian [1]), Gaussian boson sampling-based devices are instead an example of an <strong>intermediate quantum computer</strong>, designed to experimentally implement a computation that is thought to be intractable classically.</p>
<p>Gaussian boson sampling proposes the following <a class="reference external" href="https://en.wikipedia.org/wiki/Linear_optical_quantum_computing">quantum linear optics</a> scheme:</p>
<ul class="simple">
<li><p>$N$ single mode squeezed states $\newcommand{\ket}[1]{\left|{#1}\right\rangle}$$\newcommand{\bra}[1]{\left\langle{#1}\right|}$$\ket{z}$, with squeezing parameter
$z=re^{i\phi}$, enter an $N$ mode linear interferometer described by unitary $U$
simultaneously.</p></li>
<li><p>Each output mode of the <a class="reference external" href="https://en.wikipedia.org/wiki/Interferometry">interferometer</a> (denoted by state $\ket{\psi’}$) is then measured in the Fock basis, $\bigotimes_i n_i\ket{n_i}\bra{n_i}$.</p></li>
</ul>
<p>Without loss of generality, we can absorb the squeezing phase parameter $\phi$ into the
interferometer, and set $\phi=0$ for convenience.</p>
<p>Using phase space methods, Hamilton et al. [2] showed that the probability of
measuring a Fock state containing only 0 or 1 photons per mode is given by</p>
<p>$$
\left|\left\langle{n_1,n_2,\dots,n_N}\middle|{\psi’}\right\rangle\right|^2 =
\frac{\left|\text{Haf}[(U(\bigoplus_i\tanh(r_i))U^T)]<em>{st}\right|^2}{\prod</em>{i=1}^N \cosh(r_i)}
$$</p>
<p>i.e., the sampled single photon probability distribution is proportional to the <strong>hafnian</strong> of a
submatrix of $U(\bigoplus_i\tanh(r_i))U^T$, dependent upon the output covariance matrix.</p>
<section id="note">
<h3><strong>Note:</strong><a class="headerlink" href="#note" title="Permalink to this heading">#</a></h3>
<p>The hafnian of a matrix is defined by</p>
<p>$$
\text{Haf}(A) = \frac{1}{n!2^n}\sum_{\sigma \in S_{2N}}\prod_{i=1}^N A_{\sigma(2i-1)\sigma(2i)}
$$</p>
<p>where $S_{2N}$ is the set of all permutations of $2N$ elements. In graph theory, the
hafnian calculates the number of perfect <a class="reference external" href="https://en.wikipedia.org/wiki/Matching_(graph_theory)">matchings</a> in an <strong>arbitrary graph</strong> with adjacency matrix $A$.</p>
<p>Computing the hafnian, even approximately, belongs to the computational complexity class of #P-Hard problems [4], which are strongly believed to be classically hard to calculate. [2] gives strong theoretical arguments that the hafnians arising from the GBS probability distributions are also #P-hard to approximate. This implies that simulating Gaussian boson sampling cannot be done efficiently on a classical computer, providing a potential challenge to the extended Church-Turing thesis, and demonstrating the power of (non-universal) quantum computation.</p>
</section>
</section>
<section id="circuit-construction-and-simulation">
<h2>Circuit construction and simulation<a class="headerlink" href="#circuit-construction-and-simulation" title="Permalink to this heading">#</a></h2>
<p>In quantum linear optics, the multimode linear interferometer is commonly decomposed into two-mode
beamsplitters (<a class="reference external" href="https://strawberryfields.readthedocs.io/en/stable/code/api/strawberryfields.ops.BSgate.html"><code class="docutils literal notranslate"><span class="pre">BSgate</span></code></a>) and single-mode phase shifters (<a class="reference external" href="https://strawberryfields.readthedocs.io/en/stable/code/api/strawberryfields.ops.Rgate.html"><code class="docutils literal notranslate"><span class="pre">Rgate</span></code></a>)
[5], allowing for a straightforward translation into a CV quantum circuit.</p>
<p>For example, in the case of a 4 mode interferometer, with arbitrary $4\times 4$ unitary
$U$, the CV quantum circuit for Gaussian boson sampling is given by</p>
<p><img alt="gaussian_boson_sampling.png" src="examples/photonics/attachment:gaussian_boson_sampling.png" /></p>
<p>In the above, the single mode squeeze states all apply identical squeezing $z=r$, the
parameters of the beamsplitters and the rotation gates determine the unitary $U$, and finally
the detectors perform Fock state measurements on the output modes. Note that, in order to allow for arbitrary
linear unitaries for $m$ imput modes, we must have a minimum of $m+1$ columns in the
beamsplitter array [6].</p>
<p>Simulating this circuit using Strawberry Fields is easy; we can simply read off the gates from left
to right, and convert it into the Blackbird circuit language.</p>
<p>To begin, we create the Gaussian boson sampling quantum program using Strawberry Fields:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># set the random seed</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># import Strawberry Fields</span>
<span class="kn">import</span> <span class="nn">strawberryfields</span> <span class="k">as</span> <span class="nn">sf</span>
<span class="kn">from</span> <span class="nn">strawberryfields.ops</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c1"># initialize a 4 mode program</span>
<span class="n">gbs</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Program</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="k">with</span> <span class="n">gbs</span><span class="o">.</span><span class="n">context</span> <span class="k">as</span> <span class="n">q</span><span class="p">:</span>
    <span class="c1"># prepare the input squeezed states</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">Sgate</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">S</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">S</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="c1"># rotation gates</span>
    <span class="n">Rgate</span><span class="p">(</span><span class="mf">0.5719</span><span class="p">)</span>  <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Rgate</span><span class="p">(</span><span class="o">-</span><span class="mf">1.9782</span><span class="p">)</span> <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Rgate</span><span class="p">(</span><span class="mf">2.0603</span><span class="p">)</span>  <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">Rgate</span><span class="p">(</span><span class="mf">0.0644</span><span class="p">)</span>  <span class="o">|</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="c1"># beamsplitter array</span>
    <span class="n">BSgate</span><span class="p">(</span><span class="mf">0.7804</span><span class="p">,</span> <span class="mf">0.8578</span><span class="p">)</span>  <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">BSgate</span><span class="p">(</span><span class="mf">0.06406</span><span class="p">,</span> <span class="mf">0.5165</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">BSgate</span><span class="p">(</span><span class="mf">0.473</span><span class="p">,</span> <span class="mf">0.1176</span><span class="p">)</span>   <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">BSgate</span><span class="p">(</span><span class="mf">0.563</span><span class="p">,</span> <span class="mf">0.1517</span><span class="p">)</span>   <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">BSgate</span><span class="p">(</span><span class="mf">0.1323</span><span class="p">,</span> <span class="mf">0.9946</span><span class="p">)</span>  <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">BSgate</span><span class="p">(</span><span class="mf">0.311</span><span class="p">,</span> <span class="mf">0.3231</span><span class="p">)</span>   <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">BSgate</span><span class="p">(</span><span class="mf">0.4348</span><span class="p">,</span> <span class="mf">0.0798</span><span class="p">)</span>  <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">BSgate</span><span class="p">(</span><span class="mf">0.4368</span><span class="p">,</span> <span class="mf">0.6157</span><span class="p">)</span>  <span class="o">|</span> <span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>A couple of things to note in this particular example:</p>
<ol class="arabic">
<li><p>To prepare the input single mode squeezed vacuum state $\ket{z}$ where $z = 1$, we
apply a squeezing gate <a class="reference external" href="https://strawberryfields.readthedocs.io/en/stable/code/api/strawberryfields.ops.Sgate.html"><code class="docutils literal notranslate"><span class="pre">Sgate</span></code></a> to each of the modes (initially in the vacuum state).</p></li>
<li><p>Next we apply the rotation gates, <a class="reference external" href="https://strawberryfields.readthedocs.io/en/stable/code/api/strawberryfields.ops.Rgate.html"><code class="docutils literal notranslate"><span class="pre">Rgate</span></code></a>, to each mode. The resulting rotation in the phase space occurs in the anticlockwise direction, with angle $\phi$.</p></li>
<li><p>Finally, we apply the array of beamsplitters, using the <a class="reference external" href="https://strawberryfields.readthedocs.io/en/stable/code/api/strawberryfields.ops.BSgate.html"><code class="docutils literal notranslate"><span class="pre">BSgate</span></code></a> operator, with arguments <code class="docutils literal notranslate"><span class="pre">(theta,phi)</span></code>.</p>
<ul class="simple">
<li><p>The transmission amplitude is then given by $t=\cos\theta$</p></li>
<li><p>The reflection amplitude is given by $r=e^{i\phi}\sin{\theta}$</p></li>
</ul>
</li>
<li><p>The rotation gate and beamsplitter parameters have been chosen at random, leading to an
arbitrary unitary $U$ acting on the input modes annihilation and creation operators.
After leaving the beamsplitter array, we will denote the output state by $\ket{\psi’}$.</p></li>
<li><p>We are <strong>not</strong> performing Fock measurements at the output; this is to ensure the state is
preserved, so we can extract the joint Fock state probabilities after the beamsplitter array.</p>
<p>If we wish to simulate Fock measurements, we can additionally include</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">MeasureFock</span><span class="p">()</span> <span class="o">|</span> <span class="n">q</span>
</pre></div>
</div>
<p>after the beamsplitter array. After constructing the circuit and running the engine, the values of
the Fock state measurements will be available within the <code class="docutils literal notranslate"><span class="pre">samples</span></code> attribute of the
<a class="reference external" href="https://strawberryfields.readthedocs.io/en/stable/code/api/strawberryfields.Result.html"><code class="docutils literal notranslate"><span class="pre">Result</span></code></a> object returned by the engine.</p>
</li>
</ol>
<p>Now that the program is created, we can initialize an engine, and execute the program
on one of the built-in Strawberry Fields state simulators.  We will use the Numpy-based <code class="docutils literal notranslate"><span class="pre">'gaussian'</span></code> backend, along with a 4-mode register. The Gaussian backend is perfectly suited for simulation of Gaussian boson sampling, as all initial states are Gaussian, and all the required operators transform Gaussian states to other Gaussian states.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eng</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Engine</span><span class="p">(</span><span class="n">backend</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">eng</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">gbs</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The state method <a class="reference external" href="https://strawberryfields.readthedocs.io/en/stable/code/api/strawberryfields.backends.BaseState.html#strawberryfields.backends.BaseState.fock_prob"><code class="docutils literal notranslate"><span class="pre">fock_prob()</span></code></a> accepts a list or a tuple containing the Fock state to be measured and returns the probability of that measurement. For example, <code class="docutils literal notranslate"><span class="pre">[1,2,0,1]</span></code> represents the measurement resulting in the detection of 1 photon at mode <code class="docutils literal notranslate"><span class="pre">q[0]</span></code> and mode <code class="docutils literal notranslate"><span class="pre">q[3]</span></code>, and 2 photons at mode <code class="docutils literal notranslate"><span class="pre">q[1]</span></code>, and would return the value</p>
<p>$$
\text{prob}(1,2,0,1) = \left|\langle 1,2,0,1 \vert \psi’\rangle\right|^2
$$</p>
<p>The Fock state method <a class="reference external" href="https://strawberryfields.readthedocs.io/en/stable/code/api/strawberryfields.backends.BaseFockState.html#strawberryfields.backends.BaseFockState.all_fock_probs"><code class="docutils literal notranslate"><span class="pre">all_fok_probs()</span></code></a>, used
previously to return <em>all</em> Fock state probabilities as an array, is <strong>not supported</strong> by the
Gaussian backend. This is because computing the Fock probabilities of states in the Gaussian
representation has exponential scaling - while this is fine for computing particular Fock basis
probabilities, it becomes computationally demanding to return <em>all</em> Fock state probabilities using
the Gaussian backend.</p>
<p>Let’s use <a class="reference external" href="https://strawberryfields.readthedocs.io/en/stable/code/api/strawberryfields.backends.BaseState.html#strawberryfields.backends.BaseState.fock_prob"><code class="docutils literal notranslate"><span class="pre">fock_prob()</span></code></a> in a for-loop to extract the probabilities of measuring various Fock states:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Fock states to measure at output</span>
<span class="n">measure_states</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]]</span>

<span class="c1"># extract the probabilities of calculating several</span>
<span class="c1"># different Fock states at the output, and print them to the terminal</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">measure_states</span><span class="p">:</span>
    <span class="n">prob</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">fock_prob</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;|</span><span class="si">{}</span><span class="s2">&gt;: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">i</span><span class="p">),</span> <span class="n">prob</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>|0000&gt;: 0.17637844761413482
|1100&gt;: 0.06855956371222356
|0101&gt;: 0.0020560972589773983
|1111&gt;: 0.0083429463998675
|2000&gt;: 0.010312945253454915
</pre></div>
</div>
</div>
</div>
</section>
<section id="calculating-the-unitary">
<h2>Calculating the unitary<a class="headerlink" href="#calculating-the-unitary" title="Permalink to this heading">#</a></h2>
<p>Let’s explore these results further. To do so, however, we’ll need to compute
the unitary that is being applied by our beamsplitters and rotation gates.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">multi_dot</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">block_diag</span>
</pre></div>
</div>
</div>
</div>
<p>To start with, let’s generate the matrix representing the unitary transformation of the input mode
annihilation and creation operators. The rotation gates simply act as follows,</p>
<p>$$
R(\phi)\hat{a} = \hat{a}e^{i\phi},
$$</p>
<p>and thus the column of rotation gates has the following block diagonal form:</p>
<p>$$
U_\phi = \left[\begin{matrix}
e^{i\phi_1} &amp; 0 &amp; \cdots\
0 &amp; e^{i\phi_2}  &amp; \cdots \
\vdots &amp; \vdots &amp; \ddots \
\end{matrix}\right]
$$</p>
<p>Generating this in NumPy:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Uphase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">0.5719</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">1.9782</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">2.0603</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mf">0.0644</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">)])</span>
</pre></div>
</div>
</div>
</div>
<p>A single beamsplitter, acting on two input modes $(\hat{a}_1,\hat{a}_2)$, instead acts as
follows:</p>
<p>$$
BS(\theta, \phi) (\hat{a}_1,\hat{a}_2) = \left[\begin{matrix}
t &amp; -r^*\
r &amp; t\
\end{matrix}\right] \left[\begin{matrix}
\hat{a}_1\
\hat{a}_2
\end{matrix}\right]
$$</p>
<p>where $t=\cos(\theta)$ and $r=e^{i\phi}\sin(\theta)$. Again, like the rotation gate,
they combine as block diagonal matrices.</p>
<p>First of all, we need to convert the <code class="docutils literal notranslate"><span class="pre">BSgate</span></code> arguments, <code class="docutils literal notranslate"><span class="pre">theta</span></code> and <code class="docutils literal notranslate"><span class="pre">phi</span></code> (reproduced below
for convenience),</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">BSargs</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="mf">0.7804</span><span class="p">,</span> <span class="mf">0.8578</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.06406</span><span class="p">,</span> <span class="mf">0.5165</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.473</span><span class="p">,</span> <span class="mf">0.1176</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.563</span><span class="p">,</span> <span class="mf">0.1517</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.1323</span><span class="p">,</span> <span class="mf">0.9946</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.311</span><span class="p">,</span> <span class="mf">0.3231</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.4348</span><span class="p">,</span> <span class="mf">0.0798</span><span class="p">),</span>
    <span class="p">(</span><span class="mf">0.4368</span><span class="p">,</span> <span class="mf">0.6157</span><span class="p">)</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>into transmission and reflection amplitudes $t$ and $r$:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">t_r_amplitudes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">q</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="k">for</span> <span class="n">q</span><span class="p">,</span><span class="n">p</span> <span class="ow">in</span> <span class="n">BSargs</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we generate the individual beamsplitter unitary transformations,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">BSunitaries</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">t</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">r</span><span class="p">)],</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">]])</span> <span class="k">for</span> <span class="n">t</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">t_r_amplitudes</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>before using the SciPy function <code class="docutils literal notranslate"><span class="pre">scipy.linalg.block_diag</span></code> to calculate the resulting
$U_{BS_i}$, i.e., the unitary corresponding to each column of ‘independent’ beamsplitters in
the above circuit diagram:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">UBS1</span> <span class="o">=</span> <span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">BSunitaries</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
<span class="n">UBS2</span> <span class="o">=</span> <span class="n">block_diag</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">BSunitaries</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">UBS3</span> <span class="o">=</span> <span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">BSunitaries</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>
<span class="n">UBS4</span> <span class="o">=</span> <span class="n">block_diag</span><span class="p">([[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">BSunitaries</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">UBS5</span> <span class="o">=</span> <span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">BSunitaries</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">8</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>Finally, we combine the unitaries to form a single $4\times 4$ unitary via matrix
multiplication; $U = U_{BS_5}U_{BS_4}U_{BS_3}U_{BS_2}U_{BS_1}U_{\phi}$. Since
<code class="docutils literal notranslate"><span class="pre">numpy.dot</span></code> only supports matrix multiplication of two arrays, we instead use
<code class="docutils literal notranslate"><span class="pre">numpy.linalg.multi_dot</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">U</span> <span class="o">=</span> <span class="n">multi_dot</span><span class="p">([</span><span class="n">UBS5</span><span class="p">,</span> <span class="n">UBS4</span><span class="p">,</span> <span class="n">UBS3</span><span class="p">,</span> <span class="n">UBS2</span><span class="p">,</span> <span class="n">UBS1</span><span class="p">,</span> <span class="n">Uphase</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 0.2195-0.2565j  0.6111+0.5242j -0.1027+0.4745j -0.0273+0.0373j]
 [ 0.4513+0.6026j  0.457 +0.0123j  0.1316-0.4504j  0.0353-0.0532j]
 [ 0.0387+0.4927j -0.0192-0.3218j -0.2408+0.5244j -0.4584+0.3296j]
 [-0.1566+0.2246j  0.11  -0.1638j -0.4212+0.1836j  0.8188+0.068j ]]
</pre></div>
</div>
</div>
</div>
<p>We find that</p>
<p>\begin{align}U = \left[\begin{matrix}
0.2195-0.2565i &amp; 0.6111+0.5242i &amp; -0.1027+0.4745i &amp; -0.0273+0.0373i\
0.4513+0.6026i &amp; 0.4570+0.0123i &amp; 0.1316-0.4504i &amp; 0.0353-0.0532i\
0.0387+0.4927i &amp; -0.0192-0.3218i &amp; -0.2408+0.5244i &amp; -0.4584+0.3296i\
-0.1566+0.2246i &amp; 0.1100-0.1638i &amp; -0.4212+0.1836i &amp; 0.8188+0.068i
\end{matrix}\right]\end{align}</p>
</section>
<section id="the-gaussian-compiler">
<h2>The Gaussian compiler<a class="headerlink" href="#the-gaussian-compiler" title="Permalink to this heading">#</a></h2>
<p>While we have done it by hand, Strawberry Fields also supports a Gaussian unitary
compiler, that allows us to compile our program into a single Gaussian unitary.</p>
<p>Note that we create a new program that excludes the initial squeezing operations, because we want to extract the unitary corresponding to the interferometers.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">prog_unitary</span> <span class="o">=</span> <span class="n">sf</span><span class="o">.</span><span class="n">Program</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">prog_unitary</span><span class="o">.</span><span class="n">circuit</span> <span class="o">=</span> <span class="n">gbs</span><span class="o">.</span><span class="n">circuit</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>
<span class="n">prog_compiled</span> <span class="o">=</span> <span class="n">prog_unitary</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">compiler</span><span class="o">=</span><span class="s2">&quot;gaussian_unitary&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Printing <code class="docutils literal notranslate"><span class="pre">prog_compiled</span></code>, we see it now consists of a single <a class="reference external" href="https://strawberryfields.readthedocs.io/en/stable/code/api/strawberryfields.ops.GaussianTransform.html"><code class="docutils literal notranslate"><span class="pre">GaussianTransform</span></code></a> operation, consisting of a single symplectic matrix:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">prog_compiled</span><span class="o">.</span><span class="n">print</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>GaussianTransform([[ 0.2195  0.6111 -0.1027 -0.0273  0.2565 -0.5242 -0.4745 -0.0373]
 [ 0.4513  0.457   0.1316  0.0353 -0.6026 -0.0123  0.4504  0.0532]
 [ 0.0387 -0.0192 -0.2408 -0.4584 -0.4927  0.3218 -0.5244 -0.3296]
 [-0.1566  0.11   -0.4212  0.8188 -0.2246  0.1638 -0.1836 -0.068 ]
 [-0.2565  0.5242  0.4745  0.0373  0.2195  0.6111 -0.1027 -0.0273]
 [ 0.6026  0.0123 -0.4504 -0.0532  0.4513  0.457   0.1316  0.0353]
 [ 0.4927 -0.3218  0.5244  0.3296  0.0387 -0.0192 -0.2408 -0.4584]
 [ 0.2246 -0.1638  0.1836  0.068  -0.1566  0.11   -0.4212  0.8188]]) | (q[0], q[1], q[2], q[3])
</pre></div>
</div>
</div>
</div>
<p>We can easily extract this symplectic matrix, and rewrite it as a unitary
matrix:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">S</span> <span class="o">=</span> <span class="n">prog_compiled</span><span class="o">.</span><span class="n">circuit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">U</span> <span class="o">=</span> <span class="n">S</span><span class="p">[:</span><span class="mi">4</span><span class="p">,</span> <span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">S</span><span class="p">[</span><span class="mi">4</span><span class="p">:,</span> <span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[ 0.2195-0.2565j  0.6111+0.5242j -0.1027+0.4745j -0.0273+0.0373j]
 [ 0.4513+0.6026j  0.457 +0.0123j  0.1316-0.4504j  0.0353-0.0532j]
 [ 0.0387+0.4927j -0.0192-0.3218j -0.2408+0.5244j -0.4584+0.3296j]
 [-0.1566+0.2246j  0.11  -0.1638j -0.4212+0.1836j  0.8188+0.068j ]]
</pre></div>
</div>
</div>
</div>
<p>which agrees with the result above.</p>
</section>
<section id="equally-squeezed-inputs">
<h2>Equally squeezed inputs<a class="headerlink" href="#equally-squeezed-inputs" title="Permalink to this heading">#</a></h2>
<p>As shown earlier, the formula for calculating the output
Fock state probability in Gaussian boson sampling is given by</p>
<p>$$
\left|\left\langle{n_1,n_2,\dots,n_N}\middle|{\psi’}\right\rangle\right|^2 =
\frac{\left|\text{Haf}[(U\bigoplus_i\tanh(r_i)U^T)]_{st}\right|^2}{n_1!n_2!\cdots n_N!
\cosh(r_i)}
$$</p>
<p>where $U$ is the rotation/beamsplitter unitary transformation on the input and output mode
annihilation and creation operators.</p>
<p>However, in this particular example, we are using <strong>the same</strong> squeezing parameter, $z=r$, for
all input states - this allows us to simplify this equation. To start with, the hafnian expression
simply becomes $\text{Haf}[(UU^T\tanh(r))]_{st}$, removing the need for the tensor sum.</p>
<p>Thus, we have</p>
<p>$$
\left|\left\langle{n_1,n_2,\dots,n_N}\middle|{\psi’}\right\rangle\right|^2 =
\frac{\left|\text{Haf}[(UU^T\tanh(r))]_{st}\right|^2}{n_1!n_2!\cdots n_N!\cosh^N(r)}.
$$</p>
<p>Now that we have the interferometer unitary transformation $U$, as well as the ‘experimental’
results, let’s compare the two, and see if the Gaussian boson sampling result in the case of equally
squeezed input modes, agrees with the Strawberry Fields simulation probabilities.</p>
</section>
<section id="calculating-the-hafnian">
<h2>Calculating the hafnian<a class="headerlink" href="#calculating-the-hafnian" title="Permalink to this heading">#</a></h2>
<p>Before we can calculate the right hand side of the Gaussian boson sampling equation, we need a
method of calculating the hafnian. Since the hafnian is classically hard to compute, it is not
provided in either NumPy <em>or</em> SciPy, so we will use <a class="reference external" href="https://the-walrus.readthedocs.io/">The Walrus</a> library, installed alongside Strawberry Fields:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">thewalrus</span> <span class="kn">import</span> <span class="n">hafnian</span> <span class="k">as</span> <span class="n">haf</span>
</pre></div>
</div>
</div>
</div>
<p>Now, for the right hand side numerator, we first calculate the submatrix
$[(UU^T\tanh(r))]_{st}$:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>In Gaussian boson sampling, we determine the submatrix by taking the rows and columns corresponding to the measured Fock state. For example, to calculate the submatrix in the case of the output measurement $\left|{1,1,0,0}\right\rangle$,</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">B</span><span class="p">[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]][[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[[-0.1022+0.3263j  0.5542+0.2856j]
 [ 0.5542+0.2856j -0.1051+0.3296j]]
</pre></div>
</div>
</div>
</div>
</section>
<section id="comparing-to-strawberry-fields">
<h2>Comparing to Strawberry Fields<a class="headerlink" href="#comparing-to-strawberry-fields" title="Permalink to this heading">#</a></h2>
<p>Now that we have a method for calculating the hafnian, let’s compare the output to that provided by
Strawberry Fields.</p>
<p><strong>Measuring</strong> $\ket{0,0,0,0}$ <strong>at the output</strong></p>
<p>This corresponds to the hafnian of an <em>empty</em> matrix, which is simply 1:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">4</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">fock_prob</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.1763784476141347
0.17637844761413482
</pre></div>
</div>
</div>
</div>
<p><strong>Measuring</strong> $\ket{1,1,0,0}$ <strong>at the output</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="mi">1</span><span class="p">))[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]][[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">haf</span><span class="p">(</span><span class="n">B</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">4</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">fock_prob</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.06855956371222349
0.06855956371222356
</pre></div>
</div>
</div>
</div>
<p><strong>Measuring</strong> $\ket{0,1,0,1}$ <strong>at the output</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="mi">1</span><span class="p">))[:,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]][[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">haf</span><span class="p">(</span><span class="n">B</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">4</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">fock_prob</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.0020560972589774
0.0020560972589773983
</pre></div>
</div>
</div>
</div>
<p><strong>Measuring</strong> $\ket{1,1,1,1}$ <strong>at the output</strong></p>
<p>This corresponds to the hafnian of the full matrix $B=UU^T\tanh(r)$:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">haf</span><span class="p">(</span><span class="n">B</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">4</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">fock_prob</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.008342946399867483
0.0083429463998675
</pre></div>
</div>
</div>
</div>
<p><strong>Measuring</strong> $\ket{2,0,0,0}$ <strong>at the output</strong></p>
<p>Since we have two photons in mode <code class="docutils literal notranslate"><span class="pre">q[0]</span></code>, we take two copies of the
first row and first column, making sure to divide by $2!$:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">U</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="mi">1</span><span class="p">))[:,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]][[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">haf</span><span class="p">(</span><span class="n">B</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cosh</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">4</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">fock_prob</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.010312945253454883
0.010312945253454915
</pre></div>
</div>
</div>
</div>
<p>The Strawberry Field simulation results agree (with almost negligible numerical error) to the
expected result from the Gaussian boson sampling equation!</p>
<div class="alert alert-block alert-info">
Repeat this tutorial with
<ol class="arabic simple">
<li><p>A Fock backend such as <code class="docutils literal notranslate"><span class="pre">'fock'</span></code> instead of the Gaussian backend.</p></li>
<li><p>Different beamsplitter and rotation parameters.</p></li>
<li><p>Input states with <em>differing</em> squeezed values
$r_i$. You will need to modify the code to take into account the fact that the output
covariance matrix determinant must now be calculated.</p></li>
</ol>
</div>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this heading">#</a></h2>
<p>[1] M.A. Nielsen and I.L. Chuang. Quantum Computation and Quantum Information. Cambridge
University Press, 2010. ISBN 9780511992773. URL:
https://books.google.ca/books?id=JRz3jgEACAAJ.</p>
<p>[2] Craig S. Hamilton, Regina Kruse, Linda Sansoni, Sonja Barkhofen, Christine Silberhorn,
and Igor Jex. Gaussian boson sampling. Physical Review Letters, 119:170501, Oct 2017.
arXiv:1612.01199, doi:10.1103/PhysRevLett.119.170501.</p>
<p>[3] Scott Aaronson and Alex Arkhipov. The computational complexity of linear optics. Theory of
Computing, 9(1):143–252, 2013. doi:10.4086/toc.2013.v009a004.</p>
<p>[4] L.G. Valiant. The complexity of computing the permanent. Theoretical Computer Science,
8(2):189–201, 1979. doi:10.1016/0304-3975(79)90044-6.</p>
<p>[5] Michael Reck, Anton Zeilinger, Herbert J. Bernstein, and Philip Bertani. Experimental
realization of any discrete unitary operator. Physical Review Letters, 73(1):58–61, Jul 1994.
doi:10.1103/physrevlett.73.58.</p>
<p>[6] William R Clements, Peter C Humphreys, Benjamin J Metcalf, W Steven Kolthammer, and
Ian A Walsmley. Optimal design for universal multiport interferometers. Optica,
3(12):1460–1465, 2016. doi:10.1364/OPTICA.3.001460.</p>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Gaussian boson sampling and the Hafnian</a><ul>
<li><a class="reference internal" href="#background-theory">Background theory</a><ul>
<li><a class="reference internal" href="#note"><strong>Note:</strong></a></li>
</ul>
</li>
<li><a class="reference internal" href="#circuit-construction-and-simulation">Circuit construction and simulation</a></li>
<li><a class="reference internal" href="#calculating-the-unitary">Calculating the unitary</a></li>
<li><a class="reference internal" href="#the-gaussian-compiler">The Gaussian compiler</a></li>
<li><a class="reference internal" href="#equally-squeezed-inputs">Equally squeezed inputs</a></li>
<li><a class="reference internal" href="#calculating-the-hafnian">Calculating the hafnian</a></li>
<li><a class="reference internal" href="#comparing-to-strawberry-fields">Comparing to Strawberry Fields</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/scripts/furo.js"></script>
    </body>
</html>