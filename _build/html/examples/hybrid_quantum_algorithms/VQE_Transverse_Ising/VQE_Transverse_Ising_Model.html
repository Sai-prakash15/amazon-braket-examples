<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <!-- Generated with Sphinx 5.3.0 and Furo 2022.12.07 -->
        <title>SOLVING THE TRANSVERSE ISING MODEL WITH VQE - Amazon Braket Examples documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=91d0f0d1c444bdcb17a68e833c7a53903343c195" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">Amazon Braket Examples  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  
  <span class="sidebar-brand-text">Amazon Braket Examples  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  
</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">braket.tracking</span> <span class="kn">import</span> <span class="n">Tracker</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tracker</span><span class="p">()</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<section id="solving-the-transverse-ising-model-with-vqe">
<h1>SOLVING THE TRANSVERSE ISING MODEL WITH VQE<a class="headerlink" href="#solving-the-transverse-ising-model-with-vqe" title="Permalink to this heading">#</a></h1>
<p>In this tutorial we show how to solve for the ground state of the <strong>Transverse Ising Model</strong>, arguably one of the most prominent, canonical quantum spin systems, using the <strong>variational quantum eigenvalue solver (VQE)</strong>.
The VQE algorithm belongs to the class of <strong>hybrid quantum algorithms</strong> (leveraging both classical as well as quantum compute), that are widely believed to be the working horse for the current <strong>NISQ (noisy intermediate-scale quantum) era</strong>.
To validate our approach we benchmark our results with exact results as obtained from a Jordan-Wigner transformation.</p>
<p>We provide a step-by-step walkthrough explaining the VQE quantum algorithm and show how to build the corresponding parametrized quantum circuit ansatz using the Braket SDK, with simple modular building blocks (that can be re-used for other purposes).
While we demonstrate our proof-of-concept approach using classical simulators for circuit execution, our code could in principle be run on actual quantum hardware by simply changing the definition of the <code class="docutils literal notranslate"><span class="pre">device</span></code> object.</p>
<section id="background-the-variational-quantum-eigensolver-vqe">
<h2>BACKGROUND: THE VARIATIONAL QUANTUM EIGENSOLVER (VQE)<a class="headerlink" href="#background-the-variational-quantum-eigensolver-vqe" title="Permalink to this heading">#</a></h2>
<p>Quantum computers hold the promise to outperform even the most-powerful classical computers on a range of computational problems in (for example) optimization, chemistry, material science and cryptography.
The canonical set of quantum algorithms (such as Shor’s or Grover’s quantum algorithms), however, comes with hardware requirements (such as a large number of quantum gates) that are currently not available with state-of-the-art technology.
Specifically, these algorithms are typically believed to be feasible only with fault-tolerance as provided by quantum error correction.
In the current <strong>noisy intermediate-sclae (NISQ) era</strong>, near-term quantum computers do not have a large enough number of physical qubits for the implementation of error correction protocols, making this canonical set of quantum algorithms unsuitable for near-term devices. Against this background, the near-term focus has widely shifted to the class of <strong>hybrid quantum algorithms</strong> that do not require quantum error correction.
In these hybrid quantum algorithms are the noisy <strong>near-term quantum computers are used as co-processors</strong> only, within a larger classical optimization loop, as sketched in the schematic figure below.
Here, the undesired effects of noise are suppressed by deliberately limiting the quantum circuits on the quantum processing unit (QPU) to short bursts of the calculation, and the need for long coherence times (as required for the standard set of quantum algorithms) is traded for a classical overhead due to (possibly many) measurement repetitions and (essentially error-free) classical processing.</p>
<div align="center"><img src="vqe_background.png"/></div><p><strong>Variational Quantum Algorithms</strong>: Specifically, variational quantum algorithms such as the Variational Quantum Eigensolver (VQE) [1, 2] or the Quantum Approximate Optimization Algorithm (QAOA) [3] belong to this emerging class of hybrid quantum algorithms.
These are widely believed to be promising candidates for the demonstration of a <strong>quantum advantage</strong>, already with near-term (NISQ) devices in areas such as quantum chemistry [4], condensed matter simulations [5], and discrete optimization tasks [6].</p>
<p><strong>Variational Quantum Computing vs. Deep Learning</strong>: The working principle of variational quantum computing is very much reminiscent of training deep neural networks:
When you train a neural network, you have an objective function that you want to minimize, typically characterized by the error on your training set.
To minimize that error, typically you start out with an initial guess for the weights in your network.
The coprocessor, in that case a GPU, takes these weights which define the exact operation to execute and the output of the neural network is computed.
This output is then used to calculate the value of your objective function, which in turn is used by the CPU to make an educated guess to update the weights and the cycle continues.
Variational quantum algorithms, a specific form of hybrid algorithms, work in the very same way, using parametrized quantum circuits rather than parametrized neural networks and replacing the GPU with a QPU.
Here, you start with an initial guess for the parameters that define your circuit, have the QPU execute that circuit, perform measurements to calculate an objective function, pass this value (together with the current values of the parameters) back to the CPU and have this <em>classical</em> CPU update the parameters based on that information.</p>
<p>Of course, coordinating that workflow for quantum computers is much more challenging than in the previous case. Quantum computers are located in specialized laboratory facilities, are typically single threaded, and have special latency requirements.
This is exactly the undifferentiated heavy-lifting that Amazon Braket takes away for you such that we can focus on our scientific problem.
For the sake of this introductory tutorial, we simply use a classical circuit simulator (that mimic the behaviour of a quantum machine) as device to execute our quantum circuits.
Within Amazon Braket, the workflow, however, is exactly the same.</p>
</section>
<section id="background-the-transverse-ising-model">
<h2>BACKGROUND: THE TRANSVERSE ISING MODEL<a class="headerlink" href="#background-the-transverse-ising-model" title="Permalink to this heading">#</a></h2>
<p>While VQE is a very general approach, for concreteness we will focus on applying VQE to the one-dimensional Transverse Ising Model (TIM). The TIM belongs to a the broader class of many-body spin systems that are inherently hard to study on classical computers as the dimension of the Hilbert space grows exponentially with the number of particles in the system. With the help of a quantum computer, however, we can study these many-body systems with less overhead as the number of qubits required only grows polynomially. Even more so, the specific TIM is an integrable system and can be solved exactly, as shown in [7]. We will use these exact results as a benchmark for our approximate VQE results.</p>
<p>The transverse field Ising model is a quantum version of the classical Ising model that describes a lattice of spins with nearest neighbour interactions of strength $J$ (as set by the alignment or anti-alignment of spin projections along the $z$ axis), as well as an external magnetic field along the $x$ axis with strength $B$, creating an energetic bias for one x-axis spin direction over the other.</p>
<p>In one dimension, the Hamiltonian describing the TIM for $N$ spin-$1/2$ particles reads:</p>
<p>$$H = -J\sum_{i}S_{i}^{z}S_{i+1}^{z} - B\sum_{i}S_{i}^{x}.$$
Transforming the spin variables to qubits, we obtain:
$$H = -\frac{1}{4}\sum_{i}\sigma_{i}^{z}\sigma_{i+1}^{z} - \frac{B}{2}\sum_{i}\sigma_{i}^{x}.$$</p>
<p>Here, $B$ denotes the strength of the transverse magnetic field (in units of the hopping matrix element $J$ that we have set to unity).</p>
<p><strong>Symmetries and Phases</strong>: The Hamiltonian $H$ possesses a $\mathbb{Z}<em>{2}$ symmetry, as it is invariant under the unitary transformation of flipping all qubits along the $z$-direction by an angle of $\pi$. Formally, this property can be expressed as $R</em>{x}HR_{x}^{\dagger}=H$, since $R_{x}\sigma_{i}^{z}R_{x}^{\dagger}=-\sigma_{i}^{z}$ and $R_{x}\sigma_{i}^{x}R_{x}^{\dagger}=\sigma_{i}^{x}$, with $R_{x}=\exp(-i \pi/2 \sum_{i}\sigma_{i}^{x})= (-i)^{N}\prod <em>{i}\sigma</em>{i}^{x}$ being a global rotation around the $x$-axis by angle $\pi$.
The 1D model then allows for two phases, depending on whether the ground state $\left|\Psi_{\mathrm{gs}}\right&gt;$ breaks or preserves this global spin-flip symmetry [8]:</p>
<ul class="simple">
<li><p><em>Ordered Phase</em>: When the transverse field $B$ is small, the system is in the ordered phase. In this phase the ground state breaks the spin-flip symmetry. Thus, the ground state is in fact two-fold degenerate.
Mathematically, if ${\displaystyle |\psi _{1}\rangle }$  is a ground state of the Hamiltonian, then ${\displaystyle |\psi <em>{2}\rangle \equiv \prod \sigma^{x}</em>{j}|\psi _{1}\rangle \neq |\psi _{1}\rangle }$ is a ground state as well. Taken together, these two distinct states span the degenerate ground state space.
Consider the following example for $B=0$: In this case, the ground state space is spanned by the states ${\displaystyle |\ldots 1,1,1, \ldots \rangle }$ and ${\displaystyle |\ldots 0,0,0, \ldots \rangle }$, that is, with all the qubits aligned along the $z$ axis.</p></li>
<li><p><em>Disordered Phase</em>: In contrast, when $B&gt;1$, the system is in the disordered phase. Here, the ground state <em>does</em> preserve the spin-flip symmetry, and is nondegenerate (as opposed to the ordered phase discussed above).
Consider the following example when $B \rightarrow \infty$: Here, the ground state is simply the state aligned with the external magnetic field, ${\displaystyle |\ldots +,+,+, \ldots \rangle}$, with every qubit (spin) pointing in the $x$ direction.</p></li>
</ul>
<p>There is a quantum phase transition at $B=1$ separating these two phases.</p>
</section>
<section id="imports-and-setup">
<h2>IMPORTS and SETUP<a class="headerlink" href="#imports-and-setup" title="Permalink to this heading">#</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># general imports</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="c1"># magic word for producing visualizations in notebook</span>
<span class="o">%</span><span class="k">matplotlib</span> inline
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Ensure consistent results</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Flag to trigger writing results plot to file</span>
<span class="n">SAVE_FIG</span> <span class="o">=</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># AWS imports: Import Braket SDK modules</span>
<span class="kn">from</span> <span class="nn">braket.circuits</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">Gate</span><span class="p">,</span> <span class="n">AngledGate</span><span class="p">,</span> <span class="n">QubitSet</span>
<span class="kn">from</span> <span class="nn">braket.devices</span> <span class="kn">import</span> <span class="n">LocalSimulator</span>
<span class="kn">from</span> <span class="nn">braket.aws</span> <span class="kn">import</span> <span class="n">AwsDevice</span><span class="p">,</span> <span class="n">AwsSession</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up device: Local Simulator</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">LocalSimulator</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1">## example code for other backends</span>
<span class="c1">## choose the on-demand simulator to run your circuit</span>
<span class="c1"># device = AwsDevice(&quot;arn:aws:braket:::device/quantum-simulator/amazon/sv1&quot;)</span>
<span class="c1">## choose the Rigetti device to run your circuit</span>
<span class="c1"># device = AwsDevice(&quot;arn:aws:braket:us-west-1::device/qpu/rigetti/Aspen-M-2&quot;)</span>
<span class="c1">## choose the Ionq device to run your circuit</span>
<span class="c1"># device = AwsDevice(&quot;arn:aws:braket:::device/qpu/ionq/ionQdevice&quot;)</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="problem-setup">
<h2>PROBLEM SETUP<a class="headerlink" href="#problem-setup" title="Permalink to this heading">#</a></h2>
<p>In this section we develop a set of useful helper functions that we will explain in detail below.
Specifically we provide simple building blocks for the core modules of our VQE algorithm, that is (i) a function called <code class="docutils literal notranslate"><span class="pre">circuit</span></code> that defines the parametrized ansatz, (ii) a function called <code class="docutils literal notranslate"><span class="pre">objective_function</span></code> that takes a list of variational parameters as input, and returns the cost associated with those parameters and finally (iii) a function <code class="docutils literal notranslate"><span class="pre">train</span></code> to run the entire VQE algorithm for given ansatz.
This way we can solve the problem in a clean and modular approach.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># helper function to set up interaction term</span>
<span class="k">def</span> <span class="nf">get_ising_interactions</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function to setup Ising interaction term</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># set number of qubits</span>
    <span class="n">ising</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_qubits</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">))</span>
    <span class="c1"># set nearest-neighbour interactions to nonzero values only</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_qubits</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">ising</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c1"># add periodic boundary conditions</span>
    <span class="n">ising</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n_qubits</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Ising matrix:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">ising</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">ising</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># function to build the VQE ansatz</span>
<span class="k">def</span> <span class="nf">circuit</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function to return full VQE circuit ansatz</span>
<span class="sd">    input: parameter list with three parameters </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># instantiate circuit object</span>
    <span class="n">circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
    
    <span class="c1"># add Hadamard gate on first qubit</span>
    <span class="n">circuit</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># apply series of CNOT gates</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">):</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="n">control</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">ii</span><span class="p">)</span>

    <span class="c1"># add parametrized single-qubit rotations around y</span>
    <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">):</span>
        <span class="n">gate</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">circuit</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">gate</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">circuit</span>


<span class="c1"># function that computes cost function for given params</span>
<span class="k">def</span> <span class="nf">objective_function</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">b_field</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">,</span> <span class="n">n_shots</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    objective function takes a list of variational parameters as input,</span>
<span class="sd">    and returns the cost associated with those parameters</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">global</span> <span class="n">CYCLE</span>
    <span class="n">CYCLE</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;==================================&#39;</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calling the quantum circuit. Cycle:&#39;</span><span class="p">,</span> <span class="n">CYCLE</span><span class="p">)</span>
    
    <span class="c1"># obtain a quantum circuit instance from the parameters</span>
    <span class="n">vqe_circuit</span> <span class="o">=</span> <span class="n">circuit</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">)</span>
    
    <span class="c1"># Computations are independent of one another, so can be triggered in parallel</span>
    <span class="c1"># run the circuit on appropriate device</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">LocalSimulator</span><span class="p">):</span>
        <span class="n">task_zz</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">vqe_circuit</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">n_shots</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="n">task_zz</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">vqe_circuit</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">n_shots</span><span class="p">)</span>

    <span class="c1"># Hb term: construct the circuit for measuring in the X-basis</span>
    <span class="n">H_on_all</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">))</span>
    <span class="n">vqe_circuit</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">H_on_all</span><span class="p">)</span>
    
    <span class="c1"># run the circuit (with H rotation at end)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">LocalSimulator</span><span class="p">):</span>
        <span class="n">task_b</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">vqe_circuit</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">n_shots</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">task_b</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">vqe_circuit</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">n_shots</span><span class="p">)</span>

    <span class="c1"># Collect results from devices (wait for results, if necessary)</span>
    <span class="n">result_zz</span> <span class="o">=</span> <span class="n">task_zz</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
    <span class="n">result_b</span> <span class="o">=</span> <span class="n">task_b</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
    
    <span class="c1"># Compute Hzz term</span>
    <span class="c1"># convert results (0 and 1) to ising (1 and -1)</span>
    <span class="n">meas_ising</span> <span class="o">=</span> <span class="n">result_zz</span><span class="o">.</span><span class="n">measurements</span>
    <span class="n">meas_ising</span><span class="p">[</span><span class="n">meas_ising</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">meas_ising</span><span class="p">[</span><span class="n">meas_ising</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    
    <span class="c1"># Hzz term: get all energies (for every shot): (n_shots, 1) vector</span>
    <span class="n">all_energies_zz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">meas_ising</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">meas_ising</span><span class="p">))))</span>
    
    <span class="c1"># Hzz term: get approx energy expectation value (factor 1/4 for Pauli vs spin 1/2) </span>
    <span class="n">energy_expect_zz</span> <span class="o">=</span> <span class="mf">0.25</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">all_energies_zz</span><span class="p">)</span><span class="o">/</span><span class="n">n_shots</span>
    
    <span class="c1"># Compute Hb term</span>
    <span class="c1"># convert results (0 and 1) to ising (1 and -1)</span>
    <span class="n">meas_ising</span> <span class="o">=</span> <span class="n">result_b</span><span class="o">.</span><span class="n">measurements</span>
    <span class="n">meas_ising</span><span class="p">[</span><span class="n">meas_ising</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">meas_ising</span><span class="p">[</span><span class="n">meas_ising</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    
    <span class="c1"># Hb term: get all energies (for every shot): (n_shots, 1) vector</span>
    <span class="c1"># factor 1/2 for Pauli vs spin 1/2</span>
    <span class="n">energy_expect_b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">b_field</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">meas_ising</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">n_shots</span>
    
    <span class="c1"># get total energy expectation value</span>
    <span class="n">energy_expect</span> <span class="o">=</span> <span class="n">energy_expect_zz</span> <span class="o">+</span> <span class="n">energy_expect_b</span>
    <span class="c1"># per site</span>
    <span class="n">energy_expect_ind</span> <span class="o">=</span> <span class="n">energy_expect</span><span class="o">/</span><span class="n">n_qubits</span>
    
    <span class="c1"># print energy expectation value</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Energy expectation value:&#39;</span><span class="p">,</span> <span class="n">energy_expect</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Energy expectation value (per particle):&#39;</span><span class="p">,</span> <span class="n">energy_expect_ind</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">energy_expect</span>


<span class="c1"># The function to execute the training: run classical minimization.</span>
<span class="k">def</span> <span class="nf">train</span><span class="p">(</span><span class="n">b_field</span><span class="p">,</span> <span class="n">options</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">,</span> <span class="n">n_shots</span><span class="p">,</span> <span class="n">n_initial</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function to run VQE algorithm with several random seeds for initialization</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting the training.&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;==================================&#39;</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running VQE OPTIMIZATION.&#39;</span><span class="p">)</span>
    
    <span class="c1"># initialize vectors for results per random seed</span>
    <span class="n">cost_energy</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># optimize for different random initializations: avoid local optima</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_initial</span><span class="p">):</span>
        
        <span class="c1">#print counter</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">run_init</span> <span class="o">=</span> <span class="n">ii</span><span class="o">+</span><span class="mi">1</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running VQE OPTIMIZATION for random seed NUMBER&#39;</span><span class="p">,</span> <span class="n">run_init</span><span class="p">)</span>
        
        <span class="c1"># randomly initialize variational parameters within appropriate bounds</span>
        <span class="n">params0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># set bounds for search space</span>
        <span class="n">bnds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">params0</span><span class="p">)))]</span>

        <span class="c1"># run classical optimization</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">objective_function</span><span class="p">,</span> <span class="n">params0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">b_field</span><span class="p">,</span> <span class="n">n_qubits</span><span class="p">,</span> <span class="n">n_shots</span><span class="p">,</span> <span class="n">verbose</span><span class="p">),</span> 
                          <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bnds</span><span class="p">)</span>

        <span class="c1"># store result of classical optimization</span>
        <span class="n">result_energy</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fun</span>
        <span class="n">cost_energy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_energy</span><span class="p">)</span>
        <span class="n">result_angle</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span>
        <span class="n">angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result_angle</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Optimal avg energy:&#39;</span><span class="p">,</span> <span class="n">result_energy</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Optimal angles:&#39;</span><span class="p">,</span> <span class="n">result_angle</span><span class="p">)</span>
        
        <span class="c1"># reset cycle count </span>
        <span class="k">global</span> <span class="n">CYCLE</span>
        <span class="n">CYCLE</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># store energy minimum (over different initial configurations)</span>
    <span class="n">energy_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cost_energy</span><span class="p">)</span>
    <span class="n">optim_angles</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">cost_energy</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Energy per initial seeds:&#39;</span><span class="p">,</span> <span class="n">cost_energy</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Minimal energy:&#39;</span><span class="p">,</span> <span class="n">energy_min</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Optimal variational angles:&#39;</span><span class="p">,</span> <span class="n">optim_angles</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">energy_min</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="illustration-of-the-vqe-ansatz">
<h2>Illustration of the VQE ansatz<a class="headerlink" href="#illustration-of-the-vqe-ansatz" title="Permalink to this heading">#</a></h2>
<p><strong>VQE ansatz</strong>: VQE tries to find the lowest energy configuration of a given Hamiltonian, such as that of a chemical system or some many-body spin system (as studied here). Being a variational quantum-classical algorithm, VQE uses the QPU for state preparation and measurement subroutines, and the classical computer to post-process the measurement results and update the parametrized VQE ansatz according to an update rule such as gradient descent.
VQE, however, does not come without limitations.
Akin to what happens in deep learning, the quality of our results will depend very much on the trial architecture of our circuit (i.e., the trial wave function) and its the expressive power.
In other words, to <em>approximate</em> the ground state we are looking for, VQE can only operate within the bounds of the general ansatz we are using (the so-called ansatz space), by having a quantum computer prepare this very ansatz state with a parameterized gate sequence, and then have a classical optimizer iteratively update the optimal parameters.
Here, we will be guided by physical intuition and symmetry arguments to make an educated guess for our variational ansatz.</p>
<p>In general, VQE makes us of the variational principle, by preparing a parametrized trial wavefunction $\left|\Psi(\vec{\theta})\right&gt;$, and trying to find the optimal set of parameters $\vec{\theta}^{*}$, according to the following objective
$$\mathrm{min} \left&lt;\Psi(\vec{\theta})|H|\Psi(\vec{\theta})\right&gt; \geq E_{0}.$$</p>
<p>Here, $E_{0}$ denotes the (true) lowest energy eigenvalue of the Hamiltonian $H$.
Since (for sufficiently large systems with more than $\sim 50$ qubits) classical computers are unable to efficiently prepare, store and measure the wavefunction, we use the quantum computer for this subroutine.
We then use the classical computer to iteratively update the parameters using some optimization algorithm [9].</p>
<p><strong>VQE ansatz for TIM</strong>: Next, we need to choose an ansatz appropriate for the system under study, the Transverse Ising Model (TIM).
We use an ansatz that can account for quantum entanglement.
Because of the $\mathbb{Z}<em>{2}$ symmetry discussed above, for any given state $\left|\Psi(\theta)\right&gt;$ the rotated state $R</em>{x}\left|\Psi(\theta)\right&gt;$ is a degenerate state with the same energy.
Therefore, we take our ansatz as a linear superposition of these two degenerate states, $\left|\psi(\theta)\right&gt; = \alpha \left|\Psi(\theta)\right&gt; + \beta R_{x}\left|\Psi(\theta)\right&gt;$. How can we prepare such a state on a quantum computer? We use the following sequence of parametrized gates [10]:</p>
<p>First, starting from $\left|0000\right&gt;$ we apply a general single qubit rotation to the first qubit to obtain the state</p>
<p>$$\left|000\dots\right&gt; \rightarrow \alpha \left|000\dots\right&gt; + \beta \left|100\dots\right&gt;,$$</p>
<p>where the parameters $\alpha, \beta$ can be learned in the training process.
Then, we apply a sequence of CNOT gates as is done for the preparation of GHZ states.
The first CNOT between the first and second qubits prepares the state</p>
<p>$$\alpha \left|000\dots\right&gt; + \beta \left|110\dots\right&gt;.$$</p>
<p>We continue with CNOT gates till we arrive at the parametrized ansatz</p>
<p>$$\alpha \left|000\dots\right&gt; + \beta \left|111\dots\right&gt;.$$</p>
<p>Finally, to account for different polarization directions we apply parametrized single qubit rotations around the $y$ axis to arrive at our VQE trial ansatz state</p>
<p>$$\left|\Psi(\theta)\right&gt; = \alpha U_{y}(\theta_{y})\left|000\dots\right&gt; + \beta U_{y}(\theta_{y})\left|111\dots\right&gt;,$$</p>
<p>with $U_{y}(\theta_{y})=\prod \exp(-i \theta_{y}/2 \sigma_{i}^{y})$.</p>
<p><strong>Illustration</strong>: Below, we illustrate our ansatz (as prepared by our method <code class="docutils literal notranslate"><span class="pre">circuit</span></code>) with a circuit diagram for a small number of qubits $N$ and a fixed set of classical parameters. We print both our VQE ansatz as well as the modified circuit with a layer of single-qubit Hadamard gates <code class="docutils literal notranslate"><span class="pre">H</span></code> attached at the end, as needed to measure the $x$ projection with $\sigma_{i}^{x}$ for all qubits. The latter is needed to compute the expectation value for the transverse field term $H_{B}=(B/2)\sum_{i}\sigma_{i}^{x}$. With this simple visualization we can convince ourselves that we have implemented the circuit ansatz as desired.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># visualize VQE circuit example</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]</span>

<span class="n">vqe_circuit</span> <span class="o">=</span> <span class="n">circuit</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;1. Printing VQE test circuit:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">vqe_circuit</span><span class="p">)</span>

<span class="c1"># Hb term: construct the circuit for measuring in the X-basis</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;2. Apply Hadamard to measure in x-basis:&#39;</span><span class="p">)</span>
<span class="n">H_on_all</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
<span class="n">vqe_circuit</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">H_on_all</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">vqe_circuit</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1. Printing VQE test circuit:
T  : |   0   |   1   |2|    3    |    4    |   5   |
                                                    
q0 : -Rz(0.1)-Ry(0.2)-C-C---------C---------Ry(0.3)-
                      | |         |                 
q1 : -----------------X-|-Ry(0.3)-|-----------------
                        |         |                 
q2 : -------------------X---------|-Ry(0.3)---------
                                  |                 
q3 : -----------------------------X---------Ry(0.3)-

T  : |   0   |   1   |2|    3    |    4    |   5   |

2. Apply Hadamard to measure in x-basis:
T  : |   0   |   1   |2|    3    |    4    |   5   |6|
                                                      
q0 : -Rz(0.1)-Ry(0.2)-C-C---------C---------Ry(0.3)-H-
                      | |         |                   
q1 : -----------------X-|-Ry(0.3)-|-H-----------------
                        |         |                   
q2 : -------------------X---------|-Ry(0.3)-H---------
                                  |                   
q3 : -----------------------------X---------Ry(0.3)-H-

T  : |   0   |   1   |2|    3    |    4    |   5   |6|
</pre></div>
</div>
</div>
</div>
</section>
<section id="vqe-simulation-on-local-simulator">
<h2>VQE SIMULATION ON LOCAL SIMULATOR<a class="headerlink" href="#vqe-simulation-on-local-simulator" title="Permalink to this heading">#</a></h2>
<p>We are now ready to run some VQE simulation experiments. First of all, you can play and experiment yourself with the number of qubits $N$. Secondly, you may also experiment with the classical optimizer. Since we are using an off-the-shelf <code class="docutils literal notranslate"><span class="pre">scipy</span></code> minimizer (as described in more detail <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">here</a>), you can simply swap between different optimizers by setting the <code class="docutils literal notranslate"><span class="pre">method</span></code> parameter accordingly, as done above in the line <code class="docutils literal notranslate"><span class="pre">result</span> <span class="pre">=</span> <span class="pre">minimize(...,</span> <span class="pre">method='SLSQP')</span></code>. Some popular options readily available within this library include <em>Nelder-Mead</em>, <em>BFGS</em> and <em>COBYLA</em>.<br />
As a precautionary warning, note that the classical optimization step may get stuck in a local optimum, rather than finding the global minimum for our parametrized VQE ansatz wavefunction.
To address this issue, we run several optimization loops, starting from different random parameter seeds.
You can set the number of these optimization loops using the <code class="docutils literal notranslate"><span class="pre">n_initial</span></code> parameter, as shown below.
While this brute-force approach does not provide any guarantee to find the global optimum, from a pragmatic point of view at least it does increase the odds of finding an acceptable solution, at the expense of potentially having to run many more circuits on the QPU.
For a more detailed and sophisticated discussion of classical optimization of VQE we refer to Ref.[11].</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># set up the problem</span>
<span class="n">SHOTS</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1"># number of qubits</span>
<span class="n">n_initial</span> <span class="o">=</span> <span class="mi">30</span> <span class="c1"># number of random seeds to explore optimization landscape</span>
<span class="n">verbose</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># control amount of print output</span>

<span class="c1"># set counters</span>
<span class="n">CYCLE</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># set up Ising matrix with nearest neighbour interactions and PBC</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">get_ising_interactions</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

<span class="c1"># set options for classical optimization</span>
<span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
    <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
<span class="k">else</span><span class="p">:</span> 
    <span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c1"># kick off training</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

<span class="c1"># parameter scan</span>
<span class="n">stepsize</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">xvalues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="n">stepsize</span><span class="p">,</span> <span class="n">stepsize</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">results_site</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="n">xvalues</span><span class="p">:</span>
    <span class="n">b_field</span> <span class="o">=</span> <span class="n">bb</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Strength of magnetic field:&#39;</span><span class="p">,</span> <span class="n">b_field</span><span class="p">)</span>
    <span class="n">energy_min</span> <span class="o">=</span> <span class="n">train</span><span class="p">(</span><span class="n">b_field</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span> <span class="n">n_qubits</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">n_shots</span><span class="o">=</span><span class="n">SHOTS</span><span class="p">,</span> <span class="n">n_initial</span><span class="o">=</span><span class="n">n_initial</span><span class="p">,</span> 
                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">energy_min</span><span class="p">)</span>
    <span class="n">results_site</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">energy_min</span><span class="o">/</span><span class="n">N</span><span class="p">)</span>
    
    <span class="c1"># reset counters</span>
    <span class="n">CYCLE</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
<span class="c1"># print execution time</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Code execution time [sec]:&#39;</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>

<span class="c1"># print optimized results</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Optimal energies:&#39;</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Optimal energies (per site):&#39;</span><span class="p">,</span> <span class="n">results_site</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Ising matrix:
 [[ 0. -1.  0.  0.  0.  0.  0.  0.  0. -1.]
 [ 0.  0. -1.  0.  0.  0.  0.  0.  0.  0.]
 [ 0.  0.  0. -1.  0.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  0. -1.  0.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  0. -1.  0.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.  0. -1.  0.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  0. -1.  0.  0.]
 [ 0.  0.  0.  0.  0.  0.  0.  0. -1.  0.]
 [ 0.  0.  0.  0.  0.  0.  0.  0.  0. -1.]
 [ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.]]
Strength of magnetic field: 0.0
Starting the training.
Strength of magnetic field: 0.5
Starting the training.
Strength of magnetic field: 1.0
Starting the training.
Strength of magnetic field: 1.5
Starting the training.
Strength of magnetic field: 2.0
Starting the training.
Code execution time [sec]: 50.120402097702026
Optimal energies: [-2.498, -2.9795, -4.5729999999999995, -7.1125, -9.302999999999999]
Optimal energies (per site): [-0.24980000000000002, -0.29795, -0.45729999999999993, -0.7112499999999999, -0.9302999999999999]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># plot the VQE results for the energy per site</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xvalues</span><span class="p">,</span> <span class="n">results_site</span><span class="p">,</span> <span class="s1">&#39;m--o&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;transverse field $B [J]$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;groundstate energy per site $E_</span><span class="si">{0}</span><span class="s1">/N [J]$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/961ff776a8a16c74191542e0a34f0c5bfac83edcb70eed2d91fc6fc3cc86cf90.png" src="../../../_images/961ff776a8a16c74191542e0a34f0c5bfac83edcb70eed2d91fc6fc3cc86cf90.png" />
</div>
</div>
</section>
<section id="benchmarking-our-vqe-ansatz-with-exact-results">
<h2>BENCHMARKING OUR VQE ANSATZ WITH EXACT RESULTS<a class="headerlink" href="#benchmarking-our-vqe-ansatz-with-exact-results" title="Permalink to this heading">#</a></h2>
<p>As detailed in the seminal paper by [7], the paradigmatic TIM can be solved with the help of a (highly non-local) Jordan-Wigner transformation that expresses the spin (qubit) variables as fermionic variables, and leading to a sum of local quadratic terms containing fermionic creation and annihilation operators.
The resulting Hamiltonian is mathematically identical to that of a superconductor in the mean field Bogoliubov deGennes formalism and can be completely understood in the same standard way.
Specifically, the exact excitation spectrum and eigenvalues can be determined by Fourier transforming into momentum space and diagonalizing the Hamiltonian.</p>
<p>Here, we just use the known results from Ref.[7] to recover the exact ground-state energy with the helper function defined below, and refer the interested reader to the broad set of literature on the TIM for further details. The original paper is available <a class="reference external" href="https://www.math.ucdavis.edu/~bxn/pfeuty1970.pdf">online here</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># helper function to numerically solve for gs energy of TIM</span>
<span class="k">def</span> <span class="nf">num_integrate_gs</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    numerically integrate exact band to get gs energy of TIM</span>
<span class="sd">    this should give -E_0/(N*J) by Pfeufy</span>
<span class="sd">    Here set J=1 (units of energy)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># lamba_ratio (setting J=1): compare thesis</span>
    <span class="n">ll</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">B</span><span class="p">)</span>
    
    <span class="c1"># set energy</span>
    <span class="n">gs_energy</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="c1"># numerical integration</span>
    <span class="n">step_size</span> <span class="o">=</span> <span class="mf">0.0001</span>
    <span class="n">k_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">step_size</span><span class="p">)</span>
    <span class="n">integration_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">step_size</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">ll</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">ll</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">kk</span><span class="p">))</span> <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">k_values</span><span class="p">]</span>
    <span class="n">integral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">integration_values</span><span class="p">)</span>
    <span class="n">gs_energy</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="n">integral</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">ll</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">gs_energy</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># plot exact gs energy of TIM vs VQE results</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">2.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">num_integrate_gs</span><span class="p">(</span><span class="n">xx</span><span class="p">)</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
<span class="c1"># plot exact results</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;b--s&#39;</span><span class="p">)</span>
<span class="c1"># plot vqe results</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xvalues</span><span class="p">,</span> <span class="n">results_site</span><span class="p">,</span> <span class="s1">&#39;m--o&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;magnetic field $B [J]$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;groundstate energy $E_</span><span class="si">{0}</span><span class="s1">/N [J]$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">();</span>
<span class="c1"># save figure</span>
<span class="k">if</span> <span class="n">SAVE_FIG</span><span class="p">:</span>
    <span class="n">time_now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">(),</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">%H%M%S&#39;</span><span class="p">)</span>
    <span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;vqe_tim_gs-energy_&#39;</span><span class="o">+</span><span class="n">time_now</span><span class="o">+</span><span class="s1">&#39;.png&#39;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">700</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/5d70b0856d7c4c2e8575be0cc88bd584362676368cc3bb751fae01c790582d7d.png" src="../../../_images/5d70b0856d7c4c2e8575be0cc88bd584362676368cc3bb751fae01c790582d7d.png" />
</div>
</div>
<p>As shown above, for sufficiently large number of seeds (<code class="docutils literal notranslate"><span class="pre">n_initial</span></code>) we approximate the exact results reasonably well with our relatively simple three-parameter VQE ansatz, in the whole magnetic field region under consideration.</p>
</section>
<hr class="docutils" />
<section id="references">
<h2>REFERENCES<a class="headerlink" href="#references" title="Permalink to this heading">#</a></h2>
<p>[1] A. Peruzzo, J. McClean, P. Shadbolt, M.-H. Yung, X.-Q. Zhou, P. J. Love, A. Aspuru-Guzik, and J. L. Obrien, Nature communications 5, 56 (2014).</p>
<p>[2] J. R. McClean, J. Romero, R. Babbush, and A. Aspuru-Guzik, <em>The theory of variational hybrid quantum-classical algorithms</em>, New Journal of Physics 18, 023023 (2016).</p>
<p>[3] E. Farhi, J. Goldstone, and S. Gutmann, arXiv 1411.4028 (2014).</p>
<p>[4] Y. Cao, J. Romero, J. P. Olson, M. Degroote, P. D. Johnson, M. Kieferov´a, I. D. Kivlichan, T. Menke, B. Peropadre, N. P. Sawaya, et al., Chemical reviews 119,
10856 (2019).</p>
<p>[5] A. Smith, M. Kim, F. Pollmann, and J. Knolle, npj
Quantum Information 5, 1 (2019).</p>
<p>[6] L. Zhou, S.-T. Wang, S. Choi, H. Pichler, and M. D.
Lukin, arXiv 1812.01041 (2018).</p>
<p>[7] P. Pfeuty, <em>The One-Dimensional Ising Model with a Transverse Field</em>, Annals of Physics <strong>57</strong>, 79-90 (1970).</p>
<p>[8] https://en.wikipedia.org/wiki/Transverse-field_Ising_model</p>
<p>[9] S. McArdle, S. Endo, A. Aspuru-Guzik, S. Benjamin, X. Yuan, <em>Quantum computational chemistry</em>, Rev. Mod. Phys. 92, 15003 (2020).</p>
<p>[10] Abhijith J. <em>et al.</em>, <em>Quantum Algorithm Implementations for Beginners</em>, arXiv:1804.03719 (2018).</p>
<p>[11] D. Wierichs, C. Gogolin, M. Kastoryano, <em>Avoiding local minima in variational quantum eigensolvers with the natural gradient optimizer</em>, arXiv:2004.14666 (2020).</p>
</section>
<hr class="docutils" />
<section id="appendix">
<h2>APPENDIX<a class="headerlink" href="#appendix" title="Permalink to this heading">#</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check SDK version</span>
<span class="o">!</span>pip show amazon-braket-sdk <span class="p">|</span> grep Version
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Version: 0.6.0
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Task Summary&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">quantum_tasks_statistics</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Estimated cost to run this example with SV1: </span><span class="si">{</span><span class="n">t</span><span class="o">.</span><span class="n">qpu_tasks_cost</span><span class="p">()</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">simulator_tasks_cost</span><span class="p">()</span><span class="si">}</span><span class="s2"> USD&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Task Summary
{&#39;arn:aws:braket:::device/quantum-simulator/amazon/sv1&#39;: {&#39;shots&#39;: 724000, &#39;tasks&#39;: {&#39;COMPLETED&#39;: 724}, &#39;execution_duration&#39;: 21834, &#39;billed_execution_duration&#39;: 2172000}}
Estimated cost to run this example with SV1: 2.7150000000 USD
</pre></div>
</div>
</div>
</div>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">SOLVING THE TRANSVERSE ISING MODEL WITH VQE</a><ul>
<li><a class="reference internal" href="#background-the-variational-quantum-eigensolver-vqe">BACKGROUND: THE VARIATIONAL QUANTUM EIGENSOLVER (VQE)</a></li>
<li><a class="reference internal" href="#background-the-transverse-ising-model">BACKGROUND: THE TRANSVERSE ISING MODEL</a></li>
<li><a class="reference internal" href="#imports-and-setup">IMPORTS and SETUP</a></li>
<li><a class="reference internal" href="#problem-setup">PROBLEM SETUP</a></li>
<li><a class="reference internal" href="#illustration-of-the-vqe-ansatz">Illustration of the VQE ansatz</a></li>
<li><a class="reference internal" href="#vqe-simulation-on-local-simulator">VQE SIMULATION ON LOCAL SIMULATOR</a></li>
<li><a class="reference internal" href="#benchmarking-our-vqe-ansatz-with-exact-results">BENCHMARKING OUR VQE ANSATZ WITH EXACT RESULTS</a></li>
<li><a class="reference internal" href="#references">REFERENCES</a></li>
<li><a class="reference internal" href="#appendix">APPENDIX</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    </body>
</html>