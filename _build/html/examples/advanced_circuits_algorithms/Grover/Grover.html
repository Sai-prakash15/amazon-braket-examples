<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <!-- Generated with Sphinx 5.3.0 and Furo 2022.12.07 -->
        <title>Grover’s Search Algorithm - Amazon Braket Examples documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=91d0f0d1c444bdcb17a68e833c7a53903343c195" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">Amazon Braket Examples  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon no-toc" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  
  <span class="sidebar-brand-text">Amazon Braket Examples  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  
</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon no-toc" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="grover-s-search-algorithm">
<h1>Grover’s Search Algorithm<a class="headerlink" href="#grover-s-search-algorithm" title="Permalink to this heading">#</a></h1>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Use Braket SDK Cost Tracking to estimate the cost to run this example</span>
<span class="kn">from</span> <span class="nn">braket.tracking</span> <span class="kn">import</span> <span class="n">Tracker</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tracker</span><span class="p">()</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>In this tutorial, we provide a step-by-step walkthrough explaining Grover’s quantum algorithm. We show how to build the corresponding quantum circuit with simple modular building blocks using the Braket SDK. Specifically, we demonstrate how to build custom gates that are not part of the basic gate set provided by the SDK. A custom gate can used as a core quantum gate by registering it as a subroutine.</p>
<p>After building the circuit, we will run it on two types of devices: 1) classical simulator, and 2) ion-based quantum machine provided by IonQ. For the latter, we will demonstrate how to recover quantum tasks that may be waiting in queue.</p>
<ol class="arabic simple">
<li><p><span class="xref myst">Introduction</span></p></li>
<li><p><span class="xref myst">Background: What is a Quantum Oracle?</span></p></li>
<li><p><span class="xref myst">Anatomy of Grover’s Algorithm</span></p></li>
<li><p><span class="xref myst">Circuit Diagram</span></p></li>
<li><p><span class="xref myst">Code</span></p></li>
<li><p><span class="xref myst">Libraries and Parameters</span></p></li>
<li><p><span class="xref myst">Helper Functions</span></p></li>
<li><p><span class="xref myst">Device: Classical Simulator</span></p></li>
<li><p><span class="xref myst">Device: IonQ</span></p></li>
<li><p><span class="xref myst">References</span></p></li>
</ol>
<p>This tutorial is based on ion-trap experiments published as <em>C. Figgatt, D. Maslov, K. A. Landsman, N. M. Linke, S. Debnath &amp; C. Monroe (2017), “Complete 3-Qubit Grover search on a programmable quantum computer”, Nature Communications, Vol 8, Art 1918, doi:10.1038/s41467-017-01904-7, arXiv:1703.10535</em>.</p>
</section>
<section id="introduction-a-name-introduction-a">
<h1>Introduction<a name="introduction"></a><a class="headerlink" href="#introduction-a-name-introduction-a" title="Permalink to this heading">#</a></h1>
<p>Grover’s algorithm is arguably one of the canonical quantum algorithms that kick-started the field of quantum computing. In the future, it could possibly serve as a hallmark application of quantum computing. Grover’s algorithm allows us to find a particular register in an unordered database with $N$ entries in just $O(\sqrt{N})$ steps, compared to the best classical algorithm taking on average $N/2$ steps, thereby providing a <strong>quadratic speedup</strong>.</p>
<p>For large databases (with a large number of entries, $N$), a quadratic speedup can provide a significant advantage. For a database with one million entries, a quantum computer running Grover’s algorithm would need about 1000 runs, while a classical computer would need, on average, $500$k runs.</p>
<p>Research has been shown that any optimal quantum solution to an unstructured search problem has a speed limit of $O(\sqrt{N})$ runtime. This research finding matches the performance of Grover’s algorithm, thus proving that the algorithm is asymptotically optimal [2]. In fact, Grover’s algorithm can be generalized to accelerate any type of search where one can construct a quantum oracle, as described in the next section.</p>
<p>Consider the following problem [2]:
In a search space with $N$ elements, we are searching the index of those elements, which is a number in the range $0, 1, \dots, N-1$.
We have $n$ bits at our disposal, with which we can store up to $2^{n}$ elements.
Our search problem can then be expressed with the help of a function $f$, which takes as input an element out of our set of indices (that is, an integer $x$) and generates two possible outputs: $f(x^{<em>})=1$, if $x^{</em>}$ is the solution to the search problem or $f(x)=0$ otherwise (if $N&lt;2^{n}$ we can just set $f(x)=0$ for all extra unused elements).
This is done with the help of a quantum oracle, which recognizes solutions to the search problem.</p>
</section>
<section id="background-what-is-a-quantum-oracle-a-name-background-a">
<h1>Background: What is a Quantum Oracle? <a name="background"></a><a class="headerlink" href="#background-what-is-a-quantum-oracle-a-name-background-a" title="Permalink to this heading">#</a></h1>
<p>Grover’s algorithm, like many other quantum algorithms, utilizes the concept of a quantum oracle which we will denote as $\mathcal{O}$.  In essence, an oracle $\mathcal{O}$ is a black-box operation that serves as a subroutine to another algorithm. Typically, oracles are defined using a classical function $f:{0,1}^{n} \rightarrow {0,1}^{m}$, that maps an $n$-input bitstring to an $m$-output bitstring. With $x \in {0,1}^{n}$, i.e., $x=(x_{0}, x_{1}, \dots, x_{n-1})$ is a bitstring vector, and $y \in {0,1}^{m}$, the oracle $\mathcal{O}$ is a unitary operator, commonly defined by its effect on an arbitrary computational basis state as:</p>
<p>$$\mathcal{O} (\left|x\right&gt; \otimes \left|y\right&gt;) = \left|x\right&gt; \otimes \left|y \oplus f(x)\right&gt;,$$ where $\oplus$ denotes addition modulo 2.</p>
<p>This means that the second qubit register of size $m$ stores the result of the computation.
For $m=1$, which is the scenario we will focus on here, the second register $\left|y\right&gt;$ is a single qubit that is flipped if (and only if) $f(x)=1$.
In short, the quantum oracle flips the ancilla qubit only if the function $f(x)$ evaluates to one.
Accordingly, we can check if $x$ is a solution to our search problem by first preparing the state $\left|x\right&gt; \otimes \left|0\right&gt;$, then applying the oracle $\mathcal{O}$ to that state, before finally measuring the state of the oracle qubit.</p>
<p>In Grover’s algorithm, it is useful to initialize the oracle qubit in a superposition, as $\left|y\right&gt; = (\left|0\right&gt; - \left|1\right&gt;)/\sqrt{2}$.
We can distinguish two cases:
(i) If $x$ is not a solution to our search problem (i.e., $f(x)=0$), then the application of the oracle operator $\mathcal{O}$ to the input state $\left|x\right&gt; \otimes (\left|0\right&gt; - \left|1\right&gt;)/\sqrt{2}$ leaves this state simply untouched.
(ii) Conversely, if $x$ is a solution to our search problem (i.e., $f(x)=1$), then the oracle states $\left|0\right&gt;$ and $\left|1\right&gt;$ are flipped, such that the state picks up a minus sign, giving the final output state $-\left|x\right&gt; \otimes (\left|0\right&gt; - \left|1\right&gt;)/\sqrt{2}$.
Note that global phase factors do not matter in quantum computing, but the relative minus sign we encounter here does make all the difference for a superposition state, which would include the solution among all other possible input states.</p>
<p>For both cases (i) and (ii), the action of the oracle can be summarized as:</p>
<p>$$\left|x\right&gt; \otimes (\left|0\right&gt; - \left|1\right&gt;)/\sqrt{2} \longrightarrow (-1)^{f(x)} \left|x\right&gt; \otimes (\left|0\right&gt; - \left|1\right&gt;)/\sqrt{2}.$$<br />
Accordingly, the solution to our search problem gets <em>marked</em> by shifting the corresponding phase.
Because the oracle qubit remains unchanged, one can omit this oracle qubit from further discussion and simply express the action of the oracle as:</p>
<p>$$\left|x\right&gt; \longrightarrow (-1)^{f(x)}\left|x\right&gt;.$$</p>
<p>This expression also captures the definition of a <em>phase oracle</em>, which will be used in our examples below.
If a phase oracle is applied on a computational basis state $\left|x\right&gt;$, then we only get a global phase that is not observable. However, when applied to a superposition of computational basis states, this phase oracle becomes a powerful tool. As it turns out, the search oracle needs to be applied only $O(\sqrt{N})$ times to obtain the solution with high probability [2]; more generally, if there are $G$ solutions, the oracle needs to be applied only $O(\sqrt{N/G})$ times).</p>
</section>
<section id="anatomy-of-grover-s-algorithm-a-name-steps-a">
<h1>Anatomy of Grover’s Algorithm <a name="steps"></a><a class="headerlink" href="#anatomy-of-grover-s-algorithm-a-name-steps-a" title="Permalink to this heading">#</a></h1>
<p>In this tutorial, we will be working with three bits $(n=3)$, leading to eight possible items $(N=2^{3}=8)$.
To find a given target item, Grover’s algorithm uses the following steps:</p>
<ol class="arabic simple">
<li><p><strong>Initialize</strong>: Start with a uniform superposition of all possible bit strings by applying Hadamard gates. This will result in all inputs having the same amplitude. Since we do not have any prior knowledge about the solution, we initialize to an equal superposition of all possible candidate solutions.</p></li>
<li><p><strong>Oracle</strong>: Item bits are then passed through an oracle. The oracle produces only two results. If it detects the target item, its amplitude will be flipped to negative. For all other items, their amplitudes will remain positive. Because the oracle is specifically engineered to change amplitudes based on a certain bit pattern, each target item would have its own associated oracle.</p></li>
<li><p><strong>Amplification</strong>: While the oracle in step 2 distinguishes the target item by flipping its amplitude in the negative direction, this difference remains too small to detect. Hence, we use a trick to magnify the difference in amplitudes; by flipping every amplitude around the mean amplitude. Recall that only the target item’s amplitude was flipped to negative. In other words, the mean amplitude would still be positive, and its value would only be slightly lower than the amplitudes of other items. By flipping all amplitudes about the mean, the amplitudes of non-target items would decrease only slightly. On the other hand, the amplitude of the target item, being much less than the mean value to start, would be reflected back up into the positive direction by a large margin.</p></li>
<li><p><strong>Repeat</strong>: By repeating steps 2 and 3, we can magnify the amplitude of the target item to a point where it can be identified with overwhelming probability. To get to this point, we need to repeat these steps approximately $\sqrt{N}$ times (again assuming a single solution and large $N$). As discussed in more detail in our Quantum Amplification Algorithm (QAA) tutorial, to ensure we measure a solution with high probability, we apply the Grover iterator $\left\lfloor\frac{\pi}{4\theta}\right\rfloor=\left\lfloor\frac{\pi}{4}\sqrt{\frac{N}{G}}\right\rfloor$ times, with $G$ denoting the number of solutions. Since we may not know $G$ in advance, we not know the ideal number of iterations a priori. To address this issue, however, we may use quantum counting techniques with the help of the phase estimation procedure (QPE); for details we refer to Ref.[2].</p></li>
<li><p><strong>Measurement</strong>: Measure the resulting amplitudes to identify the target item.</p></li>
</ol>
<div align="center"><img src="anatomy.png"/></div></section>
<section id="circuit-diagram-a-name-diagram-a">
<h1>Circuit Diagram <a name="diagram"></a><a class="headerlink" href="#circuit-diagram-a-name-diagram-a" title="Permalink to this heading">#</a></h1>
<p>Following Ref.[1], we will examine Grover’s search algorithm for $n=3$ qubits, which corresponds to a search database of size $N = 2^{3} = 8$. Below we show the circuit used to find the item <code class="docutils literal notranslate"><span class="pre">111</span></code>.  To find other items, we can simply swap out the phase oracle, using the table given in Ref.[1].</p>
<div align="center"><img src="circuit.png"/></div></section>
<section id="code-a-name-code-a">
<h1>Code <a name="code"></a><a class="headerlink" href="#code-a-name-code-a" title="Permalink to this heading">#</a></h1>
<section id="libraries-and-parameters-a-name-setup-a">
<h2>Libraries and Parameters <a name="setup"></a><a class="headerlink" href="#libraries-and-parameters-a-name-setup-a" title="Permalink to this heading">#</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check SDK version</span>
<span class="o">!</span>pip show amazon-braket-sdk <span class="p">|</span> grep Version
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Version: 1.0.0.post1
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Import Braket libraries</span>
<span class="kn">from</span> <span class="nn">braket.circuits</span> <span class="kn">import</span> <span class="n">circuit</span><span class="p">,</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">Gate</span><span class="p">,</span> <span class="n">Moments</span>
<span class="kn">from</span> <span class="nn">braket.circuits.instruction</span> <span class="kn">import</span> <span class="n">Instruction</span>
<span class="kn">from</span> <span class="nn">braket.aws</span> <span class="kn">import</span> <span class="n">AwsQuantumTask</span><span class="p">,</span> <span class="n">AwsDevice</span>
<span class="kn">from</span> <span class="nn">braket.devices</span> <span class="kn">import</span> <span class="n">LocalSimulator</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="c1"># magic word for producing visualizations in notebook</span>
<span class="o">%</span><span class="k">matplotlib</span> inline
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="helper-functions-a-name-wrappers-a">
<h2>Helper Functions <a name="wrappers"></a><a class="headerlink" href="#helper-functions-a-name-wrappers-a" title="Permalink to this heading">#</a></h2>
<p>We develop a set of useful helper functions that we will explain in detail below. Specifically, we provide simple building blocks for the four core modules of Grover’s search algorithm: 1) initialization, 2) oracle, 3) amplification, and 4) measurement. This approach allows us to solve the problem in a clean and modular way.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Helper function to build C-C-Z gate</span>
<span class="nd">@circuit</span><span class="o">.</span><span class="n">subroutine</span><span class="p">(</span><span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ccz</span><span class="p">(</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    implementation of three-qubit gate CCZ</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># define three-qubit CCZ gate</span>
    <span class="n">ccz_gate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                         <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                         <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                         <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                         <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                         <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                         <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                         <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">]],</span>
                       <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    
    <span class="c1"># instantiate circuit object</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
    
    <span class="c1"># add CCZ gate</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">unitary</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">ccz_gate</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="n">targets</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">circ</span>


<span class="c1"># All possible items and their corresponding oracles</span>
<span class="c1"># define oracle dictionary using this CCZ gate</span>
<span class="n">oracle_sim</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;000&quot;</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">ccz</span><span class="p">(</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span>
              <span class="s2">&quot;001&quot;</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">ccz</span><span class="p">(</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span>
              <span class="s2">&quot;010&quot;</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">ccz</span><span class="p">(</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span>
              <span class="s2">&quot;011&quot;</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">ccz</span><span class="p">(</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span>
              <span class="s2">&quot;100&quot;</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">ccz</span><span class="p">(</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span>
              <span class="s2">&quot;101&quot;</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">ccz</span><span class="p">(</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span>
              <span class="s2">&quot;110&quot;</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">ccz</span><span class="p">(</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">2</span><span class="p">]),</span>
              <span class="s2">&quot;111&quot;</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">ccz</span><span class="p">(</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
          <span class="p">}</span>


<span class="c1"># helper function for initialization</span>
<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">n_qubits</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function to apply hadamard to all qubits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize with superposition</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">();</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">))</span>
    <span class="c1">#print(circ)</span>
    <span class="k">return</span> <span class="n">circ</span>


<span class="c1"># helper function for phase oracle</span>
<span class="k">def</span> <span class="nf">oracle</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function to apply oracle for given target item</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># instantiate circuit object</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
    
    <span class="c1"># add oracle</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">add_circuit</span><span class="p">(</span><span class="n">oracle_sim</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">circ</span>


<span class="c1"># helper function for amplification</span>
<span class="k">def</span> <span class="nf">amplify</span><span class="p">(</span><span class="n">n_qubits</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function for amplitude amplification</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># instantiate circuit object</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
    
    <span class="c1"># Amplification</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">))</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">add_circuit</span><span class="p">(</span><span class="n">oracle_sim</span><span class="p">[</span><span class="s1">&#39;000&#39;</span><span class="p">])</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_qubits</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">circ</span>


<span class="c1"># helper function for grover algorithm</span>
<span class="k">def</span> <span class="nf">grover</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">n_qubits</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">n_reps</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    function to put together individual modules of Grover algorithm</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># initialize</span>
    <span class="n">grover_circ</span> <span class="o">=</span> <span class="n">initialize</span><span class="p">()</span>
    <span class="c1"># oracle and amplify</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_reps</span><span class="p">):</span>
        <span class="c1"># get oracle</span>
        <span class="n">or_circ</span> <span class="o">=</span> <span class="n">oracle</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">grover_circ</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">or_circ</span><span class="p">)</span>
        <span class="c1"># amplify</span>
        <span class="n">amplification</span> <span class="o">=</span> <span class="n">amplify</span><span class="p">()</span>
        <span class="n">grover_circ</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">amplification</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">grover_circ</span>
        
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Function to run quantum task, check the status thereof, and collect results</span>
<span class="k">def</span> <span class="nf">get_result</span><span class="p">(</span><span class="n">circ</span><span class="p">):</span>
    
    <span class="c1"># get number of qubits</span>
    <span class="n">num_qubits</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">qubit_count</span>

    <span class="c1"># specify desired results_types</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">probability</span><span class="p">()</span>

    <span class="c1"># submit task: define task (asynchronous)</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

    <span class="c1"># Get ID of submitted task</span>
    <span class="n">task_id</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">id</span>
<span class="c1">#     print(&#39;Task ID :&#39;, task_id)</span>

    <span class="c1"># Wait for job to complete</span>
    <span class="n">status_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">state</span><span class="p">()</span>
    <span class="n">status_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">status</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Status:&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>

    <span class="c1"># Only notify the user when there&#39;s a status change</span>
    <span class="k">while</span> <span class="n">status</span> <span class="o">!=</span> <span class="s1">&#39;COMPLETED&#39;</span><span class="p">:</span>
        <span class="n">status</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">state</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">status</span> <span class="o">!=</span> <span class="n">status_list</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Status:&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
        <span class="n">status_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">status</span><span class="p">]</span>

    <span class="c1"># get result</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

    <span class="c1"># get metadata</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">task_metadata</span>

    <span class="c1"># get output probabilities</span>
    <span class="n">probs_values</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># get measurement results</span>
    <span class="n">measurement_counts</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">measurement_counts</span>

    <span class="c1"># print measurement results</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;measurement_counts:&#39;</span><span class="p">,</span> <span class="n">measurement_counts</span><span class="p">)</span>

    <span class="c1"># bitstrings</span>
    <span class="n">format_bitstring</span> <span class="o">=</span> <span class="s1">&#39;{0:0&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;b}&#39;</span>
    <span class="n">bitstring_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">format_bitstring</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">num_qubits</span><span class="p">)]</span>

    <span class="c1"># plot probabalities</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">bitstring_keys</span><span class="p">,</span> <span class="n">probs_values</span><span class="p">);</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;bitstrings&#39;</span><span class="p">);</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">);</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="n">measurement_counts</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="device-classical-simulator-a-name-sim-c-a">
<h2>Device: Classical Simulator <a name="sim_c"></a><a class="headerlink" href="#device-classical-simulator-a-name-sim-c-a" title="Permalink to this heading">#</a></h2>
<p>We demonstrate Grover’s algorithm on a classical simulator first.
You can choose between a local simulator or an on-demand simulator.
In the next section, we will run the same problem on a quantum IonQ device.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up the cloud-based simulator </span>
<span class="c1"># device = AwsDevice(&quot;arn:aws:braket:::device/quantum-simulator/amazon/sv1&quot;)</span>

<span class="c1"># set up the local simulator</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">LocalSimulator</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># get device name</span>
<span class="n">device_name</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">name</span>
<span class="c1"># show the properties of the device </span>
<span class="n">device_properties</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">properties</span>
<span class="c1"># show supportedQuantumOperations (supported gates for a device)</span>
<span class="n">device_operations</span> <span class="o">=</span> <span class="n">device_properties</span><span class="o">.</span><span class="n">dict</span><span class="p">()[</span><span class="s1">&#39;action&#39;</span><span class="p">][</span><span class="s1">&#39;braket.ir.jaqcd.program&#39;</span><span class="p">][</span><span class="s1">&#39;supportedOperations&#39;</span><span class="p">]</span>
<span class="c1"># Note: This field also exists for other devices like the QPUs</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Quantum Gates supported by </span><span class="si">{}</span><span class="s1">:</span><span class="se">\n</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">device_name</span><span class="p">,</span> <span class="n">device_operations</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Quantum Gates supported by StateVectorSimulator:
[&#39;ccnot&#39;, &#39;cnot&#39;, &#39;cphaseshift&#39;, &#39;cphaseshift00&#39;, &#39;cphaseshift01&#39;, &#39;cphaseshift10&#39;, &#39;cswap&#39;, &#39;cv&#39;, &#39;cy&#39;, &#39;cz&#39;, &#39;ecr&#39;, &#39;h&#39;, &#39;i&#39;, &#39;iswap&#39;, &#39;pswap&#39;, &#39;phaseshift&#39;, &#39;rx&#39;, &#39;ry&#39;, &#39;rz&#39;, &#39;s&#39;, &#39;si&#39;, &#39;swap&#39;, &#39;t&#39;, &#39;ti&#39;, &#39;unitary&#39;, &#39;v&#39;, &#39;vi&#39;, &#39;x&#39;, &#39;xx&#39;, &#39;xy&#39;, &#39;y&#39;, &#39;yy&#39;, &#39;z&#39;, &#39;zz&#39;]
</pre></div>
</div>
</div>
</div>
<p>Since the <code class="docutils literal notranslate"><span class="pre">CCZ</span></code> gate is not part of the default gate set, we have used the <code class="docutils literal notranslate"><span class="pre">unitary</span></code> method to build a custom, doubly-controlled Z gate <code class="docutils literal notranslate"><span class="pre">CCZ</span></code> for the phase oracle operator.
We will leverage the Amazon Braket <code class="docutils literal notranslate"><span class="pre">circuit.subroutine</span></code> functionality, which allows us to use such a custom-built gate as if it were any other built-in gate.</p>
<p>Now, we are ready to run our circuit for a few test cases.
To recap, the steps are as follows:</p>
<ol class="arabic simple">
<li><p>Create a uniform superposition</p></li>
<li><p>Apply the phase oracle corresponding to our target item</p></li>
<li><p>Define the diffusion operator to magnify the amplitude difference created by the oracle</p></li>
<li><p>Collect the measurement counts for our target item</p></li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Select item to find. Let&#39;s start with &#39;111&#39; for now</span>
<span class="n">item</span> <span class="o">=</span> <span class="s2">&quot;111&quot;</span>

<span class="c1"># get Grover circuit</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">grover</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

<span class="c1"># print circuit</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>

<span class="c1"># Measurement</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">get_result</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>T  : |0|1|2|3|4|5|6|
                    
q0 : -H-U-H-X-U-X-H-
        |     |     
q1 : -H-U-H-X-U-X-H-
        |     |     
q2 : -H-U-H-X-U-X-H-

T  : |0|1|2|3|4|5|6|
Status: COMPLETED
measurement_counts: Counter({&#39;111&#39;: 776, &#39;000&#39;: 39, &#39;010&#39;: 35, &#39;011&#39;: 33, &#39;001&#39;: 33, &#39;100&#39;: 31, &#39;101&#39;: 28, &#39;110&#39;: 25})
</pre></div>
</div>
<img alt="../../../_images/bfef6bca2e1775a5375604417d77a6ed6cb4944745fbd6978f20f85c362beee2.png" src="../../../_images/bfef6bca2e1775a5375604417d77a6ed6cb4944745fbd6978f20f85c362beee2.png" />
</div>
</div>
<p><strong>DISCUSSION</strong>: We observe a strong peak around the target solution given by the <code class="docutils literal notranslate"><span class="pre">111</span></code> bitstring, with all other bitstrings showing far smaller probabilities.
Let us try one more item:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Select item to find. Let&#39;s start with &#39;111&#39; for now</span>
<span class="n">item</span> <span class="o">=</span> <span class="s2">&quot;100&quot;</span>

<span class="c1"># get Grover circuit</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">grover</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

<span class="c1"># print circuit</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>

<span class="c1"># Measurement</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">get_result</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>T  : |0|1|2|3|4|5|6|7|8|
                        
q0 : -H---U-H-X---U-X-H-
          |       |     
q1 : -H-X-U-X-H-X-U-X-H-
          |       |     
q2 : -H-X-U-X-H-X-U-X-H-

T  : |0|1|2|3|4|5|6|7|8|
Status: COMPLETED
measurement_counts: Counter({&#39;100&#39;: 792, &#39;111&#39;: 34, &#39;011&#39;: 32, &#39;010&#39;: 32, &#39;001&#39;: 30, &#39;110&#39;: 28, &#39;000&#39;: 26, &#39;101&#39;: 26})
</pre></div>
</div>
<img alt="../../../_images/7411648c74dad324fb99a5e1b333a74a5468d602d94705bb90939ffbbd9b87e9.png" src="../../../_images/7411648c74dad324fb99a5e1b333a74a5468d602d94705bb90939ffbbd9b87e9.png" />
</div>
</div>
<p><strong>DISCUSSION</strong>: By repeating steps 2 (oracle) and 3 (amplification), we can further magnify the amplitude of the target item, thus maximizing the single-shot probability of identifying the right answer. This repetition is demonstrated below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Select item to find</span>
<span class="n">item</span> <span class="o">=</span> <span class="s2">&quot;100&quot;</span>

<span class="c1"># get Grover circuit</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">grover</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">n_reps</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># print circuit</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>

<span class="c1"># Measurement</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">get_result</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>T  : |0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|
                                               
q0 : -H---U-H-X---U-X-H---U--H--X-----U--X--H--
          |       |       |           |        
q1 : -H-X-U-X-H-X-U-X-H-X-U--X--H--X--U--X--H--
          |       |       |           |        
q2 : -H-X-U-X-H-X-U-X-H-X-U--X--H--X--U--X--H--

T  : |0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|
Status: COMPLETED
measurement_counts: Counter({&#39;100&#39;: 941, &#39;011&#39;: 13, &#39;010&#39;: 10, &#39;000&#39;: 10, &#39;111&#39;: 7, &#39;101&#39;: 7, &#39;110&#39;: 7, &#39;001&#39;: 5})
</pre></div>
</div>
<img alt="../../../_images/c7278c3979539210aeee6505a87d04be20950c097e0a25830a61e2f54d04f00e.png" src="../../../_images/c7278c3979539210aeee6505a87d04be20950c097e0a25830a61e2f54d04f00e.png" />
</div>
</div>
<p><strong>DISCUSSION</strong>: We observed how repeated application of the Grover operator has amplified the occurrence of the desired bitstring, while further suppressing wrong answers to our search problem. We get the correct result with high probability.</p>
</section>
<section id="device-ionq-a-name-ionq-a">
<h2>Device: IonQ <a name="ionq"></a><a class="headerlink" href="#device-ionq-a-name-ionq-a" title="Permalink to this heading">#</a></h2>
<p>Finally, we check whether this scheme works on quantum hardware, by submitting our circuit to the IonQ device. To achieve this check, we first need to express the <code class="docutils literal notranslate"><span class="pre">CCZ</span></code> gate in terms of the native gate set of IonQ. In doing so, we build a custom gate that can be registered as a subroutine and then used as if it were any other native quantum gate within our SDK.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up a QPU device</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">AwsDevice</span><span class="p">(</span><span class="s2">&quot;arn:aws:braket:::device/qpu/ionq/ionQdevice&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># get device name</span>
<span class="n">device_name</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">name</span>
<span class="c1"># show the properties of the device </span>
<span class="n">device_properties</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">properties</span>
<span class="c1"># show supportedQuantumOperations (supported gates for a device)</span>
<span class="n">device_operations</span> <span class="o">=</span> <span class="n">device_properties</span><span class="o">.</span><span class="n">dict</span><span class="p">()[</span><span class="s1">&#39;action&#39;</span><span class="p">][</span><span class="s1">&#39;braket.ir.jaqcd.program&#39;</span><span class="p">][</span><span class="s1">&#39;supportedOperations&#39;</span><span class="p">]</span>
<span class="c1"># Note: This field also exists for other devices like the QPUs</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Quantum Gates supported by </span><span class="si">{}</span><span class="s1">:</span><span class="se">\n</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">device_name</span><span class="p">,</span> <span class="n">device_operations</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Quantum Gates supported by IonQ Device:
 [&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;rx&#39;, &#39;ry&#39;, &#39;rz&#39;, &#39;h&#39;, &#39;cnot&#39;, &#39;s&#39;, &#39;si&#39;, &#39;t&#39;, &#39;ti&#39;, &#39;v&#39;, &#39;vi&#39;, &#39;xx&#39;, &#39;yy&#39;, &#39;zz&#39;, &#39;swap&#39;, &#39;i&#39;]
</pre></div>
</div>
</div>
</div>
<p>For the 𝑁=8 Grover demonstration with three qubits shown in Figgatt et al. (2017), we need to implement the Controlled-Controlled-Z <code class="docutils literal notranslate"><span class="pre">CCZ</span></code> gate that is not natively provided on the IonQ device. We will construct this gate using native gates only such as <code class="docutils literal notranslate"><span class="pre">CNOT</span></code> and <code class="docutils literal notranslate"><span class="pre">T</span></code>. Apart from our implementation, other alternative options are available (see [1] and references therein).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@circuit</span><span class="o">.</span><span class="n">subroutine</span><span class="p">(</span><span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">CCNot</span><span class="p">(</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">target</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    build CCNOT from H, CNOT, T, Ti</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cQb1</span><span class="p">,</span> <span class="n">cQb2</span> <span class="o">=</span> <span class="n">controls</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="n">cQb2</span><span class="p">,</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">ti</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="n">cQb1</span><span class="p">,</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="n">cQb2</span><span class="p">,</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">ti</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="n">cQb1</span><span class="p">,</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">cQb2</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="n">cQb1</span><span class="p">,</span><span class="n">cQb2</span><span class="p">)</span><span class="o">.</span><span class="n">t</span><span class="p">(</span><span class="n">cQb1</span><span class="p">)</span><span class="o">.</span><span class="n">ti</span><span class="p">(</span><span class="n">cQb2</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="n">cQb1</span><span class="p">,</span><span class="n">cQb2</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">circ</span> 

<span class="k">def</span> <span class="nf">CCZ_ionq</span><span class="p">(</span><span class="n">controls</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">target</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    build CCZ from H and CCNOT</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">CCNot</span><span class="p">(</span><span class="n">controls</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">circ</span>

<span class="n">ccz_ionq</span> <span class="o">=</span> <span class="n">CCZ_ionq</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Following are oracles defined based on target items:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Four possible items and their corresponding oracles</span>
<span class="n">oracle_ionq</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;000&quot;</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ccz_ionq</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span>
               <span class="s2">&quot;001&quot;</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ccz_ionq</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span>
               <span class="s2">&quot;010&quot;</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ccz_ionq</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span>
               <span class="s2">&quot;011&quot;</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ccz_ionq</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">0</span><span class="p">]),</span>
               <span class="s2">&quot;100&quot;</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ccz_ionq</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]),</span>
               <span class="s2">&quot;101&quot;</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ccz_ionq</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">1</span><span class="p">]),</span>
               <span class="s2">&quot;110&quot;</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ccz_ionq</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">([</span><span class="mi">2</span><span class="p">]),</span>
               <span class="s2">&quot;111&quot;</span><span class="p">:</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ccz_ionq</span><span class="p">)</span>
          <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Select some example item to find</span>
<span class="n">item</span> <span class="o">=</span> <span class="s2">&quot;111&quot;</span>
</pre></div>
</div>
</div>
</div>
<p>Same as with the classical simulator, we first initialize the qubits by applying the Hadamard gate <code class="docutils literal notranslate"><span class="pre">H</span></code> to every qubit.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Initialize with superposition</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">();</span>
<span class="n">circ</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>T  : |0|
        
q0 : -H-
        
q1 : -H-
        
q2 : -H-

T  : |0|
</pre></div>
</div>
</div>
</div>
<p>Next, we apply the phase oracle corresponding to our target item.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Construct phase oracle</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_circuit</span><span class="p">(</span><span class="n">oracle_ionq</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>T  : |0|1|2|3|4 |5|6|7|8 |9|10|11|12|
                                     
q0 : -H----------C--------C-C--T--C--
                 |        | |     |  
q1 : -H-----C----|---C-T--|-X--Ti-X--
            |    |   |    |          
q2 : -H-H-H-X-Ti-X-T-X-Ti-X-T--H--H--

T  : |0|1|2|3|4 |5|6|7|8 |9|10|11|12|
</pre></div>
</div>
</div>
</div>
<p>To complete the circuit, we define the diffusion operator, whose job is to magnify the amplitude difference created by the oracle.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Amplification</span>
<span class="n">circ</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="n">circ</span><span class="o">.</span><span class="n">add_circuit</span><span class="p">(</span><span class="n">oracle_ionq</span><span class="p">[</span><span class="s1">&#39;000&#39;</span><span class="p">])</span>
<span class="n">circ</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>T  : |0|1|2|3|4 |5|6|7|8 |9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|
                                                                                     
q0 : -H----------C--------C-C--T--C--H--X--------------C-----------C--C--T--C--X--H--
                 |        | |     |                    |           |  |     |        
q1 : -H-----C----|---C-T--|-X--Ti-X--H--X--------C-----|-----C--T--|--X--Ti-X--X--H--
            |    |   |    |                      |     |     |     |                 
q2 : -H-H-H-X-Ti-X-T-X-Ti-X-T--H--H--H--X--H--H--X--Ti-X--T--X--Ti-X--T--H--H--X--H--

T  : |0|1|2|3|4 |5|6|7|8 |9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|
</pre></div>
</div>
</div>
</div>
<p>This circuit could potentially be optimized, as detailed in Ref.[1], but we will use this version for simplicity.</p>
<p>In the final step, we retrieve the probabilistic counts for our target item.
To this end, we submit our circuit to the IonQ device, by setting the device as <code class="docutils literal notranslate"><span class="pre">AwsDevice(&quot;arn:aws:braket:::device/qpu/ionq/ionQdevice&quot;)</span></code>.</p>
<p>This task may not be executed immediately as it enters a queue for this machine.
Should we need to interrupt our kernel to work on something else, we can always recover our results using the unique ID of this task, as shown in the following lines.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># set up device</span>
<span class="n">ionq</span> <span class="o">=</span> <span class="n">AwsDevice</span><span class="p">(</span><span class="s2">&quot;arn:aws:braket:::device/qpu/ionq/ionQdevice&quot;</span><span class="p">)</span>

<span class="c1"># run circuit </span>
<span class="n">ionq_task</span> <span class="o">=</span> <span class="n">ionq</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="c1"># get id and status of submitted task</span>
<span class="n">ionq_task_id</span> <span class="o">=</span> <span class="n">ionq_task</span><span class="o">.</span><span class="n">id</span>
<span class="n">ionq_status</span> <span class="o">=</span> <span class="n">ionq_task</span><span class="o">.</span><span class="n">state</span><span class="p">()</span>
<span class="c1"># print(&#39;ID of task:&#39;, ionq_task_id)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Status of task:&#39;</span><span class="p">,</span> <span class="n">ionq_status</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Status of task: CREATED
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># print status</span>
<span class="n">status</span> <span class="o">=</span> <span class="n">ionq_task</span><span class="o">.</span><span class="n">state</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Status of (reconstructed) task:&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Status of (reconstructed) task: QUEUED
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># print status</span>
<span class="n">status</span> <span class="o">=</span> <span class="n">ionq_task</span><span class="o">.</span><span class="n">state</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Status of (reconstructed) task:&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Status of (reconstructed) task: COMPLETED
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># recover task</span>
<span class="n">task_load</span> <span class="o">=</span> <span class="n">AwsQuantumTask</span><span class="p">(</span><span class="n">arn</span><span class="o">=</span><span class="n">ionq_task_id</span><span class="p">)</span>

<span class="c1"># print status</span>
<span class="n">status</span> <span class="o">=</span> <span class="n">task_load</span><span class="o">.</span><span class="n">state</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Status of (reconstructed) task:&#39;</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>

<span class="c1"># wait for job to complete</span>
<span class="c1"># terminal_states = [&#39;COMPLETED&#39;, &#39;FAILED&#39;, &#39;CANCELLED&#39;]</span>
<span class="k">if</span> <span class="n">status</span> <span class="o">==</span> <span class="s1">&#39;COMPLETED&#39;</span><span class="p">:</span>
    <span class="c1"># get results</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">task_load</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
    
    <span class="c1"># get all metadata of submitted task</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="n">task_load</span><span class="o">.</span><span class="n">metadata</span><span class="p">()</span>
    <span class="c1"># example for metadata</span>
    <span class="n">shots</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;shots&#39;</span><span class="p">]</span>
    <span class="n">machine</span> <span class="o">=</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;deviceArn&#39;</span><span class="p">]</span>
    <span class="c1"># print example metadata</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> shots taken on machine </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">shots</span><span class="p">,</span> <span class="n">machine</span><span class="p">))</span>
    
    <span class="c1"># get measurement counts</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">measurement_counts</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Measurement counts:&#39;</span><span class="p">,</span> <span class="n">counts</span><span class="p">)</span>

    <span class="c1"># plot results: see effects of noise</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">counts</span><span class="o">.</span><span class="n">values</span><span class="p">());</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;bitstrings&#39;</span><span class="p">);</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;counts&#39;</span><span class="p">);</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">();</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;ionq.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">700</span><span class="p">);</span>
    
<span class="k">elif</span> <span class="n">status</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;FAILED&#39;</span><span class="p">,</span> <span class="s1">&#39;CANCELLED&#39;</span><span class="p">]:</span>
    <span class="c1"># print terminal message </span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Your task is in terminal status, but has not completed.&#39;</span><span class="p">)</span>

<span class="k">else</span><span class="p">:</span>
    <span class="c1"># print current status</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sorry, your task is still being processed and has not been finalized yet.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Status of (reconstructed) task: COMPLETED
1000 shots taken on machine arn:aws:braket:::device/qpu/ionq/ionQdevice.
Measurement counts: Counter({&#39;111&#39;: 354, &#39;011&#39;: 166, &#39;010&#39;: 103, &#39;001&#39;: 93, &#39;110&#39;: 87, &#39;100&#39;: 72, &#39;101&#39;: 69, &#39;000&#39;: 56})
</pre></div>
</div>
<img alt="../../../_images/0df61728720fde83b1005eb5cb459a4d64a48287b35276118982c535594c779f.png" src="../../../_images/0df61728720fde83b1005eb5cb459a4d64a48287b35276118982c535594c779f.png" />
</div>
</div>
<p>The output looks relatively noisy due to decoherence and gate errors in this relatively long gate sequence. However, we can still observe a dominant peak for the target item.</p>
<p>In summary, we have shown how to implement Grover’s search algorithm on a classical simulator, as well as on the IonQ device, using simple modular building blocks. We have also demonstrated how to build custom gates outside of the basic gate set provided by the SDK, and how to register these as subroutines that can be used as if they were any other pre-defined quantum gate.</p>
</section>
</section>
<hr class="docutils" />
<section id="references-a-name-ref-a">
<h1>References <a name="ref"></a><a class="headerlink" href="#references-a-name-ref-a" title="Permalink to this heading">#</a></h1>
<p>[1] C. Figgatt, D. Maslov, K. A. Landsman, N. M. Linke, S. Debnath &amp; C. Monroe (2017), “Complete 3-Qubit Grover search on a programmable quantum computer”, Nature Communications, Vol 8, Art 1918, doi:10.1038/s41467-017-01904-7, arXiv:1703.10535.</p>
<p>[2] Nielsen, Michael A., Chuang, Isaac L. (2010). Quantum Computation and Quantum Information (2nd ed.). Cambridge: Cambridge University Press.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Task Summary&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">quantum_tasks_statistics</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Note: Charges shown are estimates based on your Amazon Braket simulator and quantum processing unit (QPU) task usage. Estimated charges shown may differ from your actual charges. Estimated charges do not factor in any discounts or credits, and you may experience additional charges based on your use of other services such as Amazon Elastic Compute Cloud (Amazon EC2).&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Estimated cost to run this example: </span><span class="si">{</span><span class="n">t</span><span class="o">.</span><span class="n">qpu_tasks_cost</span><span class="p">()</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">simulator_tasks_cost</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> USD&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Task Summary
{&#39;arn:aws:braket:::device/qpu/ionq/ionQdevice&#39;: {&#39;shots&#39;: 1000, &#39;tasks&#39;: {&#39;QUEUED&#39;: 1}}}
Note: Charges shown are estimates based on your Amazon Braket simulator and quantum processing unit (QPU) task usage. Estimated charges shown may differ from your actual charges. Estimated charges do not factor in any discounts or credits, and you may experience additional charges based on your use of other services such as Amazon Elastic Compute Cloud (Amazon EC2).
Estimated cost to run this example: 10.31 USD
</pre></div>
</div>
</div>
</div>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer no-toc">
      
      
      
    </aside>
  </div>
</div><script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    </body>
</html>