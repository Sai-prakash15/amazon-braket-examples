<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <!-- Generated with Sphinx 5.3.0 and Furo 2022.12.07 -->
        <title>QUANTUM FOURIER TRANSFORM - Amazon Braket Examples documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=91d0f0d1c444bdcb17a68e833c7a53903343c195" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">Amazon Braket Examples  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  
  <span class="sidebar-brand-text">Amazon Braket Examples  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  
</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="quantum-fourier-transform">
<h1>QUANTUM FOURIER TRANSFORM<a class="headerlink" href="#quantum-fourier-transform" title="Permalink to this heading">#</a></h1>
<p>In this tutorial, we provide a detailed implementation of the Quantum Fourier Transform (QFT) and the inverse thereof, using Amazon Braket’s SDK.
We provide two different implementations, with and without recursion.
The QFT is an important subroutine to many quantum algorithms, most famously Shor’s algorithm for factoring and the quantum phase estimation (QPE) algorithm for estimating the eigenvalues of a unitary operator [1, 2].
The QFT can be performed efficiently on a quantum computer, using only ${\displaystyle O(n^{2})}$ single-qubit Hadamard gates and two-qubit controlled phase shift gates, where ${\displaystyle n}$ is the number of qubits.
We first review the basics of the quantum Fourier transform, and its relation to the discrete (classical) Fourier transform.
We then implement the QFT in code two ways: recursively and non-recursively.
This notebook also showcases Braket’s <code class="docutils literal notranslate"><span class="pre">circuit.subroutine</span></code> functionality, which allows one to define custom methods and add them to the Circuit class.</p>
<section id="technical-background-of-qft">
<h2>TECHNICAL BACKGROUND OF QFT<a class="headerlink" href="#technical-background-of-qft" title="Permalink to this heading">#</a></h2>
<p><strong>Introduction</strong>: The Quantum Fourier Transform (QFT) is a quantum algorithm for applying the discrete Fourier transform to the amplitudes of a quantum state.  The QFT is therefore a quantum analog of the classical discrete Fourier transform [1, 2].</p>
<p>Let us first review the classical discrete Fourier transform (DFT).
Given a vector $(x_0,\ldots,x_{N-1})\in\mathbb{C}^N$, the discrete Fourier transform computes the vector $(y_0,\ldots,y_{N-1})$ for which
$$ y_j = \frac{1}{\sqrt{N}}\sum_{k=0}^{N-1} x_k e^{\frac{2\pi i}{N}jk}.$$</p>
<p><strong>Quantum Fourier Transformation</strong>: In close analogy to the classical Fourier transform, the QFT takes an arbitrary input state $\left|\mathrm{input}\right&gt; = \sum x_{j}\left|j\right&gt;$ (with the orthonormal basis states $\left|0\right&gt;$, $\left|1\right&gt;$, …, $\left|N-1\right&gt;$), and maps it to the output state
$$\left|\mathrm{output}\right&gt; = \sum_{k} y_{k}\left|k\right&gt;,$$
with coefficients
$$y_{k}=\frac{1}{\sqrt{N}}\sum_{n}x_{n}e^{2\pi i\cdot n\cdot k/N}.$$</p>
<p><strong>Binary representation (notation)</strong>: We take $N=2^{n}$, with $n$ being the number of qubits. In the binary representation, the states ${\left|x\right&gt;}$ read explicitly</p>
<p>$$\left|x\right&gt; = \left|x_{1}x_{2}\dots x_{n}\right&gt;,$$
where
$$x = x_{1}2^{n-1}+x_{2}2^{n-2}+\dots+x_{n}2^{0}.$$</p>
<p>For example, in a four-qubit system $\left|7\right&gt; = \left|0111\right&gt;$ and $\left|8\right&gt; = \left|1000\right&gt;$.
Similarly, we use the following notation to represent binary fractions:</p>
<p>$$[0.x_{l}x_{l+1}\dots x_{m}] = \frac{x_{l}}{2^{1}} + \frac{x_{l+1}}{2^{2}} + \frac{x_{m}}{2^{m-l+1}}.$$</p>
<p><strong>Product representation of QFT</strong>: Very often, the product representation of the QFT proves useful. Accordingly, the QFT can be expressed (up to normalization) as
$$\left|x_{1}x_{2}\dots x_{n}\right&gt; \longrightarrow \frac{(\left|0\right&gt;+e^{2\pi i[0.x_{n}]}\left|1\right&gt;)\otimes (\left|0\right&gt;+e^{2\pi i[0.x_{n-1}x_{n}]}\left|1\right&gt;)\otimes \dots \otimes (\left|0\right&gt;+e^{2\pi i[0.x_{1}x_{2}\dots x_{n}]}\left|1\right&gt;)}{2^{n/2}}.$$
For example, the QFT on three qubits can be written as</p>
<p>$$\mathrm{QFT}\left|x_{1}x_{2}x_{3}\right&gt; = \frac{1}{2^{3/2}}\left(\left|0\right&gt;+e^{2\pi i[0.x_{3}]}\left|1\right&gt;\right) \otimes \left(\left|0\right&gt;+e^{2\pi i[0.x_{2}x_{3}]}\left|1\right&gt;\right) \otimes \left(\left|0\right&gt;+e^{2\pi i[0.x_{1}x_{2}x_{3}]}\left|1\right&gt;\right).$$</p>
<p>Thus, for the simple input state $\left|0,0,0\right&gt;$ with $x_{i}=0$, it is easy to see that the QFT produces a uniform superposition of all computational basis vectors (since only the Hadamard gates act non-trivially in this case).  Explicitly:
$$
\begin{split}
\mathrm{QFT}\left|0,0,0\right&gt; &amp; = \frac{1}{\sqrt{2^{3}}}(\left|0\right&gt;+\left|1\right&gt;) \otimes (\left|0\right&gt;+\left|1\right&gt;) \otimes (\left|0\right&gt;+\left|1\right&gt;) \
&amp; = \frac{1}{\sqrt{2^{3}}} \bigotimes_{i} \left|+\right&gt;_{i}
\end{split}
$$</p>
<p><strong>Inverse QFT</strong>: Below we will also implement the inverse QFT algorithm (denoted by $\mathrm{QFT}^{\dagger}$, or sometimes $\mathrm{QFT}^{-1}$), which fulfills $\mathrm{QFT}\cdot\mathrm{QFT}^{\dagger}=\mathbb{1}$, where $\mathbb{1}$ is the identity. For example, with the inverse QFT we can invert the above three qubit QFT as</p>
<p>$$\mathrm{QFT}^\dagger\mathrm{QFT}\left|x_{1}x_{2}x_{3}\right&gt; = \mathrm{QFT}^{\dagger}(\left|0\right&gt;+e^{2\pi i[0.x_{3}]}\left|1\right&gt;) \otimes (\left|0\right&gt;+e^{2\pi i[0.x_{2}x_{3}]}\left|1\right&gt;) \otimes (\left|0\right&gt;+e^{2\pi i[0.x_{1}x_{2}x_{3}]}\left|1\right&gt;)/2^{3/2}=\left|x_{1}x_{2}x_{3}\right&gt;.$$</p>
<p><strong>Example for inverse QFT:</strong> For further illustration, we will run a concrete example of this kind below.
Specifically, consider the following example with $x_{1}=0$, $x_{2}=1$, and $x_{3}=0$ encoding the number 2 in binary representation.
Accordingly, we prepare the initial state (up to normalization)</p>
<p>$$\left|\Psi_\mathrm{in}\right&gt;=(\left|0\right&gt;+e^{2\pi i[0.0]}\left|1\right&gt;) \otimes (\left|0\right&gt;+e^{2\pi i[0.10]}\left|1\right&gt;) \otimes (\left|0\right&gt;+e^{2\pi i[0.010]}\left|1\right&gt;),$$
which is equivalent to
$$\left|\Psi_\mathrm{in}\right&gt;=(\left|0\right&gt;+\left|1\right&gt;) \otimes (\left|0\right&gt;+e^{2\pi i\frac{1}{2}}\left|1\right&gt;) \otimes (\left|0\right&gt;+e^{2\pi i\frac{1}{4}}\left|1\right&gt;).$$</p>
<p>This state can be prepared using the single-qubits gates $H$ and $R_{z}$ as follows:</p>
<p>$$\left|\Psi_\mathrm{in}\right&gt;=H\left|0\right&gt; \otimes R_{z}(\pi)H\left|0\right&gt; \otimes R_{z}(\pi/2)H\left|0\right&gt;.$$</p>
<p>Based on the analysis above we then expect $\mathrm{QFT}^{\dagger} \left|\Psi_\mathrm{in}\right&gt; = \left|0,1,0\right&gt;$.
We can generalize the above example to multiple qubits with the following state preparation code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">circ</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">))</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">ii</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="circuit-implementation-of-qft">
<h2>CIRCUIT IMPLEMENTATION OF QFT<a class="headerlink" href="#circuit-implementation-of-qft" title="Permalink to this heading">#</a></h2>
<p>The QFT circuit can be implemented using only Hadamard gates, controlled phase gates, and SWAP gates. The Hadamard gate $H$, the phase gate ${\displaystyle R_{m}}$, and the SWAP gate are given by
$$H = \frac{1}{\sqrt{2}}
\begin{pmatrix}
1 &amp; 1\
1 &amp; -1\
\end{pmatrix} \qquad \qquad
R_{m} =
\begin{pmatrix}
1 &amp; 0\
0 &amp; e^{\frac{2\pi i}{2^{m}}}\
\end{pmatrix} \qquad \qquad
\mathrm{SWAP} =
\begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0\
0 &amp; 0 &amp; 1 &amp; 0\
0 &amp; 1 &amp; 0 &amp; 0\
0 &amp; 0 &amp; 0 &amp; 1\
\end{pmatrix}.$$</p>
<p>The details of the calculation can be found in a number of resources (including a great exposition on <a class="reference external" href="https://en.wikipedia.org/wiki/Quantum_Fourier_transform">Wikipedia</a> [1]), but the circuit that implements this transformation reads as follows (note that we need to apply a series of swap gates to reverse the order of the qubits thereby recovering the QFT as described above):</p>
<div align="center"><img src="circuit.png"/></div><p><strong>Recursive Implemenation</strong>: By inspection, we can define the first part of this circuit (i.e., everything except the SWAP gates) recursively as shown below:</p>
<div align="center"><img src="recursive_circuit.png"/></div>
<p>where $\text{QFT}_k$ in the above is the part of the circuit excluding the final SWAP gates.</p>
</section>
<section id="imports-and-setup">
<h2>IMPORTS and SETUP<a class="headerlink" href="#imports-and-setup" title="Permalink to this heading">#</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># general imports</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="c1"># magic word for producing visualizations in notebook</span>
<span class="o">%</span><span class="k">matplotlib</span> inline
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># AWS imports: Import Braket SDK modules</span>
<span class="kn">from</span> <span class="nn">braket.circuits</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">circuit</span>
<span class="kn">from</span> <span class="nn">braket.devices</span> <span class="kn">import</span> <span class="n">LocalSimulator</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># set up device: Local Simulator</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">LocalSimulator</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="implementation-of-the-qft-and-inverse-qft-circuits">
<h2>IMPLEMENTATION OF THE QFT AND INVERSE QFT CIRCUITS<a class="headerlink" href="#implementation-of-the-qft-and-inverse-qft-circuits" title="Permalink to this heading">#</a></h2>
<p>In this section we provide simple helper functions to implement the circuits for both QFT and inverse QFT.
Specifically, we demonstrate how such modular building blocks can be registered as subroutines, using <code class="docutils literal notranslate"><span class="pre">&#64;circuit.subroutine(register=True)</span></code>.</p>
<section id="recursive-definition-of-the-qft">
<h3>Recursive definition of the QFT<a class="headerlink" href="#recursive-definition-of-the-qft" title="Permalink to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># qft subroutine without swaps</span>
<span class="k">def</span> <span class="nf">qft_no_swap</span><span class="p">(</span><span class="n">qubits</span><span class="p">):</span>    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Subroutine of the QFT excluding the final SWAP gates, applied to the qubits argument.</span>
<span class="sd">    Returns the a circuit object.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        qubits (int): The list of qubits on which to apply the QFT</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># On a single qubit, the QFT is just a Hadamard.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
    
    <span class="c1"># For more than one qubit, we define the QFT recursively (as shown on the right half of the image above):</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qftcirc</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
        
        <span class="c1"># First add a Hadamard gate</span>
        <span class="n">qftcirc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1"># Then apply the controlled rotations, with weights (angles) defined by the distance to the control qubit.</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">qftcirc</span><span class="o">.</span><span class="n">cphaseshift</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">2</span><span class="p">)))</span>
            
        <span class="c1"># Now apply the above gates recursively to the rest of the qubits</span>
        <span class="n">qftcirc</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">qft_no_swap</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
        
    <span class="k">return</span> <span class="n">qftcirc</span>


<span class="c1"># To complete the full QFT, add swap gates to reverse the order of the qubits</span>
<span class="nd">@circuit</span><span class="o">.</span><span class="n">subroutine</span><span class="p">(</span><span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">qft_recursive</span><span class="p">(</span><span class="n">qubits</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a circuit object corresponding to the Quantum Fourier Transform (QFT)</span>
<span class="sd">    algorithm, applied to the argument qubits.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        qubits (int): The list of qubits on which to apply the QFT</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">qftcirc</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
    
    <span class="c1"># First add the QFT subroutine above</span>
    <span class="n">qftcirc</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">qft_no_swap</span><span class="p">(</span><span class="n">qubits</span><span class="p">))</span>
    
    <span class="c1"># Then add SWAP gates to reverse the order of the qubits:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)):</span>
        <span class="n">qftcirc</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">qftcirc</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="non-recursive-definition-of-the-qft">
<h3>Non-recursive definition of the QFT<a class="headerlink" href="#non-recursive-definition-of-the-qft" title="Permalink to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@circuit</span><span class="o">.</span><span class="n">subroutine</span><span class="p">(</span><span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">qft</span><span class="p">(</span><span class="n">qubits</span><span class="p">):</span>    
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a circuit object corresponding to the Quantum Fourier Transform (QFT)</span>
<span class="sd">    algorithm, applied to the argument qubits.  Does not use recursion to generate the QFT.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        qubits (int): The list of qubits on which to apply the QFT</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">qftcirc</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
    
    <span class="c1"># get number of qubits</span>
    <span class="n">num_qubits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">):</span>
        <span class="c1"># First add a Hadamard gate</span>
        <span class="n">qftcirc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    
        <span class="c1"># Then apply the controlled rotations, with weights (angles) defined by the distance to the control qubit.</span>
        <span class="c1"># Start on the qubit after qubit k, and iterate until the end.  When num_qubits==1, this loop does not run.</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">num_qubits</span> <span class="o">-</span> <span class="n">k</span><span class="p">):</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">qftcirc</span><span class="o">.</span><span class="n">cphaseshift</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="n">j</span><span class="p">],</span><span class="n">qubits</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">angle</span><span class="p">)</span>
            
    <span class="c1"># Then add SWAP gates to reverse the order of the qubits:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">num_qubits</span><span class="o">/</span><span class="mi">2</span><span class="p">)):</span>
        <span class="n">qftcirc</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
    <span class="k">return</span> <span class="n">qftcirc</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="inverse-qft">
<h3>Inverse QFT<a class="headerlink" href="#inverse-qft" title="Permalink to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@circuit</span><span class="o">.</span><span class="n">subroutine</span><span class="p">(</span><span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">inverse_qft</span><span class="p">(</span><span class="n">qubits</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a circuit object corresponding to the inverse Quantum Fourier Transform (QFT)</span>
<span class="sd">    algorithm, applied to the argument qubits.  Does not use recursion to generate the circuit.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        qubits (int): The list of qubits on which to apply the inverse QFT</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># instantiate circuit object</span>
    <span class="n">qftcirc</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
    
    <span class="c1"># get number of qubits</span>
    <span class="n">num_qubits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
    
    <span class="c1"># First add SWAP gates to reverse the order of the qubits:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">num_qubits</span><span class="o">/</span><span class="mi">2</span><span class="p">)):</span>
        <span class="n">qftcirc</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">qubits</span><span class="p">[</span><span class="o">-</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
    <span class="c1"># Start on the last qubit and work to the first.</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)):</span>
    
        <span class="c1"># Apply the controlled rotations, with weights (angles) defined by the distance to the control qubit.</span>
        <span class="c1"># These angles are the negative of the angle used in the QFT.</span>
        <span class="c1"># Start on the last qubit and iterate until the qubit after k.  </span>
        <span class="c1"># When num_qubits==1, this loop does not run.</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_qubits</span> <span class="o">-</span> <span class="n">k</span><span class="p">)):</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">qftcirc</span><span class="o">.</span><span class="n">cphaseshift</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="n">j</span><span class="p">],</span><span class="n">qubits</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">angle</span><span class="p">)</span>
            
        <span class="c1"># Then add a Hadamard gate</span>
        <span class="n">qftcirc</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    
    <span class="k">return</span> <span class="n">qftcirc</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="visualization-of-the-qft-circuit">
<h2>VISUALIZATION OF THE QFT CIRCUIT<a class="headerlink" href="#visualization-of-the-qft-circuit" title="Permalink to this heading">#</a></h2>
<p>In order to check our implementation of the (inverse) QFT circuit, let us visualize them for small numbers of qubits.
By inspection, we can see that the $\mathrm{QFT}$ and $\mathrm{QFT}^{\dagger}$ circuits will effectively cancel each other, as desired.</p>
<p><strong>2 qubits:</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># show inverse QFT example circuit</span>
<span class="n">num_qubits</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">qubits</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span>
<span class="n">my_qft_circ</span> <span class="o">=</span> <span class="n">qft</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;QFT CIRCUIT:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">my_qft_circ</span><span class="p">)</span>

<span class="c1"># show inverse QFT example circuit</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;INVERSE-QFT CIRCUIT:&#39;</span><span class="p">)</span>
<span class="n">my_iqft_circ</span> <span class="o">=</span> <span class="n">inverse_qft</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">my_iqft_circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>QFT CIRCUIT:
T  : |0|     1     |2| 3  |
                           
q0 : -H-PHASE(1.57)---SWAP-
        |             |    
q1 : ---C-----------H-SWAP-

T  : |0|     1     |2| 3  |

INVERSE-QFT CIRCUIT:
T  : | 0  |1|     2      |3|
                            
q0 : -SWAP---PHASE(-1.57)-H-
      |      |              
q1 : -SWAP-H-C--------------

T  : | 0  |1|     2      |3|
</pre></div>
</div>
</div>
</div>
<p><strong>3 qubits:</strong></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># show inverse QFT example circuit</span>
<span class="n">num_qubits</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">qubits</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span>
<span class="n">my_qft_circ</span> <span class="o">=</span> <span class="n">qft</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;QFT CIRCUIT:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">my_qft_circ</span><span class="p">)</span>

<span class="c1"># show inverse QFT example circuit</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;INVERSE-QFT CIRCUIT:&#39;</span><span class="p">)</span>
<span class="n">my_iqft_circ</span> <span class="o">=</span> <span class="n">inverse_qft</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">my_iqft_circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>QFT CIRCUIT:
T  : |0|     1     |      2       |     3     |4| 5  |
                                                      
q0 : -H-PHASE(1.57)-PHASE(0.785)-----------------SWAP-
        |           |                            |    
q1 : ---C-----------|------------H-PHASE(1.57)---|----
                    |              |             |    
q2 : ---------------C--------------C-----------H-SWAP-

T  : |0|     1     |      2       |     3     |4| 5  |

INVERSE-QFT CIRCUIT:
T  : | 0  |1|     2      |       3       |     4      |5|
                                                         
q0 : -SWAP------------------PHASE(-0.785)-PHASE(-1.57)-H-
      |                     |             |              
q1 : -|------PHASE(-1.57)-H-|-------------C--------------
      |      |              |                            
q2 : -SWAP-H-C--------------C----------------------------

T  : | 0  |1|     2      |       3       |     4      |5|
</pre></div>
</div>
</div>
</div>
</section>
<section id="numerical-test-experiments">
<h2>NUMERICAL TEST EXPERIMENTS<a class="headerlink" href="#numerical-test-experiments" title="Permalink to this heading">#</a></h2>
<p>In the following we will verify that our QFT implementation works as expected with a few test examples:</p>
<ol class="arabic simple">
<li><p>First, we will apply the QFT algorithm to the input state $\left|0,0,0\right&gt;$. Here, we expect a uniform superposition of all basis vectors as output, as discussed above.</p></li>
<li><p>Second, following our theoretical discussion above, we will apply the inverse QFT to a particular input state for which we expect a simple computational basis state as output.</p></li>
<li><p>Finally, we verify that the $\mathrm{QFT}$ and $\mathrm{QFT}^{\dagger}$ circuits cancel each other, effectively yielding the identity gate.</p></li>
</ol>
<p>For the second example, we will prepare a specific input state using the following circuit:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">circ</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">))</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">ii</span><span class="p">))</span>
</pre></div>
</div>
<p>This circuit prepares the binary representation of $|2\rangle$, for whatever number of qubits is set.
Disclaimer: Note that if you choose to run this on a real QPU, then you are likely to see imperfect measurement results due to experimental imperfection such as noise.</p>
<section id="numerical-test-example-1">
<h3>NUMERICAL TEST EXAMPLE 1<a class="headerlink" href="#numerical-test-example-1" title="Permalink to this heading">#</a></h3>
<p>First, let us apply the QFT algorithm to the input state $\left|0,0,0\right&gt;$. Here, we expect a uniform superposition of all basis vectors as output, as discussed above.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># check output for input |0,0,0&gt; -&gt; expect uniform distribution</span>
<span class="n">num_qubits</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">qubits</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span>
<span class="n">my_qft_circ</span> <span class="o">=</span> <span class="n">qft</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>

<span class="c1"># specify desired results_types</span>
<span class="n">my_qft_circ</span><span class="o">.</span><span class="n">state_vector</span><span class="p">()</span>
<span class="n">my_qft_circ</span><span class="o">.</span><span class="n">probability</span><span class="p">()</span>

<span class="c1"># Run the QFT on 3 qubits with all zeros input</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">my_qft_circ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">state_vector</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">probs_values</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># format statevector for output</span>
<span class="n">state_vec_pretty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">state_vector</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">state_vec_pretty</span> <span class="o">=</span> <span class="p">[</span><span class="n">ampl</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ampl</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">ampl</span> <span class="ow">in</span> <span class="n">state_vec_pretty</span><span class="p">]</span>

<span class="c1"># bitstrings</span>
<span class="n">format_bitstring</span> <span class="o">=</span> <span class="s1">&#39;{0:0&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;b}&#39;</span>
<span class="n">bitstring_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">format_bitstring</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">num_qubits</span><span class="p">)]</span>

<span class="c1"># Print the output state vector</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Exact statevector:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">state_vec_pretty</span><span class="p">)</span>

<span class="c1"># plot probabalities</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">bitstring_keys</span><span class="p">,</span> <span class="n">probs_values</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;bitstrings&#39;</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Exact statevector:
 [(0.354+0j), (0.354+0j), (0.354+0j), (0.354+0j), (0.354+0j), (0.354+0j), (0.354+0j), (0.354+0j)]
</pre></div>
</div>
<img alt="../../../_images/a38e361bd7d2fd8e826e9314f21c64bd6228ee718edeca04e735456d2756a11f.png" src="../../../_images/a38e361bd7d2fd8e826e9314f21c64bd6228ee718edeca04e735456d2756a11f.png" />
</div>
</div>
<p>Indeed, we do recover a uniform superposition of all basis vectors as output, as expected from our analysis above.</p>
</section>
<section id="numerical-test-example-2">
<h3>NUMERICAL TEST EXAMPLE 2<a class="headerlink" href="#numerical-test-example-2" title="Permalink to this heading">#</a></h3>
<p>Following our theoretical discussion above, we will apply the inverse QFT to a particular input state for which we expect a simple computational basis state as output.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># prepare initial state </span>
<span class="n">num_qubits</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">qubits</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">circ</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">ii</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;1. Printing circuit for state preparation:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>

<span class="c1"># add QFT circuit</span>
<span class="n">circ</span><span class="o">.</span><span class="n">inverse_qft</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>

<span class="c1"># print circuit including QFT</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;2. Full circuit including inverse QFT:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1. Printing circuit for state preparation:
T  : |0|   1    |
                 
q0 : -H----------
                 
q1 : -H-Rz(3.14)-
                 
q2 : -H-Rz(1.57)-

T  : |0|   1    |

2. Full circuit including inverse QFT:
T  : |0|   1    | 2  |3|     4      |       5       |     6      |7|
                                                                    
q0 : -H----------SWAP------------------PHASE(-0.785)-PHASE(-1.57)-H-
                 |                     |             |              
q1 : -H-Rz(3.14)-|------PHASE(-1.57)-H-|-------------C--------------
                 |      |              |                            
q2 : -H-Rz(1.57)-SWAP-H-C--------------C----------------------------

T  : |0|   1    | 2  |3|     4      |       5       |     6      |7|
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># specify desired results_types</span>
<span class="n">circ</span><span class="o">.</span><span class="n">state_vector</span><span class="p">()</span>
<span class="n">circ</span><span class="o">.</span><span class="n">probability</span><span class="p">()</span>

<span class="c1"># Run the QFT on 3 circuits with all zeros input</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">state_vector</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">probs_values</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># format statevector for output</span>
<span class="n">state_vec_pretty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">state_vector</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">state_vec_pretty</span> <span class="o">=</span> <span class="p">[</span><span class="n">ampl</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ampl</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">ampl</span> <span class="ow">in</span> <span class="n">state_vec_pretty</span><span class="p">]</span>

<span class="c1"># bitstrings</span>
<span class="n">format_bitstring</span> <span class="o">=</span> <span class="s1">&#39;{0:0&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;b}&#39;</span>
<span class="n">bitstring_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">format_bitstring</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">num_qubits</span><span class="p">)]</span>

<span class="c1"># Print the output state vector</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Exact statevector:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">state_vec_pretty</span><span class="p">)</span>

<span class="c1"># plot probabalities</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">bitstring_keys</span><span class="p">,</span> <span class="n">probs_values</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;bitstrings&#39;</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Exact statevector:
 [0, 0, (-0.707-0.707j), 0, 0, 0, 0, 0]
</pre></div>
</div>
<img alt="../../../_images/60d858a0e344ec7651c1e25004bbc8ed7eae61ae907798d93a569e9a4369c850.png" src="../../../_images/60d858a0e344ec7651c1e25004bbc8ed7eae61ae907798d93a569e9a4369c850.png" />
</div>
</div>
<p>As expected, all measurements show a unique bitstring corresponding to the integer number set with our initial state preparation, as expected.
Next, let us verify that this works independent of the number of qubits.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># prepare initial state </span>
<span class="n">num_qubits</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">qubits</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">circ</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
<span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">ii</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;1. Printing circuit for state preparation:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>

<span class="c1"># add QFT circuit   </span>
<span class="n">circ</span><span class="o">.</span><span class="n">inverse_qft</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>

<span class="c1"># print circuit including QFT</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;2. Full circuit including inverse QFT:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>

<span class="c1"># specify desired results_types</span>
<span class="n">circ</span><span class="o">.</span><span class="n">state_vector</span><span class="p">()</span>
<span class="n">circ</span><span class="o">.</span><span class="n">probability</span><span class="p">()</span>

<span class="c1"># Run the QFT on 3 circuits with all zeros input</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">state_vector</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">probs_values</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># format statevector for output</span>
<span class="n">state_vec_pretty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">state_vector</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">state_vec_pretty</span> <span class="o">=</span> <span class="p">[</span><span class="n">ampl</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ampl</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">ampl</span> <span class="ow">in</span> <span class="n">state_vec_pretty</span><span class="p">]</span>

<span class="c1"># bitstrings</span>
<span class="n">format_bitstring</span> <span class="o">=</span> <span class="s1">&#39;{0:0&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;b}&#39;</span>
<span class="n">bitstring_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">format_bitstring</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">num_qubits</span><span class="p">)]</span>

<span class="c1"># Print the output state vector</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Exact statevector:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">state_vec_pretty</span><span class="p">)</span>

<span class="c1"># plot probabalities</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">bitstring_keys</span><span class="p">,</span> <span class="n">probs_values</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;bitstrings&#39;</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1. Printing circuit for state preparation:
T  : |0|    1    |
                  
q0 : -H-----------
                  
q1 : -H-Rz(3.14)--
                  
q2 : -H-Rz(1.57)--
                  
q3 : -H-Rz(0.785)-

T  : |0|    1    |

2. Full circuit including inverse QFT:
T  : |0|    1    |    2    |3|     4      |       5       |            6             |       7       |     8      |9|
                                                                                                                     
q0 : -H-----------SWAP--------------------------------------------------PHASE(-0.393)---PHASE(-0.785)-PHASE(-1.57)-H-
                  |                                                     |               |             |              
q1 : -H-Rz(3.14)--|----SWAP------------------PHASE(-0.785)-PHASE(-1.57)-|-------------H-|-------------C--------------
                  |    |                     |             |            |               |                            
q2 : -H-Rz(1.57)--|----SWAP---PHASE(-1.57)-H-|-------------C------------|---------------C----------------------------
                  |           |              |                          |                                            
q3 : -H-Rz(0.785)-SWAP------H-C--------------C--------------------------C--------------------------------------------

T  : |0|    1    |    2    |3|     4      |       5       |            6             |       7       |     8      |9|
Exact statevector:
 [0, 0, (-0.924-0.383j), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
</pre></div>
</div>
<img alt="../../../_images/711bfd3a3f41cfb9bfd763d7fd0ee45a88a6e5865b9fab83e4bb328034523433.png" src="../../../_images/711bfd3a3f41cfb9bfd763d7fd0ee45a88a6e5865b9fab83e4bb328034523433.png" />
</div>
</div>
</section>
<section id="numerical-test-example-3">
<h3>NUMERICAL TEST EXAMPLE 3<a class="headerlink" href="#numerical-test-example-3" title="Permalink to this heading">#</a></h3>
<p>In this section, we verify that the $\mathrm{QFT}$ and $\mathrm{QFT}^{\dagger}$ circuits cancel each other, effectively yielding the identity gate $\mathbb{1}$.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># prepare initial state </span>
<span class="n">num_qubits</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">qubits</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>

<span class="c1"># add QFT circuit</span>
<span class="n">circ</span><span class="o">.</span><span class="n">qft</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">inverse_qft</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>

<span class="c1"># specify desired results_types</span>
<span class="n">circ</span><span class="o">.</span><span class="n">state_vector</span><span class="p">()</span>
<span class="n">circ</span><span class="o">.</span><span class="n">probability</span><span class="p">()</span>

<span class="c1"># Run the QFT on 3 circuits with all zeros input</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">state_vector</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">probs_values</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># format statevector for output</span>
<span class="n">state_vec_pretty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">state_vector</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">state_vec_pretty</span> <span class="o">=</span> <span class="p">[</span><span class="n">ampl</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ampl</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">ampl</span> <span class="ow">in</span> <span class="n">state_vec_pretty</span><span class="p">]</span>

<span class="c1"># bitstrings</span>
<span class="n">format_bitstring</span> <span class="o">=</span> <span class="s1">&#39;{0:0&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;b}&#39;</span>
<span class="n">bitstring_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">format_bitstring</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">num_qubits</span><span class="p">)]</span>

<span class="c1"># Print the output state vector</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Exact statevector:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">state_vec_pretty</span><span class="p">)</span>

<span class="c1"># plot probabalities</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">bitstring_keys</span><span class="p">,</span> <span class="n">probs_values</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;bitstrings&#39;</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Exact statevector:
 [(1+0j), 0, 0, 0, 0, 0, 0, 0]
</pre></div>
</div>
<img alt="../../../_images/cb819b14725738c426c6cb625cea1ee779fc2076796e23e73a8ab5003b39ab22.png" src="../../../_images/cb819b14725738c426c6cb625cea1ee779fc2076796e23e73a8ab5003b39ab22.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># prepare initial state </span>
<span class="n">num_qubits</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">qubits</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">circ</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># add QFT circuit</span>
  
<span class="n">circ</span><span class="o">.</span><span class="n">qft</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">inverse_qft</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>

<span class="c1"># specify desired results_types</span>
<span class="n">circ</span><span class="o">.</span><span class="n">state_vector</span><span class="p">()</span>
<span class="n">circ</span><span class="o">.</span><span class="n">probability</span><span class="p">()</span>

<span class="c1"># Run the QFT on 3 circuits with all zeros input</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="n">state_vector</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">probs_values</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># format statevector for output</span>
<span class="n">state_vec_pretty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">state_vector</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">state_vec_pretty</span> <span class="o">=</span> <span class="p">[</span><span class="n">ampl</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ampl</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">ampl</span> <span class="ow">in</span> <span class="n">state_vec_pretty</span><span class="p">]</span>

<span class="c1"># bitstrings</span>
<span class="n">format_bitstring</span> <span class="o">=</span> <span class="s1">&#39;{0:0&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;b}&#39;</span>
<span class="n">bitstring_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">format_bitstring</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">num_qubits</span><span class="p">)]</span>

<span class="c1"># Print the output state vector</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Exact statevector:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">state_vec_pretty</span><span class="p">)</span>

<span class="c1"># plot probabalities</span>
<span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">bitstring_keys</span><span class="p">,</span> <span class="n">probs_values</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;bitstrings&#39;</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Exact statevector:
 [0, 0, 0, 0, 0, (1+0j), 0, 0]
</pre></div>
</div>
<img alt="../../../_images/786fdb31e7d839b79ecebeebfffafb34b5a2c24a4136c5f9f0abfb74b59d2713.png" src="../../../_images/786fdb31e7d839b79ecebeebfffafb34b5a2c24a4136c5f9f0abfb74b59d2713.png" />
</div>
</div>
</section>
</section>
<section id="comparison-of-implementations">
<h2>COMPARISON OF IMPLEMENTATIONS<a class="headerlink" href="#comparison-of-implementations" title="Permalink to this heading">#</a></h2>
<p>In this section we compare the two implementations (recursive vs. non-recursive), showing that they produce the same circuits.
By inspection you can also check that the $\mathrm{QFT}$ and $\mathrm{QFT}^{\dagger}$ circuits cancel each other, effectively yielding the identity gate $\mathbb{1}$.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># set qubits to perform (inverse) QFT on</span>
<span class="n">qubits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>

<span class="c1"># print circuits </span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Circuit for QFT (using non-recursive implementation):&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">qft</span><span class="p">(</span><span class="n">qubits</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Circuit for QFT (using recursive implementation):&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">qft_recursive</span><span class="p">(</span><span class="n">qubits</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Circuit for inverse QFT:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">inverse_qft</span><span class="p">(</span><span class="n">qubits</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Circuit for QFT (using non-recursive implementation):
T  : |0|     1     |      2       |           3            |      4       |     5     | 6  | 7  |
                                                                                                 
q1 : -H-PHASE(1.57)-PHASE(0.785)---PHASE(0.393)---------------------------------------------SWAP-
        |           |              |                                                        |    
q3 : ---C-----------|------------H-|------------PHASE(1.57)-PHASE(0.785)---------------SWAP-|----
                    |              |            |           |                          |    |    
q6 : ---------------C--------------|------------C-----------|------------H-PHASE(1.57)-SWAP-|----
                                   |                        |              |                |    
q7 : ------------------------------C------------------------C--------------C-----------H----SWAP-

T  : |0|     1     |      2       |           3            |      4       |     5     | 6  | 7  |

Circuit for QFT (using recursive implementation):
T  : |0|     1     |      2       |           3            |      4       |     5     | 6  | 7  |
                                                                                                 
q1 : -H-PHASE(1.57)-PHASE(0.785)---PHASE(0.393)---------------------------------------------SWAP-
        |           |              |                                                        |    
q3 : ---C-----------|------------H-|------------PHASE(1.57)-PHASE(0.785)---------------SWAP-|----
                    |              |            |           |                          |    |    
q6 : ---------------C--------------|------------C-----------|------------H-PHASE(1.57)-SWAP-|----
                                   |                        |              |                |    
q7 : ------------------------------C------------------------C--------------C-----------H----SWAP-

T  : |0|     1     |      2       |           3            |      4       |     5     | 6  | 7  |

Circuit for inverse QFT:
T  : |    0    |1|     2      |       3       |            4             |       5       |     6      |7|
                                                                                                         
q1 : -SWAP--------------------------------------------------PHASE(-0.393)---PHASE(-0.785)-PHASE(-1.57)-H-
      |                                                     |               |             |              
q3 : -|----SWAP------------------PHASE(-0.785)-PHASE(-1.57)-|-------------H-|-------------C--------------
      |    |                     |             |            |               |                            
q6 : -|----SWAP---PHASE(-1.57)-H-|-------------C------------|---------------C----------------------------
      |           |              |                          |                                            
q7 : -SWAP------H-C--------------C--------------------------C--------------------------------------------

T  : |    0    |1|     2      |       3       |            4             |       5       |     6      |7|
</pre></div>
</div>
</div>
</div>
</section>
<hr class="docutils" />
<section id="appendix">
<h2>APPENDIX<a class="headerlink" href="#appendix" title="Permalink to this heading">#</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check SDK version</span>
<span class="o">!</span>pip show amazon-braket-sdk <span class="p">|</span> grep Version
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Version: 0.6.0
</pre></div>
</div>
</div>
</div>
</section>
<hr class="docutils" />
<section id="references">
<h2>REFERENCES<a class="headerlink" href="#references" title="Permalink to this heading">#</a></h2>
<p>[1] Wikipedia: https://en.wikipedia.org/wiki/Quantum_Fourier_transform</p>
<p>[2] Nielsen, Michael A., Chuang, Isaac L. (2010). Quantum Computation and Quantum Information (2nd ed.). Cambridge: Cambridge University Press.</p>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">QUANTUM FOURIER TRANSFORM</a><ul>
<li><a class="reference internal" href="#technical-background-of-qft">TECHNICAL BACKGROUND OF QFT</a></li>
<li><a class="reference internal" href="#circuit-implementation-of-qft">CIRCUIT IMPLEMENTATION OF QFT</a></li>
<li><a class="reference internal" href="#imports-and-setup">IMPORTS and SETUP</a></li>
<li><a class="reference internal" href="#implementation-of-the-qft-and-inverse-qft-circuits">IMPLEMENTATION OF THE QFT AND INVERSE QFT CIRCUITS</a><ul>
<li><a class="reference internal" href="#recursive-definition-of-the-qft">Recursive definition of the QFT</a></li>
<li><a class="reference internal" href="#non-recursive-definition-of-the-qft">Non-recursive definition of the QFT</a></li>
<li><a class="reference internal" href="#inverse-qft">Inverse QFT</a></li>
</ul>
</li>
<li><a class="reference internal" href="#visualization-of-the-qft-circuit">VISUALIZATION OF THE QFT CIRCUIT</a></li>
<li><a class="reference internal" href="#numerical-test-experiments">NUMERICAL TEST EXPERIMENTS</a><ul>
<li><a class="reference internal" href="#numerical-test-example-1">NUMERICAL TEST EXAMPLE 1</a></li>
<li><a class="reference internal" href="#numerical-test-example-2">NUMERICAL TEST EXAMPLE 2</a></li>
<li><a class="reference internal" href="#numerical-test-example-3">NUMERICAL TEST EXAMPLE 3</a></li>
</ul>
</li>
<li><a class="reference internal" href="#comparison-of-implementations">COMPARISON OF IMPLEMENTATIONS</a></li>
<li><a class="reference internal" href="#appendix">APPENDIX</a></li>
<li><a class="reference internal" href="#references">REFERENCES</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    </body>
</html>