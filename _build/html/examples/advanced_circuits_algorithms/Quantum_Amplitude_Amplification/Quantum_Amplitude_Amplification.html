<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <!-- Generated with Sphinx 5.3.0 and Furo 2022.12.07 -->
        <title>QUANTUM AMPLITUDE AMPLIFICATION - Amazon Braket Examples documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=91d0f0d1c444bdcb17a68e833c7a53903343c195" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">Amazon Braket Examples  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  
  <span class="sidebar-brand-text">Amazon Braket Examples  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  
</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="quantum-amplitude-amplification">
<h1>QUANTUM AMPLITUDE AMPLIFICATION<a class="headerlink" href="#quantum-amplitude-amplification" title="Permalink to this heading">#</a></h1>
<p>In this tutorial, we provide a detailed discussion and implementation of the Quantum Amplitude Amplification (QAA) algorithm using the Amazon Braket SDK.
QAA is a routine in quantum computing which generalizes the idea behind Grover’s famous search algorithm, with applications across many quantum algorithms.
In short, QAA uses an iterative approach to systematically increase the probability of finding one or multiple target states in a given search space.
In a quantum computer, QAA can be used to obtain a <em>quadratic speedup</em> over several classical algorithms <span class="xref myst">[1]</span>.</p>
<section id="technical-background-of-qaa">
<h2>TECHNICAL BACKGROUND OF QAA<a class="headerlink" href="#technical-background-of-qaa" title="Permalink to this heading">#</a></h2>
<p><strong>Formal introduction of QAA</strong>: We start off with a brief formal introduction to QAA, following standard references <span class="xref myst">[1-4]</span>.
In the lines that follow, we provide a pictorial derivation of QAA, giving an intuitive background to the derivation shown here.
Consider a unitary $\mathcal{A}$ acting on $(n+1)$ qubits as follows</p>
<p>$$\mathcal{A}|0\rangle _{n+1} = |\psi\rangle = \sqrt{a} |G\rangle |1\rangle + \sqrt{1-a} |B\rangle |0\rangle,$$</p>
<p>where $a \in [0,1]$ is the amplitude we wish to amplify.
Setting $\sqrt{a} = \sin(\theta)$, equivalently we can write</p>
<p>$$\mathcal{A}|0\rangle _{n+1} = |\psi\rangle = \sin(\theta) |G\rangle |1\rangle + \cos(\theta) |B\rangle |0\rangle.$$</p>
<p>Here, we have introduced the $n$-qubit states $|G\rangle$ and $|B\rangle$ by convention referred to as <em>good</em> and <em>bad</em> states, respectively.
The states $|\psi_{1}\rangle = |G\rangle |1\rangle$ and $|\psi_{0}\rangle = |B\rangle |0\rangle$ are (unique) projections of the original state $|\psi\rangle$ into good and bad subspaces, denoted as $\mathcal{H}<em>{1}$ and $\mathcal{H}</em>{0}$, respectively. Note that $|\psi_{1}\rangle$ and $|\psi_{0}\rangle$ are orthogonal, i.e., $ \langle \psi_{0}|\psi_{1}\rangle = \langle B|G\rangle \langle 0|1\rangle =0$, because $\langle 0|1\rangle =0$.</p>
<p><strong>Goal of QAA</strong>: The goal of the algorithm is then to evolve the initial state $|\psi \rangle \in \mathcal{H}$ into a state with a higher overlap with the <em>good</em> subspace $\mathcal{H}<em>{1}$ by <em>amplifying</em> the amplitude of the $|\psi</em>{1}\rangle$ component of the state.</p>
<p>The amplification process that follows boosts the amplitude of the good state $|G\rangle$ from $\sin(\theta)$ to $\sin((2m+1)\theta)$ with $2m$ denoting the number of <em>queries</em> or applications of the unitary $\mathcal{A}$. The probability of finding a <em>good</em> outcome is maximized when $m=\left\lfloor\frac{\pi}{4\theta}\right\rfloor$.</p>
<p><strong>Procedure of QAA</strong>: Rather than directly taking measurements on $|\psi\rangle$ (as prepared by a <em>single</em> application of $\mathcal{A}$), QAA proceeds by applying the following operator $\mathcal{Q}$ (that is derived from $\mathcal{A}$, i.e., taking $\mathcal{A}$ as an input),</p>
<p>$$\mathcal{Q}=\mathcal{A} \mathcal{R}<em>{0} \mathcal{A}^{\dagger} \mathcal{R}</em>{B}.$$</p>
<p>Here,
$\mathcal{R}<em>{0}=2|0\rangle</em>{n+1} \langle 0| - \mathbb{1}$
is a reflection about $|0\rangle_{n+1}$ (leaving the all-zero state $|0\rangle_{n+1}$ untouched while giving a minus sign to all other states) and similarly
$\mathcal{R}<em>{B} = \mathbb{1} - 2 |G\rangle |1\rangle \langle 1|\langle G|$
is a reflection about $|B\rangle |0\rangle$, giving a negative sign on the good state, as $\mathcal{R}</em>{B} |G\rangle |1\rangle = -1|G\rangle |1\rangle$, while leaving the bad state $|B\rangle |0\rangle$ untouched.
Finally, $\mathcal{A}^{\dagger}$ denotes the adjoint of $\mathcal{A}$.
As demonstrated in Refs.<span class="xref myst">[2,3]</span>, repeated application of the operator $\mathcal{Q}$ ($m$-times) on $|\psi\rangle = \mathcal{A}|0\rangle _{n+1}$ gives</p>
<p>$$\mathcal{Q}^{m} |\psi\rangle = \mathcal{Q}^{m}\mathcal{A}|0\rangle _{n+1} = \sin((2m+1)\theta) |G\rangle |1\rangle + \cos((2m+1)\theta) |B\rangle |0\rangle.$$</p>
<p>In a nutshell, this equation shows that, for small values of the unknown parameter $a$, the repeated application of $Q$ (involving $2m$ queries of $\mathcal{A}$ in total) yields a state for which the desired good state would be measured with a probability at least $4m^{2}$ times larger than that of a naive strategy as obtained from $\mathcal{A}|0\rangle <em>{n+1}$.
This result is because the probability of measuring the good state $|G\rangle |1\rangle$ is $P</em>{1}=\sin^{2}((2m+1)\theta) \approx (2m+1)^{2}\theta^{2}&gt;4m^{2} \theta^{2}$.
Compare this to $2m$ naive queries, i.e., $2m$ measurements from copies of the state $\mathcal{A}|0\rangle _{n+1}$ which gives the good state with linear increase in probability $2m$.
This reasoning is at the heart of the quadratic speedup obtained with QAA: the probability of measuring the good state after QAA scales quadratically with $m$ instead of linearly, meaning we only need $O(\sqrt{m})$ queries of $\mathcal{A}$ to achieve the same probability of measuring $|G\rangle$ compared to the classical strategy.
Specifically, if $(2m+1)\theta \approx \pi/2$, we have amplified the success probability to $\sin(…)^{2} \approx 1$.</p>
<p>Because $\mathcal{A}$ is an input to QAA that we assume is given, our goal is to figure out how to implement $\mathcal{R}<em>{B}$, $\mathcal{R}</em>{0}$, and $\mathcal{A}^{\dagger}$ as unitaries in a quantum circuit.
This work is shown in detail in the lines that follow.</p>
<p><strong>Intuition for QAA</strong>: The previous discussion follows the canonical, formal introduction to QAA.
This section provides a pictorial derivation of the QAA routine, which helps to get an intuitive understanding of the definition and the role of the operator $\mathcal{Q}$ introduced previously.
As shown previously, the two states $|\psi_{1}\rangle = |G\rangle |1\rangle$ and $|\psi_{0}\rangle = |B\rangle |0\rangle$ are orthogonal, and the whole problem can be analyzed in the two-dimensional subspace spanned by these two orthogonal vectors, with real amplitudes.
Since the length of the vectors involved are preserved (that is, the vectors remain normalized) we can visualize the whole QAA procedure as transformations of a point on a simple circle, as shown below, using the good and bad states $|G\rangle |1\rangle$ and $|B\rangle |0\rangle$ as basis vectors, respectively.</p>
<div align="center"><img src="vectors.png"/></div><p>Going from left to right in the image above, the QAA routine proceeds as follows:</p>
<ol class="arabic simple">
<li><p><strong>Original situation</strong>: First, the original state prepared by $\mathcal{A}$ as $|\psi\rangle = \mathcal{A}|0\rangle _{n+1} = \sin(\theta) |G\rangle |1\rangle + \cos(\theta) |B\rangle |0\rangle$ resides in the two-dimensional plane spanned by the basis vectors $|G\rangle |1\rangle$ and $|B\rangle |0\rangle$, respectively, with (typically small) projection $\sin(\theta)$ onto the $|G\rangle |1\rangle$ axis.</p></li>
<li><p><strong>Reflection about $|B\rangle |0\rangle$</strong>: We then apply a reflection around $|B\rangle |0\rangle$, transforming $|\psi\rangle$ to $|\psi’\rangle$, keeping the projection along $|B\rangle |0\rangle$ unchanged, but adding a minus sign to the $|G\rangle |1\rangle$ component. Reflection about $|B\rangle |0\rangle$ means that all terms apart from $|B\rangle |0\rangle$ pick up a negative sign. Because there are only two terms, only $|G\rangle |1\rangle$ picks up a negative sign, which is accomplished by the operator $\mathcal{R}_{B} = \mathbb{1} - 2 |G\rangle |1\rangle \langle 1|\langle G|$, as defined previously.</p></li>
<li><p><strong>Reflection about $|\psi\rangle$</strong>: Finally, we apply a reflection around the original state $|\psi\rangle$, giving the final state $|\psi’’\rangle$, with an amplified $|G\rangle |1\rangle$ amplitude of $\sin(3\theta)$, adding an angle of $2\theta$ from the rotation around $|\psi\rangle$ to the original angle $\theta$.
Reflection about $|\psi\rangle$ means that all terms except for $|\psi\rangle$ pick up a minus sign, as can be done by applying the operator $\mathcal{R}<em>{\psi} = 2|\psi\rangle\langle\psi| - \mathbb{1}$.
Using the definition $|\psi\rangle = \mathcal{A}|\vec{0}\rangle$ and conversely $\langle \psi | = \langle \vec{0}|\mathcal{A}^{\dagger}$ as well as the unitarity condition $\mathcal{A}\mathcal{A}^{\dagger}=\mathbb{1}$, this reflection can be rewritten as $\mathcal{R}</em>{\psi} = \mathcal{A}\mathcal{R}<em>{0}\mathcal{A}^{\dagger}$, where $\mathcal{R}</em>{0}=2|\vec{0}\rangle\langle\vec{0}| - \mathbb{1}$ is a reflection about the all-zero state $|\vec{0}\rangle$ where all terms except for $|\vec{0}\rangle$ pick up a minus sign.</p></li>
</ol>
<p>This sequence completes one cycle of the QAA routine, that is one application of $\mathcal{Q}$.
In total, each application of $Q$ involves two reflections, first through $|B\rangle |0\rangle$ and then through $|\psi\rangle$.
The product is a rotation with angle $2\theta$.
Based on our analysis above we can write the rotation $\mathcal{Q}$ as</p>
<p>$$\mathcal{Q} = \mathcal{R}<em>{\psi}\mathcal{R}</em>{B} = \mathcal{A}\mathcal{R}<em>{0}\mathcal{A}^{\dagger}\mathcal{R}</em>{B},$$</p>
<p>thereby confirming the formal definition above.
Repeating this sequence, after $m$ iterations of $\mathcal{Q}$ we get the generalized equation</p>
<p>$$\mathcal{Q}^{m} |\psi\rangle = \sin((2m+1)\theta) |G\rangle |1\rangle + \cos((2m+1)\theta) |B\rangle |0\rangle.$$</p>
<p><strong>Obtaining a quantum speedup</strong>:
To see that QAA indeed provides a quantum speedup, suppose we use it to query an unsorted database with $N$ elements and $G$ <em>good</em> elements.
The classical algorithm for finding good entries is to query each element in the database until a good one is found. Thus, the classical solution requires $O(N/G)$ queries.
A quantum solution would be to query the database in superposition using the state $1/\sqrt{N}\sum_i|j\rangle$, where $j$ enumerates the $N$ elements of the database.
The oracle prepares the state</p>
<p>$$|\psi\rangle = \sqrt{\frac{G}{N}} |G\rangle |1\rangle + \sqrt{\frac{N-G}{N}} |B\rangle |0\rangle.$$</p>
<p>Thus, $\sqrt{a}=\sin(\theta)=\sqrt{G/N}$ and $\theta \approx \sqrt{G/N}$ for the typical scenario where $\theta \ll 1$.</p>
<p>We then apply the QAA algorithm to amplify the amplitude of the good states, such that the probability of obtaining a <em>good</em> outcome is amplified.
To ensure that we measure a good outcome with high probability, we apply the Grover iterator $\left\lfloor\frac{\pi}{4\theta}\right\rfloor=\left\lfloor\frac{\pi}{4}\sqrt{\frac{N}{G}}\right\rfloor$ times.
In other words, we only need to query the oracle $O(\sqrt{N/G})$ times in order to find a good outcome to the search problem with high probability.
This outcome is a quadratic improvement over the $O(N/G)$ oracle calls required classically.</p>
</section>
<section id="circuit-implementation-of-qaa">
<h2>CIRCUIT IMPLEMENTATION OF QAA<a class="headerlink" href="#circuit-implementation-of-qaa" title="Permalink to this heading">#</a></h2>
<p><strong>Implementation of QAA on a QC</strong>: Now that we have an intuitive understanding for QAA (after all, it is just a rotation, as illustrated previously), the final puzzle piece that remains to be solved is the actual implementation of the reflections $\mathcal{R}<em>{B}$ and $\mathcal{R}</em>{0}$ as a quantum circuit (since $\mathcal{A}$ is given as input to the QAA problem).
Rather than implementing $\mathcal{R}_{0}$ below, we will show how to implement</p>
<p>$$-\mathcal{R}<em>{0} = \mathbb{1} - 2|0\rangle</em>{n+1} \langle 0|,$$</p>
<p>which gives a minus sign to $|0\rangle_{n+1}$ only, leaving all other states untouched.
To compensate for this minus sign, overall we will show how to implement the unitary
$$\mathcal{Q}=\mathcal{A} (-\mathcal{R}<em>{0}) \mathcal{A}^{\dagger} (-\mathcal{R}</em>{B}).$$</p>
<p><strong>Implementation of $-\mathcal{R}_{B}$</strong>: First, let us consider</p>
<p>$$-\mathcal{R}_{B} = 2 |G\rangle |1\rangle \langle 1|\langle G| - \mathbb{1},$$</p>
<p>which is a reflection about $|G\rangle |1\rangle$, because $-\mathcal{R}<em>{B} |G\rangle |1\rangle = +1|G\rangle |1\rangle$ and $-\mathcal{R}</em>{B} |B\rangle |0\rangle = -1|B\rangle |0\rangle$.
This transformation can be achieved by applying $X_{n+1}Z_{n+1}X_{n+1}$ to the (last) ancilla qubit.
This way, we obtain a minus sign whenever the ancilla is in the $|0\rangle$ state.</p>
<p><strong>Implementation of $-\mathcal{R}_{0}$</strong>: We must implement the transformation $|0, \dots, 0\rangle \rightarrow -|0, \dots, 0\rangle$, while leaving all other states untouched.
To this end, we can flip all the qubits (using single-qubit $X$ gates), flipping the sign of $|11…1\rangle$, and flipping the qubits back.
Thus, the last operation that remains to be defined explicitly is flipping the sign of $|11…1\rangle$ , which can be done with ancilla qubits.
One possible way to do this task is by using a multiply-controlled Toffoli gate:
First apply a Pauli-$X$ gate to each qubit.
Then apply the $N+1$ qubit Toffoli, controlled on all $N$ of the qubits we want to test, and targeted on a single ancilla qubit.
If (and only if) all of the qubits were in the zero state, then the ancilla qubit will be flipped to $|1\rangle$.
We then apply a $Z$ gate to the ancilla qubit, so the overall wavefunction picks up a minus sign whenever all of the register qubits are in the $|0\rangle$ state.
Finally, we uncompute the ancilla by applying another $N+1$ qubit Toffoli gate.</p>
<div align="center"><img src="R0.png" width="300"/></div><p>We can decompose the $N+1$ qubit Toffoli gate into $N-1$ CCNOT (that is, 3 qubit Toffoli) gates and $N-1$ ancilla qubits, shown as follows for $N=4$ register qubits:</p>
<div align="center"><img src="Toffoli_decomp.png"/></div><p>Thus, the final circuit can be implemented using ancilla qubits as</p>
<div align="center"><img src="R_full.png"/></div></section>
<section id="imports-and-setup">
<h2>IMPORTS and SETUP<a class="headerlink" href="#imports-and-setup" title="Permalink to this heading">#</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># general imports</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="c1"># magic word for producing visualizations in notebook</span>
<span class="o">%</span><span class="k">matplotlib</span> inline
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># AWS imports: Import Braket SDK modules</span>
<span class="kn">from</span> <span class="nn">braket.circuits</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">circuit</span>
<span class="kn">from</span> <span class="nn">braket.devices</span> <span class="kn">import</span> <span class="n">LocalSimulator</span>
<span class="kn">from</span> <span class="nn">braket.aws</span> <span class="kn">import</span> <span class="n">AwsSession</span><span class="p">,</span> <span class="n">AwsDevice</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># local imports</span>
<span class="kn">from</span> <span class="nn">utils_circuit</span> <span class="kn">import</span> <span class="n">get_unitary</span><span class="p">,</span> <span class="n">adjoint</span>
<span class="kn">from</span> <span class="nn">utils_qaa</span> <span class="kn">import</span> <span class="n">qaa</span>

<span class="c1"># monkey patch get_unitary() and adjoint() to the Circuit class</span>
<span class="n">Circuit</span><span class="o">.</span><span class="n">get_unitary</span> <span class="o">=</span> <span class="n">get_unitary</span>
<span class="n">Circuit</span><span class="o">.</span><span class="n">adjoint</span> <span class="o">=</span> <span class="n">adjoint</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># set up device: Local Schroedinger Simulator</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">LocalSimulator</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="implementation-of-reflection-operators">
<h2>IMPLEMENTATION OF REFLECTION OPERATORS<a class="headerlink" href="#implementation-of-reflection-operators" title="Permalink to this heading">#</a></h2>
<p>In <code class="docutils literal notranslate"><span class="pre">utils_qaa.py</span></code> we provide a set of simple helper functions to implement the quantum circuit for the QAA algorithm.
Specifically, we demonstrate how such modular building blocks can be registered as subroutines, using <code class="docutils literal notranslate"><span class="pre">&#64;circuit.subroutine(register=True)</span></code>.
Here we first highlight the implementation of the reflections $-\mathcal{R}<em>{B}$ and $-\mathcal{R}</em>{0}$ as discussed previously. The functions defined as follows comprise the <code class="docutils literal notranslate"><span class="pre">utiles_qaa.py</span></code> module.</p>
<section id="reflection-around-b-rangle-0-rangle">
<h3>REFLECTION AROUND $|B\rangle |0\rangle$<a class="headerlink" href="#reflection-around-b-rangle-0-rangle" title="Permalink to this heading">#</a></h3>
<p>We need to apply a minus sign to $|B\rangle |0\rangle$ only. We achieve this goal by applying $XZX$ to the ancilla qubit, so that we obtain a minus sign whenever the ancilla is in the $|0\rangle$ state.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># helper function to apply XZX to given qubit</span>
<span class="nd">@circuit</span><span class="o">.</span><span class="n">subroutine</span><span class="p">(</span><span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">minus_R_B</span><span class="p">(</span><span class="n">qubit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to apply a minus sign to |B&gt;|0&gt;. This goal is achieved by applying XZX to the ancilla qubit.</span>

<span class="sd">    Args:</span>
<span class="sd">        qubit: the ancilla qubit on which we apply XZX.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># instantiate circuit object</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
    
    <span class="c1"># Apply sequence XZX to given qubit</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">qubit</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">circ</span>
</pre></div>
</div>
</section>
<section id="reflection-around-0-rangle-otimes-n-1">
<h3>REFLECTION AROUND $|0\rangle^{\otimes n+1}$<a class="headerlink" href="#reflection-around-0-rangle-otimes-n-1" title="Permalink to this heading">#</a></h3>
<p>We must implement $-\mathcal{R}<em>{0}$, which gives a minus sign to $|0\rangle</em>{n+1}$ only, leaving all other states untouched.
To this end, we implement the circuit visualized previously using ancilla qubits; alternatively, as controlled by the flag <code class="docutils literal notranslate"><span class="pre">use_explicit_unitary</span></code>, one can evolve the system with the the unitary $\mathrm{diag}(-1,1,1,…,1)$.
This way, we can run QAA on <em>classical</em> simulators without the need to resort to ancilla qubits.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Helper function to apply rotation -R0</span>
<span class="nd">@circuit</span><span class="o">.</span><span class="n">subroutine</span><span class="p">(</span><span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">minus_R_zero</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span> <span class="n">use_explicit_unitary</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to implement transformation: |0,0,...0&gt; -&gt; -|0,0,...0&gt;, all others unchanged. </span>

<span class="sd">    Args:</span>
<span class="sd">        qubits: list of qubits on which to apply the gates</span>
<span class="sd">        use_explicit_unitary (default False): Flag to specify that we could instead implement</span>
<span class="sd">        the desired gate using a custom gate defined by the unitary diag(-1,1,...,1).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
    
    <span class="c1"># If the use_explicit_matrix flag is True, we just apply the unitary defined by |0,0,...0&gt; -&gt; -|0,0,...0&gt;</span>
    <span class="k">if</span> <span class="n">use_explicit_unitary</span><span class="p">:</span>
        <span class="c1"># Create the matrix diag(-1,1,1,...,1)</span>
        <span class="n">unitary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">))</span>
        <span class="n">unitary</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=-</span><span class="mi">1</span>
        <span class="c1"># Add a gate defined by this matrix</span>
        <span class="n">circ</span><span class="o">.</span><span class="n">unitary</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">unitary</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="n">qubits</span><span class="p">)</span>
    
    <span class="c1"># Otherwise implement the unitary using ancilla qubits:</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Flip all qubits. We now must check whether all qubits are |1&gt;, rather than |0&gt;.</span>
        <span class="n">circ</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>

        <span class="c1"># If we have only 1 qubit, we only must apply XZX to that qubit to pick up a minus sign on |0&gt;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">circ</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>

        <span class="c1"># For more qubits, we use Toffoli (or CCNOT) gates to verify the qubits are in |1&gt; (after applying X)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># Dynamically add ancilla qubits, starting on the next unused qubit in the circuit</span>
            <span class="c1"># NOTE: if this subroutine is being applied to a subset of qubits in a circuit, these ancilla</span>
            <span class="c1"># registers may already be used. We could pass in circ as an argument and add ancillas outside of</span>
            <span class="c1"># circ.targets instead, if desired.</span>
            <span class="n">ancilla_start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># Check that the first two register qubits are both 1&#39;s using a CCNOT on a new ancilla qubit.</span>
            <span class="n">circ</span><span class="o">.</span><span class="n">ccnot</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ancilla_start</span><span class="p">)</span>

            <span class="c1"># Now add a CCNOT from each of the next register qubits, comparing with the ancilla we just added.</span>
            <span class="c1"># Target on a new ancilla. If len(qubits) is 2, this does not execute.</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">qubit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">:]):</span>
                <span class="n">circ</span><span class="o">.</span><span class="n">ccnot</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span><span class="n">ancilla_start</span><span class="o">+</span><span class="n">ii</span><span class="p">,</span> <span class="n">ancilla_start</span><span class="o">+</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># A Z gate applied to the last ancilla qubit gives a minus sign if all register qubits are |1&gt;</span>
            <span class="n">ancilla_end</span> <span class="o">=</span> <span class="n">ancilla_start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
            <span class="n">circ</span><span class="o">.</span><span class="n">z</span><span class="p">(</span><span class="n">ancilla_end</span><span class="p">)</span>

            <span class="c1"># Now uncompute to disentangle the ancilla qubits by applying CCNOTs in the reverse order to the previous.</span>
            <span class="k">for</span> <span class="n">jj</span><span class="p">,</span><span class="n">qubit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">2</span><span class="p">:])):</span>
                <span class="n">circ</span><span class="o">.</span><span class="n">ccnot</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span><span class="n">ancilla_end</span><span class="o">-</span><span class="n">jj</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ancilla_end</span><span class="o">-</span><span class="n">jj</span><span class="p">)</span>

            <span class="c1"># Finally undo the last CCNOT on the first two register qubits.</span>
            <span class="n">circ</span><span class="o">.</span><span class="n">ccnot</span><span class="p">(</span><span class="n">qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ancilla_start</span><span class="p">)</span>

        <span class="c1"># Flip all qubits back</span>
        <span class="n">circ</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">circ</span>
</pre></div>
</div>
</section>
</section>
<section id="visualization-of-the-circuit-for-the-reflection-mathcal-r-0">
<h2>VISUALIZATION OF THE CIRCUIT FOR THE REFLECTION $\mathcal{R}_{0}$<a class="headerlink" href="#visualization-of-the-circuit-for-the-reflection-mathcal-r-0" title="Permalink to this heading">#</a></h2>
<p>To check our implementation of the $-\mathcal{R}_{0}$ circuit discussed previously, let us visualize this circuit for small number of qubits.
Note that our implementation accepts a list of qubit indices with arbitrary index ordering.</p>
<section id="example-circuit-with-four-qubits-and-simple-index-ordering">
<h3>Example circuit with four qubits and simple index ordering:<a class="headerlink" href="#example-circuit-with-four-qubits-and-simple-index-ordering" title="Permalink to this heading">#</a></h3>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qubits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">circ</span><span class="o">.</span><span class="n">minus_R_zero</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>T  : |0|1|2|3|4|5| 6 | 7 |8|
                            
q0 : -X-C-------------C---X-
        |             |     
q1 : -X-C-------------C---X-
        |             |     
q2 : -X-|-C-------C---|-X---
        | |       |   |     
q3 : -X-|-|-C---C-|-X-|-----
        | | |   | |   |     
q4 : ---X-C-|---|-C---X-----
          | |   | |         
q5 : -----X-C---C-X---------
            |   |           
q6 : -------X-Z-X-----------

T  : |0|1|2|3|4|5| 6 | 7 |8|
</pre></div>
</div>
</div>
</div>
</section>
<section id="example-with-four-qubits-and-arbitrary-index-ordering">
<h3>Example with four qubits and arbitrary index ordering:<a class="headerlink" href="#example-with-four-qubits-and-arbitrary-index-ordering" title="Permalink to this heading">#</a></h3>
<p>Note that the simulators require contiguous qubit indexing, while our algorithm does not.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">qubits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">circ</span><span class="o">.</span><span class="n">minus_R_zero</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>T  : |0|1|2|3|4|5|6| 7 |8|
                          
q0 : -X-C-----------C---X-
        |           |     
q1 : -X-C-----------C---X-
        |           |     
q4 : -X-|---C---C-X-|-----
        |   |   |   |     
q5 : -X-|-C-|---|-C-|-X---
        | | |   | | |     
q6 : ---X-C-|---|-C-X-----
          | |   | |       
q7 : -----X-C---C-X-------
            |   |         
q8 : -------X-Z-X---------

T  : |0|1|2|3|4|5|6| 7 |8|
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="implementation-of-qaa">
<h2>IMPLEMENTATION OF QAA<a class="headerlink" href="#implementation-of-qaa" title="Permalink to this heading">#</a></h2>
<p>This section puts everything together and shows how to implement QAA using the subroutines given previously.
We first build a function <code class="docutils literal notranslate"><span class="pre">grover_iterator(...)</span></code> that implements the Grover iterator $\mathcal{Q}=\mathcal{A} \mathcal{R}<em>{0} \mathcal{A}^{\dagger} \mathcal{R}</em>{B}$, given the unitary $\mathcal{A}$ and the so-called flag qubit labeling the good/bad subspaces.
Given this implementation for the Grover iterator $\mathcal{Q}$ it is straightforward to implement a QAA routine <code class="docutils literal notranslate"><span class="pre">qaa(...)</span></code> which repeatedly applies the iterator $\mathcal{Q}$ for a given number of iterations.</p>
<p>The full code (imported into this notebook in the <span class="xref myst">imports and setup</span> section) is available in the module <code class="docutils literal notranslate"><span class="pre">utils_qaa.py</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@circuit</span><span class="o">.</span><span class="n">subroutine</span><span class="p">(</span><span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">grover_iterator</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">flag_qubit</span><span class="p">,</span><span class="n">qubits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">use_explicit_unitary</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to implement the Grover iterator Q=A R_0 A* R_B. </span>

<span class="sd">    Args:</span>
<span class="sd">        A: Circuit defining the unitary A</span>
<span class="sd">        flag_qubit: Specifies which of the qubits A acts on labels the good/bad subspace.</span>
<span class="sd">                    Must be an element of qubits (if passed) or A.qubits.</span>
<span class="sd">        qubits: list of qubits on which to apply the gates (including the flag_qubit).</span>
<span class="sd">                If qubits is different from A.qubits, A is applied to qubits instead.</span>
<span class="sd">        use_explicit_unitary: Flag to specify that we should implement R_0 using using a custom</span>
<span class="sd">                              gate defined by the unitary diag(-1,1,...,1). Default is False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If no qubits are passed, apply the gates to the targets of A</span>
    <span class="k">if</span> <span class="n">qubits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">qubits</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">qubits</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If qubits are passed, make sure it&#39;s the right number to remap from A.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">qubits</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of desired target qubits differs from number of targets in A&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">flag_qubit</span><span class="o">=</span><span class="nb">repr</span><span class="p">(</span><span class="n">flag_qubit</span><span class="p">)))</span>
    
    <span class="c1"># Verify that flag_qubit is one of the qubits on which A acts, or one of the user defined qubits</span>
    <span class="k">if</span> <span class="n">flag_qubit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">qubits</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;flag_qubit </span><span class="si">{flag_qubit}</span><span class="s1"> is not in targets of A&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">flag_qubit</span><span class="o">=</span><span class="nb">repr</span><span class="p">(</span><span class="n">flag_qubit</span><span class="p">)))</span>
    
    <span class="c1"># Instantiate the circuit</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
    
    <span class="c1"># Apply -R_B to the flag qubit</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">minus_R_B</span><span class="p">(</span><span class="n">flag_qubit</span><span class="p">)</span>
    
    <span class="c1"># Apply A^\dagger. Use target mapping if different qubits are specified</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">add_circuit</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">adjoint</span><span class="p">(),</span><span class="n">target</span><span class="o">=</span><span class="n">qubits</span><span class="p">)</span>
    
    <span class="c1"># Apply -R_0</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">minus_R_zero</span><span class="p">(</span><span class="n">qubits</span><span class="p">,</span><span class="n">use_explicit_unitary</span><span class="p">)</span>
    
    <span class="c1"># Apply A, mapping targets if desired.</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">add_circuit</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">target</span><span class="o">=</span><span class="n">qubits</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">circ</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@circuit</span><span class="o">.</span><span class="n">subroutine</span><span class="p">(</span><span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">qaa</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">flag_qubit</span><span class="p">,</span><span class="n">num_iterations</span><span class="p">,</span><span class="n">qubits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">use_explicit_unitary</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to implement the Quantum Amplitude Amplification Q^m, where Q=A R_0 A* R_B, m=num_iterations. </span>

<span class="sd">    Args:</span>
<span class="sd">        A: Circuit defining the unitary A</span>
<span class="sd">        flag_qubit: Specifies which of the qubits A acts on labels the good/bad subspace.</span>
<span class="sd">                    Must be an element of qubits (if passed) or A.qubits.</span>
<span class="sd">        num_iterations: number of applications of the Grover iterator Q.</span>
<span class="sd">        qubits: list of qubits on which to apply the gates (including the flag_qubit).</span>
<span class="sd">                If qubits is different from A.qubits, A is applied to qubits instead.</span>
<span class="sd">        use_explicit_unitary: Flag to specify that we should implement R_0 using using a custom</span>
<span class="sd">                              gate defined by the unitary diag(-1,1,...,1). Default is False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Instantiate the circuit</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
    
    <span class="c1"># Apply the Grover iterator num_iterations times:</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_iterations</span><span class="p">):</span>
        <span class="n">circ</span><span class="o">.</span><span class="n">grover_iterator</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">flag_qubit</span><span class="p">,</span><span class="n">qubits</span><span class="p">,</span><span class="n">use_explicit_unitary</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">circ</span>
</pre></div>
</div>
</section>
<section id="numerical-example">
<h2>NUMERICAL EXAMPLE<a class="headerlink" href="#numerical-example" title="Permalink to this heading">#</a></h2>
<p>This section shows how to use QAA to amplify the amplitude of $|11\rangle$ of a two-qubit state, thereby increasing the entanglement between the two qubits. Consider a single qubit in the state</p>
<p>$$|\psi\rangle=\sqrt{1-\delta^2}|0\rangle + \delta |1\rangle,$$</p>
<p>where $\delta$ is small. This state can be prepared using a small rotation around the $y$ direction:</p>
<p>$$R_y(\epsilon)|0\rangle=|\psi\rangle,$$</p>
<p>where $\epsilon$ is chosen to give a coefficient of $\delta=\sin(\epsilon/2) \approx \epsilon/2$ to $|1\rangle$.</p>
<p>Suppose $|1\rangle$ is the “good” state and $|0\rangle$ is the “bad” state.
We can use a single ancilla qubit to mark whether our register qubit is in the “good” or “bad” state, which can be accomplished by applying a single $\mathrm{CNOT}$ gate to our ancilla qubit and $|\psi\rangle$.
Thus,</p>
<p>$$
\mathcal{A}|0\rangle|0\rangle = \mathrm{CNOT}\circ R_y(\epsilon)|0\rangle|0\rangle = \mathrm{CNOT}|\psi\rangle|0\rangle = \sqrt{1-\delta^2}|00\rangle + \delta |11\rangle.
$$</p>
<p>Our goal is to amplify the coefficient of the “good” state. Using the previous algorithm, this amplification corresponds to applying Quantum Amplitude Amplification with an input unitary $\mathcal{A}=\mathrm{CNOT}\circ R_y(\epsilon)$. We then test whether the flag qubit is in the $|1\rangle$ state, which we can achieve by checking the amplitude of the $|11\rangle$ state.</p>
<p>Let us check the effectiveness of the algorithm by plotting the probability of measuring $|11\rangle$ as a function of the number of repetitions $m$, which corresponds to the number of queries of the oracle, in the classical problem. According to the description given previously, we should see a distribution that looks like $O(\sin^2(m))$. Note that the probability <code class="docutils literal notranslate"><span class="pre">ResultType</span></code> we will use requires a non-zero value for <code class="docutils literal notranslate"><span class="pre">shots</span></code> when running on an on-demand simulator.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up the state A|00&gt;</span>
<span class="n">flag_qubit</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">A_circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Add marginal probability for flag qubit as result Type </span>
<span class="n">A_circ</span><span class="o">.</span><span class="n">probability</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="p">[</span><span class="n">flag_qubit</span><span class="p">])</span>

<span class="c1"># Let&#39;s find the probability of measuring |11&gt; for different values of m, the number of applications of QAA:</span>
<span class="n">probabilities</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">stepsize</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">iterations</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="n">stepsize</span><span class="p">)</span>
<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">iterations</span><span class="p">:</span>
    
    <span class="c1"># Get circuit object</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
    <span class="c1"># Apply QAA using A defined by A_circ</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">qaa</span><span class="p">(</span><span class="n">A_circ</span><span class="p">,</span> <span class="n">flag_qubit</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">use_explicit_unitary</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># Classically simulate the circuit</span>
    <span class="c1"># Give the correct device.run call depending on whether the device is local or on-demand</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">LocalSimulator</span><span class="p">):</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
        
    <span class="c1"># Get result</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
    <span class="c1"># Append the probability of measuring |11&gt; for this value of m.</span>
    <span class="n">probabilities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># Get analytical result for comparison</span>
<span class="n">probs_theo</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">mm</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">epsilon</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">mm</span> <span class="ow">in</span> <span class="n">iterations</span><span class="p">]</span>
    
<span class="c1"># Plot the results</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">iterations</span><span class="p">,</span> <span class="n">probabilities</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">iterations</span><span class="p">,</span> <span class="n">probs_theo</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Number of Iterations&#39;</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Probability of measuring flag qubit in |1&gt;&#39;</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../../_images/a157bd6c9cdb153fa2ea1248c6302324afc87b17ba799705d5428dc96bc2af17.png" src="../../../_images/a157bd6c9cdb153fa2ea1248c6302324afc87b17ba799705d5428dc96bc2af17.png" />
</div>
</div>
<p>As expected, we see that the repeated application of the Grover iterator $\mathcal{Q}$ does increase the amplitude associated with the state $|11\rangle$.
The probability of measuring the bitstring 11 follows the expected analytical result, given by $(P_{11} = \sin^{2}[(2m+1)\epsilon/2])$, and shown as the solid orange line.
Moreover, we have verified that the optimal number of iterations is approximately given by $\lfloor \frac{\pi}{4\theta}\rfloor= \lfloor \frac{\pi}{2\epsilon}\rfloor \approx 31$.</p>
</section>
<hr class="docutils" />
<section id="appendix">
<h2>APPENDIX<a class="headerlink" href="#appendix" title="Permalink to this heading">#</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check SDK version</span>
<span class="c1"># alternative: braket.__version__</span>
<span class="o">!</span>pip show amazon-braket-sdk <span class="p">|</span> grep Version
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Version: 0.6.0
</pre></div>
</div>
</div>
</div>
</section>
<section id="appendix-alternative-run-with-amplitude-result-type">
<h2>APPENDIX: ALTERNATIVE RUN WITH AMPLITUDE RESULT TYPE<a class="headerlink" href="#appendix-alternative-run-with-amplitude-result-type" title="Permalink to this heading">#</a></h2>
<p>Rather than just examining the marginal probability to find the flag qubit in state $|1\rangle$ as done before, we can also investigate the behavior of the amplitude associated with the state $|11\rangle$.
This amplitude is initially given by $\delta=\sin(\epsilon/2)\approx \epsilon/2$ for small $\epsilon$. We can check explicitly that this amplitude increases using repeated applications of the Grover iterator, and recover the plot using the absolute value squared of the amplitudes.</p>
<p>Using amplitudes also presents a learning opportunity:
If we use $N-1$ ancilla qubits to implement the reflection $\mathcal{R}_{0}$ (by fixing <code class="docutils literal notranslate"><span class="pre">use_explicit_unitary</span> <span class="pre">=</span> <span class="pre">False</span></code>), then measurement outcomes are bitstrings of size $N+N-1=2N-1$ (as we measure the original qubits on which the circuit acts, as well as the ancilla qubits).</p>
<p>Since the ancilla qubits are initialized in $|0, 0, …\rangle$ and are uncomputed back to their initial state in the last step of the algorithm, we can find the amplitude of a given bitstring on the register qubits by padding that target bitstring (for example, $11$ in our example) with the right number ($N-1$) of zeros.</p>
<p>Using a classical simulator backend, we can attach the corresponding amplitude as a <code class="docutils literal notranslate"><span class="pre">ResultType</span></code> to the circuit, as shown in the following code.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up the state A|00&gt;</span>
<span class="n">flag_qubit</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">epsilon</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">A_circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">)</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># set switch to either use explicit unitary diag(-1, 1, ...) [True] or use ancillas [False]</span>
<span class="n">use_explicit_unitary</span> <span class="o">=</span> <span class="kc">True</span>

<span class="c1"># Let&#39;s find the probability of measuring |11&gt; for different values of m, the number of applications of QAA:</span>
<span class="n">probabilities</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">stepsize</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">iterations</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="n">stepsize</span><span class="p">)</span>
<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">iterations</span><span class="p">:</span>
    
    <span class="c1"># Get circuit object</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
    <span class="c1"># Apply QAA using A defined by A_circ</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">qaa</span><span class="p">(</span><span class="n">A_circ</span><span class="p">,</span> <span class="n">flag_qubit</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">use_explicit_unitary</span><span class="o">=</span><span class="n">use_explicit_unitary</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">use_explicit_unitary</span><span class="p">:</span>
        <span class="n">target_string</span> <span class="o">=</span> <span class="s1">&#39;11&#39;</span>
        <span class="n">circ</span><span class="o">.</span><span class="n">amplitude</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="p">[</span><span class="n">target_string</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">number_ancillas</span> <span class="o">=</span> <span class="n">A_circ</span><span class="o">.</span><span class="n">qubit_count</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">target_string</span> <span class="o">=</span> <span class="s1">&#39;11&#39;</span><span class="o">+</span><span class="s1">&#39;0&#39;</span><span class="o">*</span><span class="n">number_ancillas</span>
        <span class="n">circ</span><span class="o">.</span><span class="n">amplitude</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="p">[</span><span class="n">target_string</span><span class="p">])</span>
    
    <span class="c1"># Classically simulate the circuit</span>
    <span class="c1"># Execute the correct device.run call depending on whether the device is local or on-demand</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">LocalSimulator</span><span class="p">):</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">task</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># Get result</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>   
    <span class="c1"># Append the probability of measuring |11&gt; for this value of m.</span>
    <span class="n">probabilities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">target_string</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Get analytical result for comparison</span>
<span class="n">probs_theo</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">mm</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">epsilon</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">mm</span> <span class="ow">in</span> <span class="n">iterations</span><span class="p">]</span>
    
<span class="c1"># Plot the results</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">iterations</span><span class="p">,</span> <span class="n">probabilities</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">iterations</span><span class="p">,</span> <span class="n">probs_theo</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Number of Iterations&#39;</span><span class="p">);</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Probability of measuring 11&#39;</span><span class="p">);</span>

<span class="c1"># Let&#39;s compare the amplitude of |11&gt; in the initial state versus the state with maximum probability:</span>
<span class="c1"># Print the initial amplitude of |11&gt;</span>

<span class="c1"># Add a Result Type to output the amplitude of |11&gt; for A</span>
<span class="n">A_initial</span> <span class="o">=</span> <span class="n">A_circ</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">A_initial</span><span class="o">.</span><span class="n">amplitude</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;11&#39;</span><span class="p">])</span>

<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">LocalSimulator</span><span class="p">):</span>
    <span class="n">initial_result</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">A_initial</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">initial_result</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">A_initial</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Amplitude &lt;11|Initial State&gt;:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">initial_result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Find the number of iterations required to achieve the maximum probability:</span>
<span class="n">max_prob</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">probabilities</span><span class="p">)</span>
<span class="n">max_iter</span> <span class="o">=</span> <span class="n">iterations</span><span class="p">[</span><span class="n">probabilities</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">max_prob</span><span class="p">)]</span>

<span class="c1"># Generate that state:</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>
<span class="n">circ</span><span class="o">.</span><span class="n">qaa</span><span class="p">(</span><span class="n">A_circ</span><span class="p">,</span> <span class="n">flag_qubit</span><span class="p">,</span> <span class="n">max_iter</span><span class="p">,</span> <span class="n">use_explicit_unitary</span><span class="o">=</span><span class="n">use_explicit_unitary</span><span class="p">)</span>
<span class="n">circ</span><span class="o">.</span><span class="n">amplitude</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="p">[</span><span class="n">target_string</span><span class="p">])</span>

<span class="c1"># Run the simulator</span>
<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">LocalSimulator</span><span class="p">):</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

<span class="c1"># Print the final amplitude of |11&gt;:</span>
<span class="n">info</span> <span class="o">=</span> <span class="s2">&quot;Maximum amplified amplitude &lt;110|Final State&gt; after approximately&quot;</span>
<span class="nb">print</span><span class="p">(</span><span class="n">info</span><span class="o">+</span><span class="s2">&quot; </span><span class="si">{}</span><span class="s2"> Grover iterations:</span><span class="se">\n</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_iter</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Amplitude &lt;11|Initial State&gt;:
 {&#39;11&#39;: (0.024997395914712332+0j)} 

Maximum amplified amplitude &lt;110|Final State&gt; after approximately 31 Grover iterations:
 {&#39;11&#39;: (0.9997837641893592+0j)}
</pre></div>
</div>
<img alt="../../../_images/956c414e5200820497ee3a45778befd9306504f4d279e009ddffb38c7a21b689.png" src="../../../_images/956c414e5200820497ee3a45778befd9306504f4d279e009ddffb38c7a21b689.png" />
</div>
</div>
</section>
<hr class="docutils" />
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this heading">#</a></h2>
<p>[1] Wikipedia: <a class="reference external" href="https://en.wikipedia.org/wiki/Amplitude_amplification">Amplitude Amplification</a>.</p>
<p>[2] G. Brassard, P. Høyer, “An exact quantum polynomial-time algorithm for Simon’s problem”, Proceedings of Fifth Israeli Symposium on Theory of Computing and Systems. IEEE Computer Society Press: 12–23, <a class="reference external" href="https://arxiv.org/abs/quant-ph/9704027">arXiv:quant-ph/9704027</a> (1997).</p>
<p>[3] G. Brassard, P. Høyer, M. Mosca, A. Tapp, “Quantum Amplitude Amplification and Estimation”, <a class="reference external" href="https://arxiv.org/pdf/quant-ph/0005055.pdf">arXiv:quant-ph/0005055</a> (2000).</p>
<p>[4] Y. Suzuki, S. Uno, R. Raymond, T. Tanaka, T. Onodera, N. Yamamoto, “Amplitude Estimation without Phase Estimation”, <a class="reference external" href="https://arxiv.org/pdf/1904.10246.pdf">arXiv:1904.10246</a> (2019).</p>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">QUANTUM AMPLITUDE AMPLIFICATION</a><ul>
<li><a class="reference internal" href="#technical-background-of-qaa">TECHNICAL BACKGROUND OF QAA</a></li>
<li><a class="reference internal" href="#circuit-implementation-of-qaa">CIRCUIT IMPLEMENTATION OF QAA</a></li>
<li><a class="reference internal" href="#imports-and-setup">IMPORTS and SETUP</a></li>
<li><a class="reference internal" href="#implementation-of-reflection-operators">IMPLEMENTATION OF REFLECTION OPERATORS</a><ul>
<li><a class="reference internal" href="#reflection-around-b-rangle-0-rangle">REFLECTION AROUND $|B\rangle |0\rangle$</a></li>
<li><a class="reference internal" href="#reflection-around-0-rangle-otimes-n-1">REFLECTION AROUND $|0\rangle^{\otimes n+1}$</a></li>
</ul>
</li>
<li><a class="reference internal" href="#visualization-of-the-circuit-for-the-reflection-mathcal-r-0">VISUALIZATION OF THE CIRCUIT FOR THE REFLECTION $\mathcal{R}_{0}$</a><ul>
<li><a class="reference internal" href="#example-circuit-with-four-qubits-and-simple-index-ordering">Example circuit with four qubits and simple index ordering:</a></li>
<li><a class="reference internal" href="#example-with-four-qubits-and-arbitrary-index-ordering">Example with four qubits and arbitrary index ordering:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-of-qaa">IMPLEMENTATION OF QAA</a></li>
<li><a class="reference internal" href="#numerical-example">NUMERICAL EXAMPLE</a></li>
<li><a class="reference internal" href="#appendix">APPENDIX</a></li>
<li><a class="reference internal" href="#appendix-alternative-run-with-amplitude-result-type">APPENDIX: ALTERNATIVE RUN WITH AMPLITUDE RESULT TYPE</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    </body>
</html>