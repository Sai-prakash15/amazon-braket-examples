<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="../../../genindex.html" /><link rel="search" title="Search" href="../../../search.html" />

    <!-- Generated with Sphinx 5.3.0 and Furo 2022.12.07 -->
        <title>QUANTUM PHASE ESTIMATION - Amazon Braket Examples documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo.css?digest=91d0f0d1c444bdcb17a68e833c7a53903343c195" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../index.html"><div class="brand">Amazon Braket Examples  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../index.html">
  
  
  <span class="sidebar-brand-text">Amazon Braket Examples  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  
</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="quantum-phase-estimation">
<h1>QUANTUM PHASE ESTIMATION<a class="headerlink" href="#quantum-phase-estimation" title="Permalink to this heading">#</a></h1>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Use Braket SDK Cost Tracking to estimate the cost to run this example</span>
<span class="kn">from</span> <span class="nn">braket.tracking</span> <span class="kn">import</span> <span class="n">Tracker</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">Tracker</span><span class="p">()</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>This tutorial provides a detailed implementation of the Quantum Phase Estimation (QPE) algorithm using the Amazon Braket SDK.
The QPE algorithm is designed to estimate the eigenvalues of a unitary operator $U$ [1, 2];
it is a very important subroutine to many quantum algorithms, most famously Shorâ€™s algorithm for factoring and the HHL algorithm (named after the physicists Harrow, Hassidim and Lloyd) for solving linear systems of equations on a quantum computer [1, 2].
Moreover, eigenvalue problems can be found across many disciplines and application areas, including (for example) principal component analysis (PCA) as used in machine learning or the solution of differential equations as relevant across mathematics, physics, engineering and chemistry.
We first review the basics of the QPE algorithm.
We then implement the QPE algorithm in code using the Amazon Braket SDK, and we illustrate the application thereof with simple examples.
This notebook also showcases the Amazon Braket <code class="docutils literal notranslate"><span class="pre">circuit.subroutine</span></code> functionality, which allows us to use custom-built gates as if they were any other built-in gates.
This tutorial is set up to run either on the local simulator or the on-demand simulators; changing between these devices merely requires changing one line of code as demonstrated as follows in cell [4].</p>
<section id="technical-background-of-qpe">
<h2>TECHNICAL BACKGROUND OF QPE<a class="headerlink" href="#technical-background-of-qpe" title="Permalink to this heading">#</a></h2>
<p><strong>Introduction</strong>: A unitary matrix is a complex, square matrix whose adjoint (or conjugate transpose) is equal to its inverse. Unitary matrices have many nice properties, including the fact that their eigenvalues are always roots of unity (that is, phases). Given a unitary matrix $U$ (satisfying $U^{\dagger}U=\mathbb{1}=UU^{\dagger}$) and an eigenstate $|\psi \rangle$ with $U|\psi \rangle = e^{2\pi i\varphi}|\psi \rangle$, the Quantum Phase Estimation (QPE) algorithm provides an estimate $\tilde{\varphi} \approx \varphi$ for the phase $\varphi$ (with $\varphi \in [0,1]$ since the eigenvalues $\lambda = \exp(2\pi i\varphi)$ of a unitary have modulus one).
The QPE works with high probability within an additive error $\varepsilon$ using $O(\log(1/\varepsilon))$ qubits (without counting the qubits used to encode the eigenstate) and $O(1/\varepsilon)$ controlled-$U$ operations [1].</p>
<p><strong>Quantum Phase Estimation Algorithm</strong>:
The QPE algorithm takes a unitary $U$ as input. For the sake of simplicity (we will generalize the discussion below), suppose that the algorithm also takes as input an eigenstate $|\psi \rangle$ fulfilling</p>
<p>$$U|\psi \rangle = \lambda |\psi \rangle,$$</p>
<p>with $\lambda = \exp(2\pi i\varphi)$.</p>
<p>QPE uses two registers of qubits: we refer to the first register as <em>precision</em> qubits (as the number of qubits $n$ in the first register sets the achievable precision of our results) and the second register as <em>query</em> qubits (as the second register hosts the eigenstate $|\psi \rangle$).
Suppose we have prepared this second register in $|\psi \rangle$.  We then prepare a uniform superposition of all basis vectors in the first register using a series of Hadamard gates.</p>
<p>Next, we apply a series of controlled-unitaries $C-U^{2^{k}}$ for different powers of $k=0,1,\dots, n-1$ (as illustrated in the circuit diagram that follows).
For example, for $k=1$ we get
\begin{equation}
\begin{split}
(|0 \rangle + |1 \rangle) |\psi \rangle  &amp; \rightarrow |0 \rangle |\psi \rangle + |1 \rangle U|\psi \rangle \
&amp; = (|0 \rangle + e^{2\pi i \varphi}|1 \rangle) |\psi \rangle.
\end{split}
\end{equation}</p>
<p>Note that the second register remains unaffected as it stays in the eigenstate $|\psi \rangle$.
However, we managed to transfer information about the phase of the eigenvalue of $U$ (that is, $\varphi$) into the first <em>precision</em> register by encoding it as a relative phase in the state of the qubits in the first register.</p>
<p>Similarly, for $k=2$ we obtain
\begin{equation}
\begin{split}
(|0 \rangle + |1 \rangle) |\psi \rangle  &amp; \rightarrow |0 \rangle |\psi \rangle + |1 \rangle U^{2}|\psi \rangle \
&amp; = (|0 \rangle + e^{2\pi i 2\varphi}|1 \rangle) |\psi \rangle,
\end{split}
\end{equation}</p>
<p>where this time we wrote $2\varphi$ into the precision register. The process is similar for all $k&gt;2$.</p>
<p>Introducing the following notation for binary fractions
$$[0. \varphi_{l}\varphi_{l+1}\dots \varphi_{m}] = \frac{\varphi_{l}}{2^{1}} + \frac{\varphi_{l+1}}{2^{2}} + \frac{\varphi_{m}}{2^{m-l+1}},$$</p>
<p>one can show that the application of a controlled unitary $C-U^{2^{k}}$ leads to the following transformation</p>
<p>\begin{equation}
\begin{split}
(|0 \rangle + |1 \rangle) |\psi \rangle  &amp; \rightarrow |0 \rangle |\psi \rangle + |1 \rangle U^{2^{k}}|\psi \rangle \
&amp; = (|0 \rangle + e^{2\pi i 2^{k}\varphi}|1 \rangle) |\psi \rangle \
&amp; = (|0 \rangle + e^{2\pi i [0.\varphi_{k+1}\dots \varphi_{n}]}|1 \rangle) |\psi \rangle,
\end{split}
\end{equation}</p>
<p>where the first $k$ bits of precision in the binary expansion (that is, those bits to the left of the decimal) can be dropped, because $e^{2\pi i \theta} = 1$ for any whole number $\theta$.</p>
<p>The QPE algorithm implements a series of these transformations for $k=0, 1, \dots, n-1$, using $n$ qubits in the precision register.
In its entirety, this sequence of controlled unitaries leads to the transformation</p>
<p>$$ |0, \dots, 0 \rangle \otimes |\psi \rangle \longrightarrow
(|0 \rangle + e^{2\pi i [0.\varphi_{n}]}|1 \rangle)
\otimes (|0 \rangle + e^{2\pi i [0.\varphi_{n-1}\varphi_{n}]}|1 \rangle)
\otimes \dots
\otimes (|0 \rangle + e^{2\pi i [0.\varphi_{1}\dots\varphi_{n}]}|1 \rangle)
\otimes |\psi \rangle.
$$</p>
<p>By inspection, one can see that the state of the register qubits above corresponds to a quantum Fourier transform of the state $|\varphi_1,\dots,\varphi_n\rangle$. Thus, the final step of the QPE algorithm is to run the <em>inverse</em> Quantum Fourier Transform (QFT) algorithm on the precision register to extract the phase information from this state. The resulting state is
$$|\varphi_{1}, \varphi_{2}, \dots, \varphi_{n}  \rangle \otimes |\psi\rangle.$$</p>
<p>Measuring the precision qubits in the computational basis then gives the classical bitstring $\varphi_{1}, \varphi_{2}, \dots, \varphi_{n}$, from which we can readily infer the phase estimate $\tilde{\varphi} = 0.\varphi_{1} \dots \varphi_{n}$ with the corresponding eigenvalue $\tilde{\lambda} = \exp(2\pi i \tilde{\varphi})$.</p>
<p><strong>Simple example for illustration</strong>: For concreteness, consider a simple example with the unitary given by the Pauli $X$ gate, $U=X$, for which $|\Psi \rangle = |+\rangle = (|0 \rangle + |1 \rangle)/\sqrt{2}$ is an eigenstate with eigenvalue $\lambda = 1$, i.e., $\varphi=0$.
This state can be prepared with a Hadamard gate as $|\Psi \rangle = H|0 \rangle$.
We take a precision register consisting of just two qubits ($n=2$).</p>
<p>Thus, after the first layer of Hadamard gates, the quantum state is
$$|0,0,0 \rangle \rightarrow |+,+,+\rangle.$$</p>
<p>Next, the applications of the controlled-$U$ gates (equal to $C-X$ operations, or CNOT gates in this example) leave this state untouched, because $|+\rangle$ is an eigenstate of $X$ with eigenvalue $+1$.
Finally, applying the inverse QFT leads to</p>
<p>$$\mathrm{QFT}^{\dagger}|+++\rangle=\mathrm{QFT}^\dagger\frac{|00\rangle + |01\rangle + |10\rangle + |11\rangle}{4}\otimes |+\rangle = |00\rangle \otimes |+\rangle,$$</p>
<p>from which we deduce $\varphi = [0.00]=0$ and therefore $\lambda=1$, as expected.
Here, in the last step we have used $|00\rangle + |01\rangle + |10\rangle + |11\rangle = (|0\rangle + e^{2\pi i[0.0]}|1\rangle)(|0\rangle + e^{2\pi i[0.00]}|1\rangle)$, which makes the effect of the inverse QFT more apparent.</p>
<p><strong>Initial state of query register</strong>: So far, we have assumed that the query register is prepared in an eigenstate $|\Psi\rangle$ of $U$. What happens if this is not the case? Letâ€™s reconsider the simple example given previously.</p>
<p>Suppose now that the query register is instead prepared in the state $|\Psi\rangle = |1\rangle$.
We can always express this state in the eigenbasis of $U$, that is, $|1\rangle = \frac{1}{\sqrt{2}}(|+\rangle - |-\rangle)$.
By linearity, application of the QPE algorithm then gives (up to normalization)</p>
<p>\begin{equation}
\begin{split}
\mathrm{QPE}(|0,0,\dots\rangle \otimes |1\rangle) &amp; = \mathrm{QPE}(|0,0,\dots\rangle \otimes |+\rangle)</p>
<ul class="simple">
<li><p>\mathrm{QPE}(|0,0,\dots\rangle \otimes |-\rangle) \
&amp; =  |\varphi_{+}\rangle \otimes |+\rangle - |\varphi_{-}\rangle \otimes |-\rangle. \
\end{split}
\end{equation}</p></li>
</ul>
<p>When we measure the precision qubits in this state, 50% of the time we will observe the eigenphase $\varphi_{+}$ and 50% of the time we will measure $\varphi_{-}$. We illustrate this example numerically as follows.</p>
<p>This example motivates the general case: we can pass a state that is not an eigenstate of $U$ to the QPE algorithm, but we may need to repeat our measurements several times in order to obtain an estimate of the desired phase.</p>
</section>
<section id="circuit-implementation-of-qpe">
<h2>CIRCUIT IMPLEMENTATION OF QPE<a class="headerlink" href="#circuit-implementation-of-qpe" title="Permalink to this heading">#</a></h2>
<p>The QPE circuit can be implemented using Hadamard gates, controlled-$U$ unitaries, and the inverse QFT (denoted as $\mathrm{QFT}^{-1}$).
The details of the calculation can be found in a number of resources (such as, [1]); we omit them here.
Following the previous discussion, the circuit that implements the QPE algorithm reads as below, where m is the size of lower query register and n is the size of upper precision register.</p>
<div align="center"><img src="circuit.png"/></div></section>
<section id="imports-and-setup">
<h2>IMPORTS and SETUP<a class="headerlink" href="#imports-and-setup" title="Permalink to this heading">#</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># general imports</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="c1"># magic word for producing visualizations in notebook</span>
<span class="o">%</span><span class="k">matplotlib</span> inline
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># AWS imports: Import Amazon Braket SDK modules</span>
<span class="kn">from</span> <span class="nn">braket.circuits</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">circuit</span>
<span class="kn">from</span> <span class="nn">braket.devices</span> <span class="kn">import</span> <span class="n">LocalSimulator</span>
<span class="kn">from</span> <span class="nn">braket.aws</span> <span class="kn">import</span> <span class="n">AwsDevice</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># local imports</span>
<span class="kn">from</span> <span class="nn">utils_qpe</span> <span class="kn">import</span> <span class="n">qpe</span><span class="p">,</span> <span class="n">run_qpe</span>

<span class="o">%</span><span class="k">load_ext</span> autoreload
<span class="o">%</span><span class="k">autoreload</span> 2
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># set up device: local simulator or the on-demand simulator</span>
<span class="n">device</span> <span class="o">=</span> <span class="n">LocalSimulator</span><span class="p">()</span>
<span class="c1"># device = AwsDevice(&quot;arn:aws:braket:::device/quantum-simulator/amazon/sv1&quot;)</span>
</pre></div>
</div>
</div>
</div>
<section id="pauli-matrices">
<h3>Pauli Matrices:<a class="headerlink" href="#pauli-matrices" title="Permalink to this heading">#</a></h3>
<p>In some of our examples, we choose the unitary $U$ to be given by the <strong>Pauli Matrices</strong>, which we thus define as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define Pauli matrices</span>
<span class="n">Id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>             <span class="c1"># Identity matrix</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span>
              <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>   <span class="c1"># Pauli X</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="n">j</span><span class="p">],</span>
              <span class="p">[</span><span class="mf">1.</span><span class="n">j</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>  <span class="c1"># Pauli Y</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
              <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">]])</span>  <span class="c1"># Pauli Z</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="implementation-of-the-qpe-circuit">
<h2>IMPLEMENTATION OF THE QPE CIRCUIT<a class="headerlink" href="#implementation-of-the-qpe-circuit" title="Permalink to this heading">#</a></h2>
<p>In <code class="docutils literal notranslate"><span class="pre">utils_qpe.py</span></code> we provide simple helper functions to implement the quantum circuit for the QPE algorithm.
Specifically, we demonstrate that such modular building blocks can be registered as subroutines, using <code class="docutils literal notranslate"><span class="pre">&#64;circuit.subroutine(register=True)</span></code>.
Moreover, we provide a helper function (called <code class="docutils literal notranslate"><span class="pre">get_qpe_phases</span></code>) to perform postprocessing based on the measurement results to extract the phase. The details of <code class="docutils literal notranslate"><span class="pre">utils_qpe.py</span></code> are shown in the Appendix.</p>
<p>To implement the unitary $C-U^{2^k}$, one can use the fact that $C-U^{2} = (C-U)(C-U)$, so that $C-U^{2^{k}}$ can be constructed by repeatedly applying the core building block $C-U$.
However, the circuit generated using this approach will have a significantly larger depth. In our implementation, we instead define the matrix $U^{2^k}$ and create the controlled $C-(U^{2^k})$ gate from that.</p>
</section>
<section id="visualization-of-the-qft-circuit">
<h2>VISUALIZATION OF THE QFT CIRCUIT<a class="headerlink" href="#visualization-of-the-qft-circuit" title="Permalink to this heading">#</a></h2>
<p>To check our implementation of the QPE circuit, we visualize this circuit for a small number of qubits.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># set total number of qubits</span>
<span class="n">precision_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">query_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>

<span class="c1"># prepare query register</span>
<span class="n">my_qpe_circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">query_qubits</span><span class="p">)</span>

<span class="c1"># set unitary</span>
<span class="n">unitary</span> <span class="o">=</span> <span class="n">X</span>

<span class="c1"># show small QPE example circuit</span>
<span class="n">my_qpe_circ</span> <span class="o">=</span> <span class="n">my_qpe_circ</span><span class="o">.</span><span class="n">qpe</span><span class="p">(</span><span class="n">precision_qubits</span><span class="p">,</span> <span class="n">query_qubits</span><span class="p">,</span> <span class="n">unitary</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;QPE CIRCUIT:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">my_qpe_circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>QPE CIRCUIT:
T  : |0|1|2| 3  |4|     5      |6|
                                  
q0 : -H---U-SWAP---PHASE(-1.57)-H-
          | |      |              
q1 : -H-U-|-SWAP-H-C--------------
        | |                       
q2 : -H-U-U-----------------------

T  : |0|1|2| 3  |4|     5      |6|
</pre></div>
</div>
</div>
</div>
<p>As shown in the following code, the two registers can be distributed anywhere across the circuit, with arbitrary indices for the precision and the query registers.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># set qubits</span>
<span class="n">precision_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">query_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span>

<span class="c1"># prepare query register</span>
<span class="n">my_qpe_circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">i</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="n">my_qpe_circ</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">query_qubits</span><span class="p">)</span>

<span class="c1"># set unitary</span>
<span class="n">unitary</span> <span class="o">=</span> <span class="n">X</span>

<span class="c1"># show small QPE example circuit</span>
<span class="n">my_qpe_circ</span> <span class="o">=</span> <span class="n">my_qpe_circ</span><span class="o">.</span><span class="n">qpe</span><span class="p">(</span><span class="n">precision_qubits</span><span class="p">,</span> <span class="n">query_qubits</span><span class="p">,</span> <span class="n">unitary</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;QPE CIRCUIT:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">my_qpe_circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>QPE CIRCUIT:
T  : |0|1|2|3| 4  |5|     6      |7|
                                    
q0 : -I-----------------------------
                                    
q1 : -I-H---U-SWAP---PHASE(-1.57)-H-
            | |      |              
q2 : -I-----|-|------|--------------
            | |      |              
q3 : -I-H-U-|-SWAP-H-C--------------
          | |                       
q4 : -I---|-|-----------------------
          | |                       
q5 : -I-H-U-U-----------------------
                                    
q6 : -I-----------------------------

T  : |0|1|2|3| 4  |5|     6      |7|
</pre></div>
</div>
</div>
</div>
<p>As follows, we set up the same circuit, this time implementing the unitary $C-U^{2^k}$, by repeatedly applying the core building block $C-U$.
This operation can be done by setting the parameter <code class="docutils literal notranslate"><span class="pre">control_unitary=False</span></code> (default is <code class="docutils literal notranslate"><span class="pre">True</span></code>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># set qubits</span>
<span class="n">precision_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">query_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span>

<span class="c1"># prepare query register</span>
<span class="n">my_qpe_circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">i</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>
<span class="n">my_qpe_circ</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">query_qubits</span><span class="p">)</span>

<span class="c1"># set unitary</span>
<span class="n">unitary</span> <span class="o">=</span> <span class="n">X</span>

<span class="c1"># show small QPE example circuit</span>
<span class="n">my_qpe_circ</span> <span class="o">=</span> <span class="n">my_qpe_circ</span><span class="o">.</span><span class="n">qpe</span><span class="p">(</span><span class="n">precision_qubits</span><span class="p">,</span> <span class="n">query_qubits</span><span class="p">,</span> <span class="n">unitary</span><span class="p">,</span> <span class="n">control_unitary</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;QPE CIRCUIT:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">my_qpe_circ</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>QPE CIRCUIT:
T  : |0|1|2|3|4| 5  |6|     7      |8|
                                      
q0 : -I-------------------------------
                                      
q1 : -I-H---U-U-SWAP---PHASE(-1.57)-H-
            | | |      |              
q2 : -I-----|-|-|------|--------------
            | | |      |              
q3 : -I-H-U-|-|-SWAP-H-C--------------
          | | |                       
q4 : -I---|-|-|-----------------------
          | | |                       
q5 : -I-H-U-U-U-----------------------
                                      
q6 : -I-------------------------------

T  : |0|1|2|3|4| 5  |6|     7      |8|
</pre></div>
</div>
</div>
</div>
<p>In the circuit diagram, we can visually infer the exponents for $k=0,1$, at the expense of a larger circuit depth.</p>
</section>
<section id="numerical-test-experiments">
<h2>NUMERICAL TEST EXPERIMENTS<a class="headerlink" href="#numerical-test-experiments" title="Permalink to this heading">#</a></h2>
<p>In the following section, we verify that our QFT implementation works as expected with a few test examples:</p>
<ol class="arabic simple">
<li><p>We run QPE with $U=X$ and prepare the eigenstate $|\Psi\rangle = |+\rangle = H|0\rangle$ with phase $\varphi=0$ and eigenvalue $\lambda=1$.</p></li>
<li><p>We run QPE with $U=X$ and prepare the eigenstate $|\Psi\rangle = |-\rangle = HX|0\rangle$ with phase $\varphi=0.5$ and eigenvalue $\lambda=-1$.</p></li>
<li><p>We run QPE with $U=X$ and prepare $|\Psi\rangle = |1\rangle = X|0\rangle$ which is <em>not</em> an eigenstate of $U$.
Because $|1\rangle = (|+\rangle - |-\rangle)/\sqrt{2}$, we expect to measure both $\varphi=0$ and $\varphi=0.5$ associated with the two eigenstates $|\pm\rangle$.</p></li>
<li><p>We run QPE with unitary $U=X \otimes Z$, and prepare the query register in the eigenstate $|\Psi\rangle = |+\rangle \otimes |1\rangle = H|0\rangle \otimes Z|0\rangle$.
Here, we expect to measure the phase $\varphi=0.5$ (giving the corresponding eigenvalue $\lambda=-1$).</p></li>
<li><p>We run QPE with a <em>random</em> two qubit unitary, diagonal in the computational basis, and prepare the query register in the eigenstate $|11\rangle$.
In this case, we should be able to read off the eigenvalue and phase from $U$ and verify QPE gives the right answer (with high probability) up to a small error (that depends on the number of qubits in the precision register).</p></li>
</ol>
</section>
<section id="helper-functions-for-numerical-tests">
<h2>HELPER FUNCTIONS FOR NUMERICAL TESTS<a class="headerlink" href="#helper-functions-for-numerical-tests" title="Permalink to this heading">#</a></h2>
<p>Because we will run the same code repeatedly, letâ€™s first create a helper function we can use to keep the notebook clean.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">postprocess_qpe_results</span><span class="p">(</span><span class="n">out</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to postprocess dictionary returned by run_qpe</span>

<span class="sd">    Args:</span>
<span class="sd">        out: dictionary containing results/information associated with QPE run as produced by run_qpe</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># unpack results</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;circuit&#39;</span><span class="p">]</span>
    <span class="n">measurement_counts</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;measurement_counts&#39;</span><span class="p">]</span>
    <span class="n">bitstring_keys</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;bitstring_keys&#39;</span><span class="p">]</span>
    <span class="n">probs_values</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;probs_values&#39;</span><span class="p">]</span>
    <span class="n">precision_results_dic</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;precision_results_dic&#39;</span><span class="p">]</span>
    <span class="n">phases_decimal</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;phases_decimal&#39;</span><span class="p">]</span>
    <span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;eigenvalues&#39;</span><span class="p">]</span>
    
    <span class="c1"># print the circuit </span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Printing circuit:&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">circ</span><span class="p">)</span>
    
    <span class="c1"># print measurement results</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Measurement counts:&#39;</span><span class="p">,</span> <span class="n">measurement_counts</span><span class="p">)</span>
    
    <span class="c1"># plot probabalities</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">bitstring_keys</span><span class="p">,</span> <span class="n">probs_values</span><span class="p">);</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;bitstrings&#39;</span><span class="p">);</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;probability&#39;</span><span class="p">);</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">);</span>

    <span class="c1"># print results</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Results in precision register:&#39;</span><span class="p">,</span> <span class="n">precision_results_dic</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;QPE phase estimates:&#39;</span><span class="p">,</span> <span class="n">phases_decimal</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;QPE eigenvalue estimates:&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<section id="numerical-test-example-1">
<h3>NUMERICAL TEST EXAMPLE 1<a class="headerlink" href="#numerical-test-example-1" title="Permalink to this heading">#</a></h3>
<p>First, apply the QPE algorithm to the simple single-qubit unitary $U=X$, with eigenstate $|\Psi\rangle = |+\rangle = H|0\rangle$. Here, we expect to measure the phase $\varphi=0$ (giving the corresponding eigenvalue $\lambda=1$).
We show that this result stays the same as we increase the number of qubits $n$ for the top register.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set total number of precision qubits: 2</span>
<span class="n">number_precision_qubits</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c1"># Define the set of precision qubits</span>
<span class="n">precision_qubits</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_precision_qubits</span><span class="p">)</span>

<span class="c1"># Define the query qubits. We&#39;ll have them start after the precision qubits</span>
<span class="n">query_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="n">number_precision_qubits</span><span class="p">]</span>

<span class="c1"># State preparation for eigenstate of U=X</span>
<span class="n">query</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">query_qubits</span><span class="p">)</span>

<span class="c1"># Run the test with U=X</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">run_qpe</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">precision_qubits</span><span class="p">,</span> <span class="n">query_qubits</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

<span class="c1"># Postprocess results</span>
<span class="n">postprocess_qpe_results</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Printing circuit:
T  : |0|1|2| 3  |4|     5      |6|Result Types|
                                               
q0 : -H---U-SWAP---PHASE(-1.57)-H-Probability--
          | |      |              |            
q1 : -H-U-|-SWAP-H-C--------------Probability--
        | |                       |            
q2 : -H-U-U-----------------------Probability--

T  : |0|1|2| 3  |4|     5      |6|Result Types|
Measurement counts: Counter({&#39;000&#39;: 504, &#39;001&#39;: 496})
Results in precision register: {&#39;00&#39;: 1000}
QPE phase estimates: [0.0]
QPE eigenvalue estimates: [1.+0.j]
</pre></div>
</div>
<img alt="../../../_images/83f0c061a0bcdd42229232c18db133ede766665ca868c1e71fc8f986198b8b73.png" src="../../../_images/83f0c061a0bcdd42229232c18db133ede766665ca868c1e71fc8f986198b8b73.png" />
</div>
</div>
<p>Next, check that we get the same result for a larger precision (top) register.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set total number of precision qubits: 3</span>
<span class="n">number_precision_qubits</span> <span class="o">=</span> <span class="mi">3</span>

<span class="c1"># Define the set of precision qubits</span>
<span class="n">precision_qubits</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_precision_qubits</span><span class="p">)</span>

<span class="c1"># Define the query qubits. We&#39;ll have them start after the precision qubits</span>
<span class="n">query_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="n">number_precision_qubits</span><span class="p">]</span>

<span class="c1"># State preparation for eigenstate of U=X</span>
<span class="n">query</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">query_qubits</span><span class="p">)</span>

<span class="c1"># Run the test with U=X</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">run_qpe</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">precision_qubits</span><span class="p">,</span> <span class="n">query_qubits</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

<span class="c1"># Postprocess results</span>
<span class="n">postprocess_qpe_results</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Printing circuit:
T  : |0|1|2|3| 4  |5|     6      |       7       |     8      |9|Result Types|
                                                                              
q0 : -H-----U-SWAP------------------PHASE(-0.785)-PHASE(-1.57)-H-Probability--
            | |                     |             |              |            
q1 : -H---U-|-|------PHASE(-1.57)-H-|-------------C--------------Probability--
          | | |      |              |                            |            
q2 : -H-U-|-|-SWAP-H-C--------------C----------------------------Probability--
        | | |                                                    |            
q3 : -H-U-U-U----------------------------------------------------Probability--

T  : |0|1|2|3| 4  |5|     6      |       7       |     8      |9|Result Types|
Measurement counts: Counter({&#39;0000&#39;: 504, &#39;0001&#39;: 496})
Results in precision register: {&#39;000&#39;: 1000}
QPE phase estimates: [0.0]
QPE eigenvalue estimates: [1.+0.j]
</pre></div>
</div>
<img alt="../../../_images/e4954239452a0b46b782175ef2901b91bd7df942d11f2ecd0e8737b600799bb9.png" src="../../../_images/e4954239452a0b46b782175ef2901b91bd7df942d11f2ecd0e8737b600799bb9.png" />
</div>
</div>
</section>
<section id="numerical-test-example-2">
<h3>NUMERICAL TEST EXAMPLE 2<a class="headerlink" href="#numerical-test-example-2" title="Permalink to this heading">#</a></h3>
<p>Next, apply the QPE algorithm to the simple single-qubit unitary $U=X$, with eigenstate $|\Psi\rangle = |-\rangle = HX|0\rangle$.
Here, we expect to measure the phase $\varphi=0.5$ (giving the corresponding eigenvalue $\lambda=-1$).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set total number of precision qubits: 2</span>
<span class="n">number_precision_qubits</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c1"># Define the set of precision qubits</span>
<span class="n">precision_qubits</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_precision_qubits</span><span class="p">)</span>

<span class="c1"># Define the query qubits. We&#39;ll have them start after the precision qubits</span>
<span class="n">query_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="n">number_precision_qubits</span><span class="p">]</span>

<span class="c1"># State preparation for eigenstate of U=X</span>
<span class="n">query</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">query_qubits</span><span class="p">)</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">query_qubits</span><span class="p">)</span>

<span class="c1"># Run the test with U=X</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">run_qpe</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">precision_qubits</span><span class="p">,</span> <span class="n">query_qubits</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

<span class="c1"># Postprocess results</span>
<span class="n">postprocess_qpe_results</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Printing circuit:
T  : |0|1|2|3| 4  |5|     6      |7|Result Types|
                                                 
q0 : -H-----U-SWAP---PHASE(-1.57)-H-Probability--
            | |      |              |            
q1 : -H---U-|-SWAP-H-C--------------Probability--
          | |                       |            
q2 : -X-H-U-U-----------------------Probability--

T  : |0|1|2|3| 4  |5|     6      |7|Result Types|
Measurement counts: Counter({&#39;100&#39;: 516, &#39;101&#39;: 484})
Results in precision register: {&#39;10&#39;: 1000}
QPE phase estimates: [0.5]
QPE eigenvalue estimates: [-1.+0.j]
</pre></div>
</div>
<img alt="../../../_images/35501305495917f9a6a6ee3e1a696f19a116757f03537ac9d6cc55c8b15f919a.png" src="../../../_images/35501305495917f9a6a6ee3e1a696f19a116757f03537ac9d6cc55c8b15f919a.png" />
</div>
</div>
</section>
<section id="numerical-test-example-3">
<h3>NUMERICAL TEST EXAMPLE 3<a class="headerlink" href="#numerical-test-example-3" title="Permalink to this heading">#</a></h3>
<p>Next, apply the QPE algorithm again to the simple single-qubit unitary $U=X$, but we initialize the query register in the state $|\Psi\rangle = |1\rangle$ which is <em>not</em> an eigenstate of $U$.
Here, following the previous discussion, we expect to measure the phases $\varphi=0, 0.5$ (giving the corresponding eigenvalue $\lambda=\pm 1$). Accordingly, here we set <code class="docutils literal notranslate"><span class="pre">items_to_keep=2</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set total number of precision qubits: 2</span>
<span class="n">number_precision_qubits</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c1"># Define the set of precision qubits</span>
<span class="n">precision_qubits</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_precision_qubits</span><span class="p">)</span>

<span class="c1"># Define the query qubits. We&#39;ll have them start after the precision qubits</span>
<span class="n">query_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="n">number_precision_qubits</span><span class="p">]</span>

<span class="c1"># State preparation for |1&gt;, which is not an eigenstate of U=X</span>
<span class="n">query</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">query_qubits</span><span class="p">)</span>

<span class="c1"># Run the test with U=X</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">run_qpe</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">precision_qubits</span><span class="p">,</span> <span class="n">query_qubits</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">items_to_keep</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Postprocess results</span>
<span class="n">postprocess_qpe_results</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Printing circuit:
T  : |0|1|2| 3  |4|     5      |6|Result Types|
                                               
q0 : -H---U-SWAP---PHASE(-1.57)-H-Probability--
          | |      |              |            
q1 : -H-U-|-SWAP-H-C--------------Probability--
        | |                       |            
q2 : -X-U-U-----------------------Probability--

T  : |0|1|2| 3  |4|     5      |6|Result Types|
Measurement counts: Counter({&#39;000&#39;: 261, &#39;100&#39;: 256, &#39;101&#39;: 242, &#39;001&#39;: 241})
Results in precision register: {&#39;10&#39;: 498, &#39;00&#39;: 502}
QPE phase estimates: [0.0, 0.5]
QPE eigenvalue estimates: [ 1.+0.j -1.+0.j]
</pre></div>
</div>
<img alt="../../../_images/830a94afa80a8a6e11ef5cddecfa4282d805093609ed758743a3d31f27281ca7.png" src="../../../_images/830a94afa80a8a6e11ef5cddecfa4282d805093609ed758743a3d31f27281ca7.png" />
</div>
</div>
</section>
<section id="numerical-test-example-4">
<h3>NUMERICAL TEST EXAMPLE 4<a class="headerlink" href="#numerical-test-example-4" title="Permalink to this heading">#</a></h3>
<p>Next, apply the QPE algorithm to the two-qubit unitary $U=X \otimes Z$, and prepare the query register in the eigenstate $|\Psi\rangle = |+\rangle \otimes |1\rangle = H|0\rangle \otimes X|0\rangle$.
Here, we expect to measure the phase $\varphi=0.5$ (giving the corresponding eigenvalue $\lambda=-1$).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># set unitary matrix U</span>
<span class="n">u1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Id</span><span class="p">)</span> 
<span class="n">u2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">Id</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
<span class="n">unitary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">u1</span><span class="p">,</span> <span class="n">u2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Two-qubit unitary (XZ):</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">unitary</span><span class="p">)</span>

<span class="c1"># get example eigensystem </span>
<span class="n">eig_values</span><span class="p">,</span> <span class="n">eig_vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">unitary</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Eigenvalues:&#39;</span><span class="p">,</span> <span class="n">eig_values</span><span class="p">)</span>
<span class="c1"># print(&#39;Eigenvectors:&#39;, eig_vectors)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Two-qubit unitary (XZ):
 [[ 0.  0.  1.  0.]
 [ 0.  0.  0. -1.]
 [ 1.  0.  0.  0.]
 [ 0. -1.  0.  0.]]
Eigenvalues: [ 1. -1.  1. -1.]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set total number of precision qubits: 2</span>
<span class="n">number_precision_qubits</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c1"># Define the set of precision qubits</span>
<span class="n">precision_qubits</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_precision_qubits</span><span class="p">)</span>

<span class="c1"># Define the query qubits. We&#39;ll have them start after the precision qubits</span>
<span class="n">query_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="n">number_precision_qubits</span><span class="p">,</span> <span class="n">number_precision_qubits</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># State preparation for eigenstate |+,1&gt; of U=X \otimes Z</span>
<span class="n">query</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">query_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">query_qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># Run the test with U=X</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">run_qpe</span><span class="p">(</span><span class="n">unitary</span><span class="p">,</span> <span class="n">precision_qubits</span><span class="p">,</span> <span class="n">query_qubits</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

<span class="c1"># Postprocess results</span>
<span class="n">postprocess_qpe_results</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Printing circuit:
T  : |0|1|2| 3  |4|     5      |6|Result Types|
                                               
q0 : -H---U-SWAP---PHASE(-1.57)-H-Probability--
          | |      |              |            
q1 : -H-U-|-SWAP-H-C--------------Probability--
        | |                       |            
q2 : -H-U-U-----------------------Probability--
        | |                       |            
q3 : -X-U-U-----------------------Probability--

T  : |0|1|2| 3  |4|     5      |6|Result Types|
Measurement counts: Counter({&#39;1011&#39;: 503, &#39;1001&#39;: 497})
Results in precision register: {&#39;10&#39;: 1000}
QPE phase estimates: [0.5]
QPE eigenvalue estimates: [-1.+0.j]
</pre></div>
</div>
<img alt="../../../_images/4cd736efceb7d8284c0ae4d49f772b4556e5df18b8da39b396f9bd3210d9870f.png" src="../../../_images/4cd736efceb7d8284c0ae4d49f772b4556e5df18b8da39b396f9bd3210d9870f.png" />
</div>
</div>
</section>
<section id="numerical-test-example-5">
<h3>NUMERICAL TEST EXAMPLE 5<a class="headerlink" href="#numerical-test-example-5" title="Permalink to this heading">#</a></h3>
<p>In this example, we choose the unitary to be a <em>random</em> two-qubit unitary, diagonal in the computational basis. We initialize the query register to be in the eigenstate $|11\rangle$ of $U$, which we can prepare using that $|11\rangle = X\otimes X|00\rangle$.
In this case we should be able to read off the eigenvalue and phase from $U$ and verify that QPE gives the right answer.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generate a random 2 qubit unitary matrix:</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">unitary_group</span>

<span class="c1"># Fix random seed for reproducibility</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Get random two-qubit unitary</span>
<span class="n">random_unitary</span> <span class="o">=</span> <span class="n">unitary_group</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Let&#39;s diagonalize this</span>
<span class="n">evals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">random_unitary</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

<span class="c1"># Since we want to be able to read off the eigenvalues of the unitary in question</span>
<span class="c1"># let&#39;s choose our unitary to be diagonal in this basis</span>
<span class="n">unitary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">evals</span><span class="p">)</span>

<span class="c1"># Check that this is indeed unitary, and print it out:</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Two-qubit random unitary:</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">unitary</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Check for unitarity: &#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unitary</span><span class="p">)),</span> <span class="n">unitary</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">unitary</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">())))</span>

<span class="c1"># Print eigenvalues</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Eigenvalues:&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">evals</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Two-qubit random unitary:
 [[-0.078+0.997j  0.   +0.j     0.   +0.j     0.   +0.j   ]
 [ 0.   +0.j    -0.987-0.159j  0.   +0.j     0.   +0.j   ]
 [ 0.   +0.j     0.   +0.j     0.192-0.981j  0.   +0.j   ]
 [ 0.   +0.j     0.   +0.j     0.   +0.j     0.747-0.665j]]
Check for unitarity:  True
Eigenvalues: [-0.078+0.997j -0.987-0.159j  0.192-0.981j  0.747-0.665j]
</pre></div>
</div>
</div>
</div>
<p>When we execute the QPE circuit, we expect the following (approximate) result for the eigenvalue estimate:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Target eigenvalue:&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">evals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Target eigenvalue: (0.747-0.665j)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set total number of precision qubits</span>
<span class="n">number_precision_qubits</span> <span class="o">=</span> <span class="mi">3</span>

<span class="c1"># Define the set of precision qubits</span>
<span class="n">precision_qubits</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_precision_qubits</span><span class="p">)</span>

<span class="c1"># Define the query qubits. We&#39;ll have them start after the precision qubits</span>
<span class="n">query_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="n">number_precision_qubits</span><span class="p">,</span> <span class="n">number_precision_qubits</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># State preparation for eigenstate |1,1&gt; of diagonal U</span>
<span class="n">query</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">query_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">query_qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># Run the test with U=X</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">run_qpe</span><span class="p">(</span><span class="n">unitary</span><span class="p">,</span> <span class="n">precision_qubits</span><span class="p">,</span> <span class="n">query_qubits</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

<span class="c1"># Postprocess results</span>
<span class="n">postprocess_qpe_results</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

<span class="c1"># compare output to exact target values</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Target eigenvalue:&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">evals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Printing circuit:
T  : |0|1|2|3| 4  |5|     6      |       7       |     8      |9|Result Types|
                                                                              
q0 : -H-----U-SWAP------------------PHASE(-0.785)-PHASE(-1.57)-H-Probability--
            | |                     |             |              |            
q1 : -H---U-|-|------PHASE(-1.57)-H-|-------------C--------------Probability--
          | | |      |              |                            |            
q2 : -H-U-|-|-SWAP-H-C--------------C----------------------------Probability--
        | | |                                                    |            
q3 : -X-U-U-U----------------------------------------------------Probability--
        | | |                                                    |            
q4 : -X-U-U-U----------------------------------------------------Probability--

T  : |0|1|2|3| 4  |5|     6      |       7       |     8      |9|Result Types|
Measurement counts: Counter({&#39;11111&#39;: 986, &#39;11011&#39;: 8, &#39;00011&#39;: 3, &#39;01011&#39;: 1, &#39;10011&#39;: 1, &#39;10111&#39;: 1})
Results in precision register: {&#39;100&#39;: 1, &#39;101&#39;: 1, &#39;111&#39;: 986, &#39;000&#39;: 3, &#39;010&#39;: 1, &#39;110&#39;: 8}
QPE phase estimates: [0.875]
QPE eigenvalue estimates: [0.70711-0.70711j]
Target eigenvalue: (0.747-0.665j)
</pre></div>
</div>
<img alt="../../../_images/241bdaedce734ee53c34200a5a728fe45b1d059823d200e1ba22f9d5fc530a07.png" src="../../../_images/241bdaedce734ee53c34200a5a728fe45b1d059823d200e1ba22f9d5fc530a07.png" />
</div>
</div>
<p>We can easily improve the precision of our parameter estimate by increasing the number of qubits in the precision register, as shown in the following example.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set total number of precision qubits</span>
<span class="n">number_precision_qubits</span> <span class="o">=</span> <span class="mi">10</span>

<span class="c1"># Define the set of precision qubits</span>
<span class="n">precision_qubits</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_precision_qubits</span><span class="p">)</span>

<span class="c1"># Define the query qubits. We&#39;ll have them start after the precision qubits</span>
<span class="n">query_qubits</span> <span class="o">=</span> <span class="p">[</span><span class="n">number_precision_qubits</span><span class="p">,</span> <span class="n">number_precision_qubits</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># State preparation for eigenstate |1,1&gt; of diagonal U</span>
<span class="n">query</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">query_qubits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">x</span><span class="p">(</span><span class="n">query_qubits</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># Run the test with U=X</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">run_qpe</span><span class="p">(</span><span class="n">unitary</span><span class="p">,</span> <span class="n">precision_qubits</span><span class="p">,</span> <span class="n">query_qubits</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span> <span class="n">device</span><span class="p">)</span>

<span class="c1"># Postprocess results</span>
<span class="n">eigenvalues</span> <span class="o">=</span> <span class="n">out</span><span class="p">[</span><span class="s1">&#39;eigenvalues&#39;</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;QPE eigenvalue estimates:&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="c1"># compare output to exact target values</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Target eigenvalue:&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">evals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>QPE eigenvalue estimates: [0.74506-0.667j]
Target eigenvalue: (0.74699-0.66484j)
</pre></div>
</div>
</div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="appendix">
<h2>APPENDIX<a class="headerlink" href="#appendix" title="Permalink to this heading">#</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Check SDK version</span>
<span class="c1"># alternative: braket.__version__</span>
<span class="o">!</span>pip show amazon-braket-sdk <span class="p">|</span> grep Version
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Version: 0.6.0
</pre></div>
</div>
</div>
</div>
</section>
<section id="details-of-the-utiles-qpe-py-module">
<h2>Details of the <code class="docutils literal notranslate"><span class="pre">utiles_qpe.py</span></code> module<a class="headerlink" href="#details-of-the-utiles-qpe-py-module" title="Permalink to this heading">#</a></h2>
<section id="imports-including-inverse-qft">
<h3>Imports, including inverse QFT<a class="headerlink" href="#imports-including-inverse-qft" title="Permalink to this heading">#</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># general imports</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="c1"># AWS imports: Import Braket SDK modules</span>
<span class="kn">from</span> <span class="nn">braket.circuits</span> <span class="kn">import</span> <span class="n">Circuit</span><span class="p">,</span> <span class="n">circuit</span>

<span class="c1"># local imports</span>
<span class="kn">from</span> <span class="nn">utils_qft</span> <span class="kn">import</span> <span class="n">inverse_qft</span>
</pre></div>
</div>
</section>
<section id="qpe-subroutine">
<h3>QPE Subroutine<a class="headerlink" href="#qpe-subroutine" title="Permalink to this heading">#</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nd">@circuit</span><span class="o">.</span><span class="n">subroutine</span><span class="p">(</span><span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">controlled_unitary</span><span class="p">(</span><span class="n">control</span><span class="p">,</span> <span class="n">target_qubits</span><span class="p">,</span> <span class="n">unitary</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a circuit object corresponding to the controlled unitary</span>

<span class="sd">    Args:</span>
<span class="sd">        control: The qubit on which to control the gate</span>

<span class="sd">        target_qubits: List of qubits on which the unitary U acts</span>

<span class="sd">        unitary: matrix representation of the unitary we wish to implement in a controlled way</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Define projectors onto the computational basis</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
                   <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]])</span>

    <span class="n">p1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
                   <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>

    <span class="c1"># Instantiate circuit object</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>

    <span class="c1"># Construct numpy matrix</span>
    <span class="n">id_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unitary</span><span class="p">))</span>
    <span class="n">controlled_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">p0</span><span class="p">,</span> <span class="n">id_matrix</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">unitary</span><span class="p">)</span>

    <span class="c1"># Set all target qubits</span>
    <span class="n">targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">control</span><span class="p">]</span> <span class="o">+</span> <span class="n">target_qubits</span>

    <span class="c1"># Add controlled unitary</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">unitary</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">controlled_matrix</span><span class="p">,</span> <span class="n">targets</span><span class="o">=</span><span class="n">targets</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">circ</span>


<span class="nd">@circuit</span><span class="o">.</span><span class="n">subroutine</span><span class="p">(</span><span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">qpe</span><span class="p">(</span><span class="n">precision_qubits</span><span class="p">,</span> <span class="n">query_qubits</span><span class="p">,</span> <span class="n">unitary</span><span class="p">,</span> <span class="n">control_unitary</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to implement the QPE algorithm using two registers for precision (read-out) and query.</span>
<span class="sd">    Register qubits need not be contiguous.</span>

<span class="sd">    Args:</span>
<span class="sd">        precision_qubits: list of qubits defining the precision register</span>

<span class="sd">        query_qubits: list of qubits defining the query register</span>

<span class="sd">        unitary: Matrix representation of the unitary whose eigenvalues we wish to estimate</span>

<span class="sd">        control_unitary: Optional boolean flag for controlled unitaries,</span>
<span class="sd">                         with C-(U^{2^k}) by default (default is True),</span>
<span class="sd">                         or C-U controlled-unitary (2**power) times</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">qpe_circ</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">()</span>

    <span class="c1"># Get number of qubits</span>
    <span class="n">num_precision_qubits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">precision_qubits</span><span class="p">)</span>
    <span class="n">num_query_qubits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">query_qubits</span><span class="p">)</span>

    <span class="c1"># Apply Hadamard across precision register</span>
    <span class="n">qpe_circ</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="n">precision_qubits</span><span class="p">)</span>

    <span class="c1"># Apply controlled unitaries. Start with the last precision_qubit, and end with the first</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">precision_qubits</span><span class="p">)):</span>
        <span class="c1"># Set power exponent for unitary</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">ii</span>

        <span class="c1"># Alterantive 1: Implement C-(U^{2^k})</span>
        <span class="k">if</span> <span class="n">control_unitary</span><span class="p">:</span>
            <span class="c1"># Define the matrix U^{2^k}</span>
            <span class="n">Uexp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_power</span><span class="p">(</span><span class="n">unitary</span><span class="p">,</span><span class="mi">2</span><span class="o">**</span><span class="n">power</span><span class="p">)</span>

            <span class="c1"># Apply the controlled unitary C-(U^{2^k})</span>
            <span class="n">qpe_circ</span><span class="o">.</span><span class="n">controlled_unitary</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="n">query_qubits</span><span class="p">,</span> <span class="n">Uexp</span><span class="p">)</span>
        <span class="c1"># Alterantive 2: One can instead apply controlled-unitary (2**power) times to get C-U^{2^power}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">power</span><span class="p">):</span>
                <span class="n">qpe_circ</span><span class="o">.</span><span class="n">controlled_unitary</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="n">query_qubits</span><span class="p">,</span> <span class="n">unitary</span><span class="p">)</span>

    <span class="c1"># Apply inverse qft to the precision_qubits</span>
    <span class="n">qpe_circ</span><span class="o">.</span><span class="n">inverse_qft</span><span class="p">(</span><span class="n">precision_qubits</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">qpe_circ</span>
</pre></div>
</div>
</section>
<section id="qpe-postprocessing-helper-functions">
<h3>QPE postprocessing helper functions<a class="headerlink" href="#qpe-postprocessing-helper-functions" title="Permalink to this heading">#</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># helper function to remove query bits from bitstrings</span>
<span class="k">def</span> <span class="nf">substring</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">precision_qubits</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to get substring from keys for dedicated string positions as given by precision_qubits.</span>
<span class="sd">    This function is necessary to allow for arbitrary qubit mappings in the precision and query registers</span>
<span class="sd">    (that is, so that the register qubits need not be contiguous.)</span>

<span class="sd">    Args:</span>
<span class="sd">        key: string from which we want to extract the substring supported only on the precision qubits</span>

<span class="sd">        precision_qubits: List of qubits corresponding to precision_qubits.</span>
<span class="sd">                          Currently assumed to be a list of integers corresponding to the indices of the qubits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">short_key</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">precision_qubits</span><span class="p">:</span>
        <span class="n">short_key</span> <span class="o">=</span> <span class="n">short_key</span> <span class="o">+</span> <span class="n">key</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">short_key</span>


<span class="c1"># helper function to convert binary fractional to decimal</span>
<span class="c1"># reference: https://www.geeksforgeeks.org/convert-binary-fraction-decimal/</span>
<span class="k">def</span> <span class="nf">binaryToDecimal</span><span class="p">(</span><span class="n">binary</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to convert binary string (example: &#39;01001&#39;) to decimal</span>

<span class="sd">    Args:</span>
<span class="sd">        binary: string which to convert to decimal fraction</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">binary</span><span class="p">)</span>
    <span class="n">fracDecimal</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Convert fractional part of binary to decimal equivalent</span>
    <span class="n">twos</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
        <span class="n">fracDecimal</span> <span class="o">+=</span> <span class="p">((</span><span class="nb">ord</span><span class="p">(</span><span class="n">binary</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">))</span> <span class="o">/</span> <span class="n">twos</span><span class="p">);</span>
        <span class="n">twos</span> <span class="o">*=</span> <span class="mf">2.0</span>

    <span class="c1"># return fractional part</span>
    <span class="k">return</span> <span class="n">fracDecimal</span>


<span class="c1"># helper function for postprocessing based on measurement shots</span>
<span class="k">def</span> <span class="nf">get_qpe_phases</span><span class="p">(</span><span class="n">measurement_counts</span><span class="p">,</span> <span class="n">precision_qubits</span><span class="p">,</span> <span class="n">items_to_keep</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get QPE phase estimate from measurement_counts for given number of precision qubits</span>

<span class="sd">    Args:</span>
<span class="sd">        measurement_counts: measurement results from a device run</span>

<span class="sd">        precision_qubits: List of qubits corresponding to precision_qubits.</span>
<span class="sd">                          Currently assumed to be a list of integers corresponding to the indices of the qubits</span>

<span class="sd">        items_to_keep: number of items to return (topmost measurement counts for precision register)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Aggregate the results (that is, ignore the query register qubits):</span>

    <span class="c1"># First get bitstrings with corresponding counts for precision qubits only</span>
    <span class="n">bitstrings_precision_register</span> <span class="o">=</span> <span class="p">[</span><span class="n">substring</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">precision_qubits</span><span class="p">)</span>  <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">measurement_counts</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
    <span class="c1"># Then keep only the unique strings</span>
    <span class="n">bitstrings_precision_register_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bitstrings_precision_register</span><span class="p">)</span>
    <span class="c1"># Cast as a list for later use</span>
    <span class="n">bitstrings_precision_register_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bitstrings_precision_register_set</span><span class="p">)</span>

    <span class="c1"># Now create a new dict to collect measurement results on the precision_qubits.</span>
    <span class="c1"># Keys are given by the measurement count substrings on the register qubits. Initialize the counts to zero.</span>
    <span class="n">precision_results_dic</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">bitstrings_precision_register_list</span><span class="p">}</span>

    <span class="c1"># Loop over all measurement outcomes</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">measurement_counts</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="c1"># Save the measurement count for this outcome</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="n">measurement_counts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="c1"># Generate the corresponding shortened key (supported only on the precision_qubits register)</span>
        <span class="n">count_key</span> <span class="o">=</span> <span class="n">substring</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">precision_qubits</span><span class="p">)</span>
        <span class="c1"># Add these measurement counts to the corresponding key in our new dict</span>
        <span class="n">precision_results_dic</span><span class="p">[</span><span class="n">count_key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">counts</span>

    <span class="c1"># Get topmost values only</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">precision_results_dic</span><span class="p">)</span>
    <span class="n">topmost</span><span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">most_common</span><span class="p">(</span><span class="n">items_to_keep</span><span class="p">)</span>
    <span class="c1"># get decimal phases from bitstrings for topmost bitstrings</span>
    <span class="n">phases_decimal</span> <span class="o">=</span> <span class="p">[</span><span class="n">binaryToDecimal</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">topmost</span><span class="p">]</span>

    <span class="c1"># Get decimal phases from bitstrings for all bitstrings</span>
    <span class="c1"># number_precision_qubits = len(precision_qubits)</span>
    <span class="c1"># Generate binary decimal expansion</span>
    <span class="c1"># phases_decimal = [int(key, 2)/(2**number_precision_qubits) for key in precision_results_dic]</span>
    <span class="c1"># phases_decimal = [binaryToDecimal(key) for key in precision_results_dic]</span>

    <span class="k">return</span> <span class="n">phases_decimal</span><span class="p">,</span> <span class="n">precision_results_dic</span>
</pre></div>
</div>
</section>
<section id="run-qpe-experiments">
<h3>Run QPE experiments:<a class="headerlink" href="#run-qpe-experiments" title="Permalink to this heading">#</a></h3>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">run_qpe</span><span class="p">(</span><span class="n">unitary</span><span class="p">,</span> <span class="n">precision_qubits</span><span class="p">,</span> <span class="n">query_qubits</span><span class="p">,</span> <span class="n">query_circuit</span><span class="p">,</span>
            <span class="n">device</span><span class="p">,</span> <span class="n">items_to_keep</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">save_to_pck</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function to run QPE algorithm end-to-end and return measurement counts.</span>

<span class="sd">    Args:</span>
<span class="sd">        precision_qubits: list of qubits defining the precision register</span>

<span class="sd">        query_qubits: list of qubits defining the query register</span>

<span class="sd">        unitary: Matrix representation of the unitary whose eigenvalues we wish to estimate</span>

<span class="sd">        query_circuit: query circuit for state preparation of query register</span>

<span class="sd">        items_to_keep: (optional) number of items to return (topmost measurement counts for precision register)</span>

<span class="sd">        device: Braket device backend</span>

<span class="sd">        shots: (optional) number of measurement shots (default is 1000)</span>

<span class="sd">        save_to_pck: (optional) save results to pickle file if True (default is False)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># get size of precision register and total number of qubits</span>
    <span class="n">number_precision_qubits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">precision_qubits</span><span class="p">)</span>
    <span class="n">num_qubits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">precision_qubits</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">query_qubits</span><span class="p">)</span>

    <span class="c1"># Define the circuit. Start by copying the query_circuit, then add the QPE:</span>
    <span class="n">circ</span> <span class="o">=</span> <span class="n">query_circuit</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">qpe</span><span class="p">(</span><span class="n">precision_qubits</span><span class="p">,</span> <span class="n">query_qubits</span><span class="p">,</span> <span class="n">unitary</span><span class="p">)</span>

    <span class="c1"># Add desired results_types</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">probability</span><span class="p">()</span>

    <span class="c1"># Run the circuit with all zeros input.</span>
    <span class="c1"># The query_circuit subcircuit generates the desired input from all zeros.</span>
    <span class="c1"># The following code executes the correct device.run call, depending on whether the backend is local or on-demand</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">device</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">shots</span><span class="o">=</span><span class="n">shots</span><span class="p">)</span>

    <span class="c1"># get result for this task</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">task</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

    <span class="c1"># get metadata</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">task_metadata</span>

    <span class="c1"># get output probabilities (see result_types above)</span>
    <span class="n">probs_values</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># get measurement results</span>
    <span class="n">measurements</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">measurements</span>
    <span class="n">measured_qubits</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">measured_qubits</span>
    <span class="n">measurement_counts</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">measurement_counts</span>
    <span class="n">measurement_probabilities</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">measurement_probabilities</span>

    <span class="c1"># bitstrings</span>
    <span class="n">format_bitstring</span> <span class="o">=</span> <span class="s1">&#39;{0:0&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;b}&#39;</span>
    <span class="n">bitstring_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">format_bitstring</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">num_qubits</span><span class="p">)]</span>

    <span class="c1"># QPE postprocessing</span>
    <span class="n">phases_decimal</span><span class="p">,</span> <span class="n">precision_results_dic</span> <span class="o">=</span> <span class="n">get_qpe_phases</span><span class="p">(</span><span class="n">measurement_counts</span><span class="p">,</span> <span class="n">precision_qubits</span><span class="p">,</span> <span class="n">items_to_keep</span><span class="p">)</span>
    <span class="n">eigenvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">phase</span><span class="p">)</span> <span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="n">phases_decimal</span><span class="p">]</span>

    <span class="c1"># aggregate results</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;circuit&#39;</span><span class="p">:</span> <span class="n">circ</span><span class="p">,</span>
           <span class="s1">&#39;task_metadata&#39;</span><span class="p">:</span> <span class="n">metadata</span><span class="p">,</span>
           <span class="s1">&#39;measurements&#39;</span><span class="p">:</span> <span class="n">measurements</span><span class="p">,</span>
           <span class="s1">&#39;measured_qubits&#39;</span><span class="p">:</span> <span class="n">measured_qubits</span><span class="p">,</span>
           <span class="s1">&#39;measurement_counts&#39;</span><span class="p">:</span> <span class="n">measurement_counts</span><span class="p">,</span>
           <span class="s1">&#39;measurement_probabilities&#39;</span><span class="p">:</span> <span class="n">measurement_probabilities</span><span class="p">,</span>
           <span class="s1">&#39;probs_values&#39;</span><span class="p">:</span> <span class="n">probs_values</span><span class="p">,</span>
           <span class="s1">&#39;bitstring_keys&#39;</span><span class="p">:</span> <span class="n">bitstring_keys</span><span class="p">,</span>
           <span class="s1">&#39;precision_results_dic&#39;</span><span class="p">:</span> <span class="n">precision_results_dic</span><span class="p">,</span>
           <span class="s1">&#39;phases_decimal&#39;</span><span class="p">:</span> <span class="n">phases_decimal</span><span class="p">,</span>
           <span class="s1">&#39;eigenvalues&#39;</span><span class="p">:</span> <span class="n">eigenvalues</span><span class="p">}</span>

    <span class="k">if</span> <span class="n">save_to_pck</span><span class="p">:</span>
        <span class="c1"># store results: dump output to pickle with timestamp in filename</span>
        <span class="n">time_now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">(),</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">%H%M%S&#39;</span><span class="p">)</span>
        <span class="n">results_file</span> <span class="o">=</span> <span class="s1">&#39;results-&#39;</span><span class="o">+</span><span class="n">time_now</span><span class="o">+</span><span class="s1">&#39;.pck&#39;</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">results_file</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">))</span>
        <span class="c1"># you can load results as follows</span>
        <span class="c1"># out = pickle.load(open(results_file, &quot;rb&quot;))</span>

    <span class="k">return</span> <span class="n">out</span>
</pre></div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="references">
<h2>REFERENCES<a class="headerlink" href="#references" title="Permalink to this heading">#</a></h2>
<p>[1] Wikipedia: https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm</p>
<p>[2] Nielsen, Michael A., Chuang, Isaac L. (2010). Quantum Computation and Quantum Information (2nd ed.). Cambridge: Cambridge University Press.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Task Summary&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">quantum_tasks_statistics</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Note: Charges shown are estimates based on your Amazon Braket simulator and quantum processing unit (QPU) task usage. Estimated charges shown may differ from your actual charges. Estimated charges do not factor in any discounts or credits, and you may experience additional charges based on your use of other services such as Amazon Elastic Compute Cloud (Amazon EC2).&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Estimated cost to run this example: </span><span class="si">{</span><span class="n">t</span><span class="o">.</span><span class="n">qpu_tasks_cost</span><span class="p">()</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">simulator_tasks_cost</span><span class="p">()</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> USD&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Task Summary
{}
Note: Charges shown are estimates based on your Amazon Braket simulator and quantum processing unit (QPU) task usage. Estimated charges shown may differ from your actual charges. Estimated charges do not factor in any discounts or credits, and you may experience additional charges based on your use of other services such as Amazon Elastic Compute Cloud (Amazon EC2).
Estimated cost to run this example: 0.00 USD
</pre></div>
</div>
</div>
</div>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">QUANTUM PHASE ESTIMATION</a><ul>
<li><a class="reference internal" href="#technical-background-of-qpe">TECHNICAL BACKGROUND OF QPE</a></li>
<li><a class="reference internal" href="#circuit-implementation-of-qpe">CIRCUIT IMPLEMENTATION OF QPE</a></li>
<li><a class="reference internal" href="#imports-and-setup">IMPORTS and SETUP</a><ul>
<li><a class="reference internal" href="#pauli-matrices">Pauli Matrices:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementation-of-the-qpe-circuit">IMPLEMENTATION OF THE QPE CIRCUIT</a></li>
<li><a class="reference internal" href="#visualization-of-the-qft-circuit">VISUALIZATION OF THE QFT CIRCUIT</a></li>
<li><a class="reference internal" href="#numerical-test-experiments">NUMERICAL TEST EXPERIMENTS</a></li>
<li><a class="reference internal" href="#helper-functions-for-numerical-tests">HELPER FUNCTIONS FOR NUMERICAL TESTS</a><ul>
<li><a class="reference internal" href="#numerical-test-example-1">NUMERICAL TEST EXAMPLE 1</a></li>
<li><a class="reference internal" href="#numerical-test-example-2">NUMERICAL TEST EXAMPLE 2</a></li>
<li><a class="reference internal" href="#numerical-test-example-3">NUMERICAL TEST EXAMPLE 3</a></li>
<li><a class="reference internal" href="#numerical-test-example-4">NUMERICAL TEST EXAMPLE 4</a></li>
<li><a class="reference internal" href="#numerical-test-example-5">NUMERICAL TEST EXAMPLE 5</a></li>
</ul>
</li>
<li><a class="reference internal" href="#appendix">APPENDIX</a></li>
<li><a class="reference internal" href="#details-of-the-utiles-qpe-py-module">Details of the <code class="docutils literal notranslate"><span class="pre">utiles_qpe.py</span></code> module</a><ul>
<li><a class="reference internal" href="#imports-including-inverse-qft">Imports, including inverse QFT</a></li>
<li><a class="reference internal" href="#qpe-subroutine">QPE Subroutine</a></li>
<li><a class="reference internal" href="#qpe-postprocessing-helper-functions">QPE postprocessing helper functions</a></li>
<li><a class="reference internal" href="#run-qpe-experiments">Run QPE experiments:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">REFERENCES</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/scripts/furo.js"></script>
    </body>
</html>